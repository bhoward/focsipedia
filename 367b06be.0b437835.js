(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{121:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return b})),n.d(t,"metadata",(function(){return l})),n.d(t,"rightToc",(function(){return o})),n.d(t,"default",(function(){return c}));var a=n(1),r=n(6),i=(n(0),n(182)),b={id:"doodle",title:"DPoodle Graphics"},l={id:"fp/doodle",title:"DPoodle Graphics",description:"```reason hidden",source:"@site/docs/fp/doodle.md",permalink:"/focsipedia/docs/fp/doodle",editUrl:"https://github.com/bhoward/focsipedia/edit/master/docs/fp/doodle.md",sidebar:"someSidebar",previous:{title:"Types in Functional Programming",permalink:"/focsipedia/docs/fp/types"},next:{title:"ReasonML",permalink:"/focsipedia/docs/reason"}},o=[{value:"Section 1. Introduction",id:"section-1-introduction",children:[]},{value:"Section 2. <code>image</code> type",id:"section-2-image-type",children:[]},{value:"Section 3. Position and Manipulation",id:"section-3-position-and-manipulation",children:[]},{value:"Section 4. Format",id:"section-4-format",children:[]}],s={rightToc:o};function c(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},s,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason",metastring:"hidden",hidden:!0}),'type point = (float, float);\ntype angle = float;\ntype pathElement =\n| MoveTo(point)\n| LineTo(point)\n| CurveTo(point, point, point);\ntype color =\n| Color(string)\n| RGBA(int, int, int, float)\n| HSLA(angle, float, float, float);\ntype fontFamily =\n| Mono\n| Sans\n| Serif;\ntype fontWeight =\n| Bold\n| Regular;\ntype fontStyle =\n| Italic\n| Normal;\ntype style =\n| LineWidth(float)\n| LineColor(color) /* TODO patterns? */\n| FillColor(color)\n| Dashed\n| Font(float, fontFamily, fontWeight, fontStyle);\ntype image =\n| Empty\n| Ellipse(float, float)\n| Rectangle(float, float)\n| Text(string)\n| OpenPath(list(pathElement))\n| ClosedPath(list(pathElement))\n| Beside(image, image)\n| Above(image, image)\n| On(image, image)\n| Styled(image, list(style))\n| Translate(image, float, float)\n| Rotate(image, angle)\n| Scale(image, float, float)\n| Bounds(image, float, float, float, float);\ntype position = TL | TC | TR | ML | MC | MR | BL | BC | BR;\nlet string_of_color = c => {\n  switch (c) {\n  | Color(s) => s\n  | RGBA(r, g, b, a) =>\n    Printf.sprintf("rgba(%d,%d,%d,%f)",\n      r, g, b, a)\n  | HSLA(h, s, l, a) =>\n    Printf.sprintf("hsla(%f,%d%%,%d%%,%f)",\n      h, int_of_float(s *. 100.), int_of_float(l *. 100.), a)\n  }\n};\nlet string_of_fontFamily = f => {\n  switch (f) {\n  | Mono => "Roboto Mono, monospace"\n  | Sans => "Roboto, sans-serif"\n  | Serif => "Lora, serif"\n  }\n}\nlet string_of_fontWeight = w => {\n  switch (w) {\n  | Bold => "bold"\n  | Regular => "normal"\n  }\n}\nlet string_of_fontStyle = s => {\n  switch (s) {\n  | Italic => "italic"\n  | Normal => "normal"\n  }\n}\nlet string_of_style = s => {\n  switch (s) {\n  | LineWidth(w) =>\n    Printf.sprintf("stroke-width=\'%f\'", w)\n  | LineColor(c) =>\n    Printf.sprintf("stroke=\'%s\'", string_of_color(c))\n  | FillColor(c) => \n    Printf.sprintf("fill=\'%s\'", string_of_color(c))\n  | Dashed =>\n    "stroke-dasharray=\'4\'"\n  | Font(size, family, weight, style) =>\n    Printf.sprintf("font-size=\'%frem\' font-family=\'%s\' font-weight=\'%s\' font-style=\'%s\'",\n      size, string_of_fontFamily(family), string_of_fontWeight(weight), string_of_fontStyle(style))\n  }\n}\nlet radians = a => {\n  a *. 3.14159265358979 /. 180.0\n};\nlet getPoint = elt => {\n  switch (elt) {\n  | MoveTo(p) => p\n  | LineTo(p) => p\n  | CurveTo(_, _, p) => p\n  }\n};\nlet rec bbox_of_points = ps => {\n  switch (ps) {\n  | [] => (0., 0., 0., 0.)\n  | [(x, y)] => (x, x, y, y)\n  | [(x, y), ...rest] => {\n      let (l, r, t, b) = bbox_of_points(rest);\n      (min(x, l), max(x, r), min(y, t), max(y, b))\n    }\n  }\n};\nlet rec bbox = img => {\n  switch (img) {\n  | Empty => (0., 0., 0., 0.)\n  | Ellipse(w, h) => (-.w /. 2., w /. 2., -.h /. 2., h /. 2.)\n  | Rectangle(w, h) => (-.w /. 2., w /. 2., -.h /. 2., h /. 2.)\n  | Text(_) => (0., 0., 0., 0.)\n  | OpenPath(elts) => {\n    bbox_of_points(List.map(getPoint, elts))\n  }\n  | ClosedPath(elts) => {\n    bbox_of_points(List.map(getPoint, elts))\n  }\n  | Beside(l, r) => {\n    let (ll, lr, lt, lb) = bbox(l);\n    let (rl, rr, rt, rb) = bbox(r);\n    let w = (lr -. ll) +. (rr -. rl);\n    (-.w /. 2., w /. 2., min(lt, rt), max(lb, rb))\n  }\n  | Above(t, b) => {\n    let (tl, tr, tt, tb) = bbox(t);\n    let (bl, br, bt, bb) = bbox(b);\n    let h = (tb -. tt) +. (bb -. bt);\n    (min(tl, bl), max(tr, br), -.h /. 2., h /. 2.)\n  }\n  | On(a, b) => {\n    let (al, ar, at, ab) = bbox(a);\n    let (bl, br, bt, bb) = bbox(b);\n    (min(al, bl), max(ar, br), min(at, bt), max(ab, bb))\n  }\n  | Styled(img, _) => bbox(img)\n  | Translate(img, x, y) => {\n    let (l, r, t, b) = bbox(img);\n    (l +. x, r +. x, t +. y, b +. y)\n  }\n  | Rotate(img, a) => {\n    let (l, r, t, b) = bbox(img);\n    let ps = [(l, t), (l, b), (r, t), (r, b)];\n    let arad = radians(a);\n    let cosa = cos(arad);\n    let sina = sin(arad);\n    let rot = ((x, y)) => { (x *. cosa -. y *. sina, x *. sina +. y *. cosa) }\n    bbox_of_points(List.map(rot, ps))\n  }\n  | Scale(img, sx, sy) => {\n    let (l, r, t, b) = bbox(img);\n    (l *. sx, r *. sx, t *. sy, b *. sy)\n  }\n  | Bounds(_, l, r, t, b) => (l, r, t, b)\n  }\n};\nlet left = img => {\n    let (l, _, _, _) = bbox(img);\n    l\n};\nlet right = img => {\n    let (_, r, _, _) = bbox(img);\n    r\n};\nlet top = img => {\n    let (_, _, t, _) = bbox(img);\n    t\n};\nlet bottom = img => {\n    let (_, _, _, b) = bbox(img);\n    b\n};\nlet width = img => {\n    let (l, r, _, _) = bbox(img);\n    r -. l\n};\nlet height = img => {\n    let (_, _, t, b) = bbox(img);\n    b -. t\n};\nlet topLeft = img => {\n    let (l, _, t, _) = bbox(img);\n    (l, t)\n};\nlet topRight = img => {\n    let (_, r, t, _) = bbox(img);\n    (r, t)\n};\nlet bottomLeft = img => {\n    let (l, _, _, b) = bbox(img);\n    (l, b)\n};\nlet bottomRight = img => {\n    let (_, r, _, b) = bbox(img);\n    (r, b)\n};\nlet rec string_of_path = path => {\n  switch (path) {\n  | [] => ""\n  | [MoveTo((x, y)), ...rest] =>\n      Printf.sprintf("M %f %f ", x, y) ++ string_of_path(rest)\n  | [LineTo((x, y)), ...rest] =>\n      Printf.sprintf("L %f %f ", x, y) ++ string_of_path(rest)\n  | [CurveTo((x1, y1), (x2, y2), (x3, y3)), ...rest] =>\n      Printf.sprintf("C %f %f, %f %f, %f %f ", x1, y1, x2, y2, x3, y3) ++ string_of_path(rest)\n  }\n};\nlet rec render = img => {\n  switch (img) {\n  | Empty => ""\n  | Ellipse(w, h) =>\n    Printf.sprintf("<ellipse rx=\'%f\' ry=\'%f\' cx=\'0\' cy=\'0\' />",\n      w /. 2., h /. 2.)\n  | Rectangle(w, h) =>\n    Printf.sprintf("<rect width=\'%f\' height=\'%f\' x=\'%f\' y=\'%f\' />",\n      w, h, -.w /. 2., -.h /. 2.)\n  | Text(s) =>\n    Printf.sprintf("<text x=\'0\' y=\'0\' text-anchor=\'middle\' dominant-baseline=\'middle\'>%s</text>", s)\n  | OpenPath(path) =>\n    Printf.sprintf("<path d=\'%s\' fill=\'none\' stroke-linejoin=\'round\' stroke-linecap=\'round\' />", string_of_path(path))\n  | ClosedPath(path) => \n    Printf.sprintf("<path d=\'%sZ\' stroke-linejoin=\'round\' stroke-linecap=\'round\' />", string_of_path(path))\n  | Beside(l, r) => {\n      let (ll, lr, _, _) = bbox(l);\n      let (rl, rr, _, _) = bbox(r);\n      let w = (lr -. ll) +. (rr -. rl);\n      Printf.sprintf("<g transform=\'translate(%f,0)\'>%s</g>",\n        -.w /. 2. -. ll, render(l))\n      ++\n      Printf.sprintf("<g transform=\'translate(%f,0)\'>%s</g>",\n        w /. 2. -. rr, render(r))\n    } \n  | Above(t, b) => {\n      let (_, _, tt, tb) = bbox(t);\n      let (_, _, bt, bb) = bbox(b);\n      let h = (tb -. tt) +. (bb -. bt);\n      Printf.sprintf("<g transform=\'translate(0,%f)\'>%s</g>",\n        -.h /. 2. -. tt, render(t))\n      ++\n      Printf.sprintf("<g transform=\'translate(0,%f)\'>%s</g>",\n        h /. 2. -. bb, render(b))\n    }\n  | On(a, b) => render(b) ++ render(a)\n  | Styled(img, stys) => {\n      let ss = List.map(s => { " " ++ string_of_style(s) }, stys);\n      Printf.sprintf("<g %s>%s</g>", List.fold_left((++), "", ss), render(img))\n    }\n  | Translate(img, x, y) =>\n    Printf.sprintf("<g transform=\'translate(%f,%f)\'>%s</g>",\n      x, y, render(img))\n  | Rotate(img, a) =>\n    Printf.sprintf("<g transform=\'rotate(%f)\'>%s</g>",\n      a, render(img))\n  | Scale(img, sx, sy) =>\n    Printf.sprintf("<g transform=\'scale(%f,%f)\'>%s</g>",\n      sx, sy, render(img))\n  | Bounds(img, _, _, _, _) => render(img)\n  }\n};\nlet draw = image => {\n  let (l, r, t, b) = bbox(image);\n  let w = r -. l;\n  let h = b -. t;\n  let padw = w *. 0.05;\n  let padh = h *. 0.05;\n  let newl = min(l -. padw, -100.);\n  let newr = max(r +. padw, 100.);\n  let newt = t -. padh;\n  let newb = b +. padh;\n  Printf.printf("<svg viewBox=\'%f %f %f %f\' width=\'100%%\' preserveAspectRatio>",\n    newl, newt, newr -. newl, newb -. newt);\n  print_string("<g fill=\'grey\' stroke=\'black\' font-family=\'Roboto Mono, monospace\' font-size=\'1rem\'>");\n  print_string(render(image));\n  print_string("</g></svg>\\n");\n};\nlet empty = Empty;\nlet circle = r => { Ellipse(2. *. r, 2. *. r) };\nlet ellipse = (w, h) => { Ellipse(w, h) };\nlet rectangle = (w, h) => { Rectangle(w, h) };\nlet square = w => { Rectangle(w, w) };\nlet triangle = (w, h) => { ClosedPath([\n    MoveTo((-. w /. 2., h /. 2.)),\n    LineTo((0., -. h /. 2.)),\n    LineTo((w /. 2., h /. 2.))\n  ]) };\nlet text = s => { Text(s) };\nlet openPath = elements => { OpenPath(elements) };\nlet closedPath = elements => { ClosedPath(elements) };\nlet polar = (r, theta) => {\n  let a = radians(theta);\n  (r *. cos(a), r *. sin(a))\n};\nlet regularPolygon = (sides, size, initialAngle) => {\n  let rotation = 360. /. float_of_int(sides);\n  let getPoint = n => polar(size, rotation *. float_of_int(n) +. initialAngle);\n  let rec path = n => {\n    if (n == 0) []\n    else [LineTo(getPoint(n)), ...path(n - 1)]\n  };\n  ClosedPath([MoveTo(getPoint(sides)), ...path(sides - 1)])\n};\nlet polygon = points => {\n  let rec path = points => {\n    switch (points) {\n    | [] => []\n    | [p, ...rest] => [LineTo(p), ...path(rest)]\n    }\n  };\n  switch (points) {\n  | [] => Empty\n  | [p, ...rest] => ClosedPath([MoveTo(p), ...path(rest)])\n  }\n};\nlet polyline = points => {\n  let rec path = points => {\n    switch (points) {\n    | [] => []\n    | [p, ...rest] => [LineTo(p), ...path(rest)]\n    }\n  };\n  switch (points) {\n  | [] => Empty\n  | [p, ...rest] => OpenPath([MoveTo(p), ...path(rest)])\n  }\n};\nlet above = (a, b) => { Above(a, b) };\nlet below = (a, b) => { Above(b, a) };\nlet beside = (a, b) => { Beside(a, b) };\nlet on = (a, b) => { On(a, b) };\nlet under = (a, b) => { On(b, a) };\nlet (---) = (a, b) => { Above(a, b) };\nlet (|||) = (a, b) => { Beside(a, b) };\nlet (+++) = (a, b) => { On(a, b) };\nlet fill = (c, img) => { Styled(img, [FillColor(c)]) };\nlet stroke = (c, img) => { Styled(img, [LineColor(c)]) };\nlet solid = (c, img) => { Styled(img, [FillColor(c), LineColor(c)]) };\nlet strokeWidth = (w, img) => { Styled(img, [LineWidth(w)]) };\nlet withFont = (size, family, weight, style, img) => { Styled(img, [Font(size, family, weight, style)]) };\nlet focus = (pos, img) => {\n  let (l, r, t, b) = bbox(img);\n  switch (pos) {\n  | TL => Translate(img, -.l, -.t)\n  | TC => Translate(img, -.(l +. r) /. 2., -.t)\n  | TR => Translate(img, -.r, -.t)\n  | ML => Translate(img, -.l, -.(t +. b) /. 2.)\n  | MC => Translate(img, -.(l +. r) /. 2., -.(t +. b) /. 2.)\n  | MR => Translate(img, -.r, -.(t +. b) /. 2.)\n  | BL => Translate(img, -.l, -.b)\n  | BC => Translate(img, -.(l +. r) /. 2., -.b)\n  | BR => Translate(img, -.r, -.b)\n  }\n};\nlet rotate = (a, img) => { Rotate(img, a) };\nlet translate = (dx, dy, img) => { Translate(img, dx, dy) };\nlet scalexy = (sx, sy, img) => { Scale(img, sx, sy) };\nlet scale = (s, img) => { Scale(img, s, s) };\nlet setBounds = (l, r, t, b, img) => { Bounds(img, l, r, t, b) };\nlet showBounds = img => {\n  let (l, r, t, b) = bbox(img);\n  let w = r -. l;\n  let h = b -. t;\n  On(\n    Bounds(Styled(\n      circle(max(w, h) /. 20.) +++\n        OpenPath([MoveTo((-.w /. 10., 0.)), LineTo((w /. 10., 0.))]) +++\n        OpenPath([MoveTo((0., -.h /. 10.)), LineTo((0., h /. 10.))]) +++\n        Translate(rectangle(w, h), l +. w /. 2., t +. h /. 2.),\n      [Dashed, FillColor(Color("none")), LineColor(Color("black")), LineWidth(1.0)]), 0., 0., 0., 0.),\n    img\n  )\n}\nlet rgb = (r, g, b) => { RGBA(r, g, b, 1.0) };\nlet rgba = (r, b, g, a) => { RGBA(r, g, b, a) };\nlet hsl = (h, s, l) => { HSLA(h, s, l, 1.0) };\nlet hsla = (h, s, l, a) => {HSLA(h, s, l, a) };\nlet moveXY = (x, y) => { MoveTo((x, y)) };\nlet lineXY = (x, y) => { LineTo((x, y)) };\nlet curveXY = (c1x, c1y, c2x, c2y, px, py) => { CurveTo((c1x, c1y), (c2x, c2y), (px, py)) };\nlet curveP = (c1, c2, p) => { CurveTo(c1, c2, p) };\nlet moveP = p => { MoveTo(p) };\nlet lineP = p => { LineTo(p) };\nlet rec logoBackground = n => {\n  if (n == 0) {\n    Empty\n  } else {\n    let r = 10.0 *. sqrt(float_of_int(4 * n));\n    logoBackground(n - 1) +++\n      solid(hsl(float_of_int(12 * n), 1.0, 0.5), ellipse(2. *. r, r))\n  }\n};\nlet logo = withFont(2., Mono, Bold, Normal, stroke(Color("none"), fill(Color("black"), text("DPoodle")))) +++ logoBackground(50);\ndraw(logo)\n')),Object(i.b)("h2",{id:"section-1-introduction"},"Section 1. Introduction"),Object(i.b)("p",null,"DPoodle is a graphics library written in ReasonML at DePauw University during Spring 2020.\nDPoodle is based on the Doodle graphics library from ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://creativescala.com/"}),"Creative Scala"),"."),Object(i.b)("h2",{id:"section-2-image-type"},"Section 2. ",Object(i.b)("inlineCode",{parentName:"h2"},"image")," type"),Object(i.b)("p",null,"The basic type of a drawing in DPoodle is ",Object(i.b)("inlineCode",{parentName:"p"},"image"),".\nSeven built-in functions used to construct geometric shapes are ellipse, circle, rectangle, square, triangle, polygon, and regularPolygon.\nThe size arguments for all of these functions are of type ",Object(i.b)("inlineCode",{parentName:"p"},"float"),", plus the ",Object(i.b)("inlineCode",{parentName:"p"},"regularPolygon")," function also takes the number of sides as an ",Object(i.b)("inlineCode",{parentName:"p"},"int"),".\nEvery image in DPoodle has a ",Object(i.b)("em",{parentName:"p"},"bounding box"),", which is a minimal rectangle that can cover the image.\nThe center of the bounding box by default is at (0, 0).\nThe built-in triangle function creates an isoceles triangle with the base on the bottom edge of the bounding box and the vertex in the middle of the top edge. Detail about the built-in functions to create geometric shape images in DPoodle are in the following table:"),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(a.a)({parentName:"tr"},{align:"center"}),"Function"),Object(i.b)("th",Object(a.a)({parentName:"tr"},{align:"center"}),"Argument(s)"),Object(i.b)("th",Object(a.a)({parentName:"tr"},{align:"center"}),"Bounding box size"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),Object(i.b)("inlineCode",{parentName:"td"},"ellipse(w, h)")),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"Horizontal axis (w) and Vertical axis (h)"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),Object(i.b)("span",Object(a.a)({parentName:"td"},{className:"math math-inline"}),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"katex"}),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"katex-mathml"}),Object(i.b)("math",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(i.b)("semantics",{parentName:"math"},Object(i.b)("mrow",{parentName:"semantics"},Object(i.b)("mi",{parentName:"mrow"},"w"),Object(i.b)("mo",{parentName:"mrow"},"\xd7"),Object(i.b)("mi",{parentName:"mrow"},"h")),Object(i.b)("annotation",Object(a.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"w\\times h")))),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"base"}),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"strut",style:{height:"0.66666em",verticalAlign:"-0.08333em"}})),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"mord mathdefault",style:{marginRight:"0.02691em"}}),"w"),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2222222222222222em"}})),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"mbin"}),"\xd7"),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2222222222222222em"}}))),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"base"}),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"strut",style:{height:"0.69444em",verticalAlign:"0em"}})),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"mord mathdefault"}),"h"))))))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),Object(i.b)("inlineCode",{parentName:"td"},"circle(r)")),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"Radius (r)"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),Object(i.b)("span",Object(a.a)({parentName:"td"},{className:"math math-inline"}),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"katex"}),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"katex-mathml"}),Object(i.b)("math",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(i.b)("semantics",{parentName:"math"},Object(i.b)("mrow",{parentName:"semantics"},Object(i.b)("mn",{parentName:"mrow"},"2"),Object(i.b)("mi",{parentName:"mrow"},"r"),Object(i.b)("mo",{parentName:"mrow"},"\xd7"),Object(i.b)("mn",{parentName:"mrow"},"2"),Object(i.b)("mi",{parentName:"mrow"},"r")),Object(i.b)("annotation",Object(a.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"2r\\times 2r")))),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"base"}),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"strut",style:{height:"0.72777em",verticalAlign:"-0.08333em"}})),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"mord"}),"2"),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"mord mathdefault",style:{marginRight:"0.02778em"}}),"r"),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2222222222222222em"}})),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"mbin"}),"\xd7"),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2222222222222222em"}}))),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"base"}),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"strut",style:{height:"0.64444em",verticalAlign:"0em"}})),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"mord"}),"2"),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"mord mathdefault",style:{marginRight:"0.02778em"}}),"r"))))))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),Object(i.b)("inlineCode",{parentName:"td"},"rectangle(w, h)")),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"Width (w) and Height (h)"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),Object(i.b)("span",Object(a.a)({parentName:"td"},{className:"math math-inline"}),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"katex"}),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"katex-mathml"}),Object(i.b)("math",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(i.b)("semantics",{parentName:"math"},Object(i.b)("mrow",{parentName:"semantics"},Object(i.b)("mi",{parentName:"mrow"},"w"),Object(i.b)("mo",{parentName:"mrow"},"\xd7"),Object(i.b)("mi",{parentName:"mrow"},"h")),Object(i.b)("annotation",Object(a.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"w\\times h")))),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"base"}),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"strut",style:{height:"0.66666em",verticalAlign:"-0.08333em"}})),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"mord mathdefault",style:{marginRight:"0.02691em"}}),"w"),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2222222222222222em"}})),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"mbin"}),"\xd7"),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2222222222222222em"}}))),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"base"}),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"strut",style:{height:"0.69444em",verticalAlign:"0em"}})),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"mord mathdefault"}),"h"))))))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),Object(i.b)("inlineCode",{parentName:"td"},"square(w)")),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"Side length (w)"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),Object(i.b)("span",Object(a.a)({parentName:"td"},{className:"math math-inline"}),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"katex"}),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"katex-mathml"}),Object(i.b)("math",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(i.b)("semantics",{parentName:"math"},Object(i.b)("mrow",{parentName:"semantics"},Object(i.b)("mi",{parentName:"mrow"},"w"),Object(i.b)("mo",{parentName:"mrow"},"\xd7"),Object(i.b)("mi",{parentName:"mrow"},"w")),Object(i.b)("annotation",Object(a.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"w\\times w")))),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"base"}),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"strut",style:{height:"0.66666em",verticalAlign:"-0.08333em"}})),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"mord mathdefault",style:{marginRight:"0.02691em"}}),"w"),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2222222222222222em"}})),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"mbin"}),"\xd7"),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2222222222222222em"}}))),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"base"}),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}})),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"mord mathdefault",style:{marginRight:"0.02691em"}}),"w"))))))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),Object(i.b)("inlineCode",{parentName:"td"},"triangle(w, h)")),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"Base (w) and Height (h)"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),Object(i.b)("span",Object(a.a)({parentName:"td"},{className:"math math-inline"}),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"katex"}),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"katex-mathml"}),Object(i.b)("math",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(i.b)("semantics",{parentName:"math"},Object(i.b)("mrow",{parentName:"semantics"},Object(i.b)("mi",{parentName:"mrow"},"w"),Object(i.b)("mo",{parentName:"mrow"},"\xd7"),Object(i.b)("mi",{parentName:"mrow"},"h")),Object(i.b)("annotation",Object(a.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"w\\times h")))),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"base"}),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"strut",style:{height:"0.66666em",verticalAlign:"-0.08333em"}})),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"mord mathdefault",style:{marginRight:"0.02691em"}}),"w"),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2222222222222222em"}})),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"mbin"}),"\xd7"),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2222222222222222em"}}))),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"base"}),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"strut",style:{height:"0.69444em",verticalAlign:"0em"}})),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"mord mathdefault"}),"h"))))))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),Object(i.b)("inlineCode",{parentName:"td"},"polygon(points)")),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"List of vertex points"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"Smallest rectangle containing all points")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),Object(i.b)("inlineCode",{parentName:"td"},"regularPolygon(n, s, a)")),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"Number of sides (n), Distance from center to vertex (s), and Initial angle (a)"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),Object(i.b)("span",Object(a.a)({parentName:"td"},{className:"math math-inline"}),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"katex"}),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"katex-mathml"}),Object(i.b)("math",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(i.b)("semantics",{parentName:"math"},Object(i.b)("mrow",{parentName:"semantics"},Object(i.b)("mn",{parentName:"mrow"},"2"),Object(i.b)("mi",{parentName:"mrow"},"s"),Object(i.b)("mo",{parentName:"mrow"},"\xd7"),Object(i.b)("mn",{parentName:"mrow"},"2"),Object(i.b)("mi",{parentName:"mrow"},"s")),Object(i.b)("annotation",Object(a.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"2s\\times 2s")))),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"base"}),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"strut",style:{height:"0.72777em",verticalAlign:"-0.08333em"}})),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"mord"}),"2"),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"mord mathdefault"}),"s"),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2222222222222222em"}})),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"mbin"}),"\xd7"),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2222222222222222em"}}))),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"base"}),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"strut",style:{height:"0.64444em",verticalAlign:"0em"}})),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"mord"}),"2"),Object(i.b)("span",Object(a.a)({parentName:"span"},{className:"mord mathdefault"}),"s")))))," (roughly)")))),Object(i.b)("p",null,"Function ",Object(i.b)("inlineCode",{parentName:"p"},"draw(image)")," is used to visualize the ",Object(i.b)("inlineCode",{parentName:"p"},"image"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"draw(ellipse(20.0, 15.0))\ndraw(square(15.0))\ndraw(triangle(15.0, 20.0))\ndraw(polygon([(-10.0, 10.0), (0.0, -10.0), (10.0, -10.0), (15.0, 0.0)]))\ndraw(regularPolygon(6, 15., 90.))\n")),Object(i.b)("p",null,"In the library there is also a function call ",Object(i.b)("inlineCode",{parentName:"p"},"polyline")," which is closely related to to ",Object(i.b)("inlineCode",{parentName:"p"},"polygon"),". A polyline is a non-closed polygon: "),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"draw(polyline([(-10.0, 10.0), (0.0, -10.0), (10.0, -10.0), (15.0, 0.0)]))\n")),Object(i.b)("p",null,"Information about bounding box ",Object(i.b)("inlineCode",{parentName:"p"},"bbox")," of an ",Object(i.b)("inlineCode",{parentName:"p"},"image")," can be retrieved by following functions, which take an ",Object(i.b)("inlineCode",{parentName:"p"},"image")," as input. The first 4 functions return a ",Object(i.b)("inlineCode",{parentName:"p"},"float")," and the rest return a ",Object(i.b)("inlineCode",{parentName:"p"},"point"),", which is equivalent to a pair of floats."),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(a.a)({parentName:"tr"},{align:"center"}),"Function"),Object(i.b)("th",Object(a.a)({parentName:"tr"},{align:"center"}),"Return"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),Object(i.b)("inlineCode",{parentName:"td"},"left(image)")),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"Minimum x-coordinate of corresponding ",Object(i.b)("inlineCode",{parentName:"td"},"bbox"))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),Object(i.b)("inlineCode",{parentName:"td"},"right(image)")),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"Maximum x-coordinate of corresponding ",Object(i.b)("inlineCode",{parentName:"td"},"bbox"))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),Object(i.b)("inlineCode",{parentName:"td"},"top(image)")),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"Minium y-coordinate of corresponding ",Object(i.b)("inlineCode",{parentName:"td"},"bbox"))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),Object(i.b)("inlineCode",{parentName:"td"},"bottom(image)")),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"Maximum y-coordinate of corresponding ",Object(i.b)("inlineCode",{parentName:"td"},"bbox"))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),Object(i.b)("inlineCode",{parentName:"td"},"topLeft(image)")),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"Top left coordinate of corresponding ",Object(i.b)("inlineCode",{parentName:"td"},"bbox"))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),Object(i.b)("inlineCode",{parentName:"td"},"topRight(image)")),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"Top right coordinate of corresponding ",Object(i.b)("inlineCode",{parentName:"td"},"bbox"))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),Object(i.b)("inlineCode",{parentName:"td"},"bottomLeft(image)")),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"Bottom left coordinate of corresponding ",Object(i.b)("inlineCode",{parentName:"td"},"bbox"))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),Object(i.b)("inlineCode",{parentName:"td"},"bottomRight(image)")),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"Bottom right coordinate of corresponding ",Object(i.b)("inlineCode",{parentName:"td"},"bbox"))))),Object(i.b)("p",null,"Here are some examples: "),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"let a = rectangle(15., 20.)\nleft(a)\nright(a)\ntop(a)\nbottom(a)\ntopLeft(a)\ntopRight(a)\nbottomLeft(a)\nbottomRight(a)\n")),Object(i.b)("p",null,"We can also visuallize the bouding box and its center using ",Object(i.b)("inlineCode",{parentName:"p"},"showBounds")," function, which takes image as input: "),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"let a = circle(30.)\ndraw(showBounds(a))\n")),Object(i.b)("p",null,"We can also construct a shape by specifying a colection of points and the connection between these points (using straight line or curve).\nThese shapes can be:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Open-path: using ",Object(i.b)("inlineCode",{parentName:"li"},"openPath(pathElements)")," function."),Object(i.b)("li",{parentName:"ul"},"Close-path: using ",Object(i.b)("inlineCode",{parentName:"li"},"closedPath(pathElements)")," function. ")),Object(i.b)("p",null,"These two functions take a list of ",Object(i.b)("inlineCode",{parentName:"p"},"pathElement")," values as input. The ",Object(i.b)("inlineCode",{parentName:"p"},"pathElement")," type can be"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"MoveTo(point)")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"LineTo(point)")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"CurveTo(point, point, point)"),"\nwhere point is a pair of floats.")),Object(i.b)("p",null,"In the following example, we draw an AND gate using ",Object(i.b)("inlineCode",{parentName:"p"},"closedPath")," function, on top of input and output wires drawn with ",Object(i.b)("inlineCode",{parentName:"p"},"openPath"),": "),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"let andGate = ClosedPath([\n  MoveTo((-5., -10.)),\n  LineTo((0., -10.)),\n  CurveTo((5., -10.), (10., -5.), (10., 0.)),\n  CurveTo((10., 5.), (5., 10.), (0., 10.)),\n  LineTo((-5., 10.))\n]) +++ OpenPath([\n  MoveTo((-5., -5.)), LineTo((-15., -5.)),\n  MoveTo((-5., 5.)), LineTo((-15., 5.)),\n  MoveTo((10., 0.)), LineTo((20., 0.))\n]);\ndraw(andGate);\n")),Object(i.b)("p",null,"Here are corresponding definitions of OR and NOT gates. Note how the NOT gate is built from other primitive geometric shapes:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"let orGate = ClosedPath([\n  MoveTo((-5., -10.)),\n  LineTo((0., -10.)),\n  CurveTo((5., -10.), (8., -5.), (10., 0.)),\n  CurveTo((8., 5.), (5., 10.), (0., 10.)),\n  LineTo((-5., 10.)),\n  CurveTo((0., 5.), (0., -5.), (-5., -10.))\n]) +++ OpenPath([\n  MoveTo((0., -5.)), LineTo((-15., -5.)),\n  MoveTo((0., 5.)), LineTo((-15., 5.)),\n  MoveTo((10., 0.)), LineTo((20., 0.))\n]);\ndraw(orGate);\n\nlet notGate = translate(4., 0., (rotate(90., triangle(20., 14.)) ||| circle(2.)))\n  +++ OpenPath([\n  MoveTo((-5., 0.)), LineTo((-15., 0.)),\n  MoveTo((13., 0.)), LineTo((20., 0.))\n]);\ndraw(notGate);\n")),Object(i.b)("h2",{id:"section-3-position-and-manipulation"},"Section 3. Position and Manipulation"),Object(i.b)("p",null,"We can control the relative position of 2 images using the following functions: "),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(a.a)({parentName:"tr"},{align:"center"}),"Function"),Object(i.b)("th",Object(a.a)({parentName:"tr"},{align:"center"}),"Return"),Object(i.b)("th",Object(a.a)({parentName:"tr"},{align:"center"}),"Alternative operation"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"beside(a, b)"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"Image a is on the left of image b. The centers of a and b are aligned"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),Object(i.b)("code",null,"a ","|","|","|"," b"))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"above (a, b)"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"Image a is vertically above image b. The centers of a and b are aligned"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),Object(i.b)("inlineCode",{parentName:"td"},"a --- b"))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"on(a, b)"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"Image a on top of image b. The centers of a and b are superimposed"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),Object(i.b)("inlineCode",{parentName:"td"},"a +++ b"))))),Object(i.b)("p",null,"The operator symbols should remind you of how a and b are arranged; imagine either drawing a line between them (",Object(i.b)("inlineCode",{parentName:"p"},"|")," or ",Object(i.b)("inlineCode",{parentName:"p"},"-"),") or centering one on the other (",Object(i.b)("inlineCode",{parentName:"p"},"+"),")."),Object(i.b)("p",null,"We can also scale, rotate, and translate the image: "),Object(i.b)("h2",{id:"section-4-format"},"Section 4. Format"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"image")," type is formatted using the ",Object(i.b)("inlineCode",{parentName:"p"},"Styled")," function. "),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"")),Object(i.b)("p",null,"Here is an ugly example:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),'let blueFill = img => { Styled(img, [FillColor(Color("blue"))]) };\nlet wideLines = img => { Styled(img, [LineWidth(3.0)]) };\nlet redOutline = img => { Styled(img, [LineColor(Color("red"))]) };\nlet a = blueFill(Ellipse(60.0, 80.0));\nlet b = wideLines(Rectangle(50.0, 50.0));\nlet c = Ellipse(30.0, 30.0);\nlet d = Bounds(Text("Hello"), -24., 24., -7., 7.);\ndraw(On(Rotate(Scale(d, 5., 5.), 45.),\n        redOutline(Above(Beside(a, b), c))));\n')),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),'let blueFill = fill(Color("blue"));\nlet wideLines = strokeWidth(3.0);\nlet redOutline = stroke(Color("red"));\nlet a = blueFill(ellipse(60.0, 80.0));\nlet b = wideLines(square(50.0));\nlet c = circle(30.0);\nlet d = setBounds(-24., 24., -7., 7., text("Hello"));\ndraw(rotate(45., scale(5., d)) +++ redOutline((a ||| b) --- c));\n')),Object(i.b)("p",null,"Here is an arrow. The ",Object(i.b)("inlineCode",{parentName:"p"},"focus")," function moves the ",Object(i.b)("em",{parentName:"p"},"focus")," point of the image (the point used\nto line up images with ",Object(i.b)("inlineCode",{parentName:"p"},"On"),", ",Object(i.b)("inlineCode",{parentName:"p"},"Beside"),", and ",Object(i.b)("inlineCode",{parentName:"p"},"Above"),").\nThe first argument of focus is a two-letter value; the first letter is (T)op, (M)iddle, or (B)ottom, and the second is (L)eft, (C)enter, or (R)ight.\nThe value ",Object(i.b)("inlineCode",{parentName:"p"},"ML")," says to move the focus to the middle of the left edge of the bounding box, which in this\ncase is the tail end of the arrow.\nWe can use the ",Object(i.b)("inlineCode",{parentName:"p"},"showBounds")," function to visualize the bounding box and focus point."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),'let arrow = len => {\n  strokeWidth(2., focus(ML, OpenPath([\n    moveXY(0., 0.),\n    lineXY(len, 0.),\n    lineXY(len -. 5., 5.),\n    moveXY(len, 0.),\n    lineXY(len -. 5., -5.)])))\n};\n\ndraw(arrow(50.))\n\ndraw(showBounds(arrow(50.)))\n\ndraw(arrow(50.) +++ rotate(-90., arrow(30.)) +++ fill(Color("white"), circle(60.)))\n')),Object(i.b)("p",null,"Using the arrow, here is a function to visualize a linked list:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),'let listNode = n => {\n  let valueField = solid(Color("black"), text(string_of_int(n))) +++ square(20.);\n  let nextField = arrow(20.) +++ square(20.);\n  fill(Color("white"), valueField ||| nextField)\n};\n\nlet rec showList = nums => {\n  switch (nums) {\n  | [] => solid(Color("black"), circle(5.))\n  | [head, ...tail] => listNode(head) ||| showList(tail)\n  }\n};\n\ndraw(showList([1, 2, 3]));\ndraw(showList([1, 2, 3, 4, 5, 6, 7, 8, 9]));\n')))}c.isMDXComponent=!0},182:function(e,t,n){"use strict";n.d(t,"a",(function(){return m})),n.d(t,"b",(function(){return O}));var a=n(0),r=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function b(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?b(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):b(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=r.a.createContext({}),c=function(e){var t=r.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l({},t,{},e)),n},m=function(e){var t=c(e.components);return r.a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},d=Object(a.forwardRef)((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,b=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),m=c(n),d=a,O=m["".concat(b,".").concat(d)]||m[d]||p[d]||i;return n?r.a.createElement(O,l({ref:t},s,{components:n})):r.a.createElement(O,l({ref:t},s))}));function O(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,b=new Array(i);b[0]=d;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l.mdxType="string"==typeof e?e:a,b[1]=l;for(var s=2;s<i;s++)b[s]=n[s];return r.a.createElement.apply(null,b)}return r.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);