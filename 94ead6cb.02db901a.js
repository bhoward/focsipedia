(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{126:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return c})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return b}));var a=n(1),i=n(6),r=(n(0),n(157)),o=(n(158),{id:"types",title:"Types in Functional Programming"}),c={id:"fp/types",title:"Types in Functional Programming",description:"import useBaseUrl from '@docusaurus/useBaseUrl';",source:"@site/docs/fp/types.md",permalink:"/focsipedia/docs/fp/types",editUrl:"https://github.com/bhoward/focsipedia/edit/master/docs/fp/types.md",sidebar:"someSidebar",previous:{title:"Introduction to Functional Programming",permalink:"/focsipedia/docs/fp/intro"},next:{title:"ReasonML",permalink:"/focsipedia/docs/reason"}},s=[{value:"Functions",id:"functions",children:[]},{value:"Type Inference",id:"type-inference",children:[{value:"Currying",id:"currying",children:[]}]},{value:"Tuples",id:"tuples",children:[]},{value:"Records and Variants",id:"records-and-variants",children:[{value:"Pattern Matching",id:"pattern-matching",children:[]},{value:"Recursive Types",id:"recursive-types",children:[]}]},{value:"Connection to Natural Deduction",id:"connection-to-natural-deduction",children:[]}],l={rightToc:s},p="wrapper";function b(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(r.b)(p,Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"One of the hallmarks of modern functional programming is a strong and rich\nsystems of types. The type of an expression can be thought of as the set of all\nvalues that the expression might have; by specifying the type of a parameter to\na function, it constrains the values that may be provided as input. In this\nsense, the type of a function is then a form of contract: if the input satisfies\nsome condition (is a value in the parameter type), then the output is also\nguaranteed to satisfy a condition (be a value of the result type)."),Object(r.b)("h2",{id:"functions"},"Functions"),Object(r.b)("p",null,"In ReasonML we write the type of functions from ",Object(r.b)("inlineCode",{parentName:"p"},"A")," to ",Object(r.b)("inlineCode",{parentName:"p"},"B")," as ",Object(r.b)("inlineCode",{parentName:"p"},"A => B"),". Given a\nfunction ",Object(r.b)("inlineCode",{parentName:"p"},"f")," of that type, if ",Object(r.b)("inlineCode",{parentName:"p"},"x")," is a value (or more generally any expression)\nof type ",Object(r.b)("inlineCode",{parentName:"p"},"A"),", then the ",Object(r.b)("strong",{parentName:"p"},"application")," ",Object(r.b)("inlineCode",{parentName:"p"},"f(x)")," will give us a result of type ",Object(r.b)("inlineCode",{parentName:"p"},"B"),".\nThe value ",Object(r.b)("inlineCode",{parentName:"p"},"x")," to which we apply the function is known as the ",Object(r.b)("strong",{parentName:"p"},"argument"),".\nFor example, ",Object(r.b)("inlineCode",{parentName:"p"},"string_of_int")," is a function of type ",Object(r.b)("inlineCode",{parentName:"p"},"int => string"),"; when we\napply it to an integer, it returns the string of digits representing the argument:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"let result = string_of_int(42);\n")),Object(r.b)("p",null,"Since functions are first-class values, we may bind a function to another name:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"let f = string_of_int;\nlet result = f(42);\n")),Object(r.b)("div",{className:"admonition admonition-warning"},Object(r.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(r.b)("h5",{parentName:"div"},Object(r.b)("div",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(r.b)("svg",Object(a.a)({parentName:"div"},{xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"}),Object(r.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"})))),"warning")),Object(r.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(r.b)("p",{parentName:"div"},"Because the embedded ReasonML compiler here is first converting the code to\nOCaml, and then executing the OCaml code, it actually reports types using the\nOCaml syntax, which is slightly different! For example, OCaml uses a single\narrow ",Object(r.b)("inlineCode",{parentName:"p"},"->")," for function types instead of the double arrow ",Object(r.b)("inlineCode",{parentName:"p"},"=>"),". This is\nunfortunate, but as we will see below we rarely even need to write types."))),Object(r.b)("p",null,"To create a function value, we use the double arrow to show that we are taking\na parameter, for example ",Object(r.b)("inlineCode",{parentName:"p"},"p"),", and using it to compute a result:\n",Object(r.b)("inlineCode",{parentName:"p"},"p => { ...result expression... }"),". The parameter may be any variable name","\u2014",'it\nwill represent the value of the argument just within the block containing the\nresult expressions. That is, if the variable name had been used outside the function,\nit will be temporarily "shadowed" by the new binding; when the function has returned\nits result, the local binding to the argument goes away.'),Object(r.b)("p",null,"Consider the following example:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"let x = 5;\nlet f = x => { x + 12 };\nlet y = f(x * x) + x;\n")),Object(r.b)("p",null,"The first binding to ",Object(r.b)("inlineCode",{parentName:"p"},"x")," is the integer 5. When ",Object(r.b)("inlineCode",{parentName:"p"},"f")," is applied to its argument,\nwhich is ",Object(r.b)("inlineCode",{parentName:"p"},"x * x"),", or 25, we will temporarily bind 25 to a new, local variable\nnamed ",Object(r.b)("inlineCode",{parentName:"p"},"x")," and evaluate the body of the function: ",Object(r.b)("inlineCode",{parentName:"p"},"x + 12"),", which gives 37.\nContinuing to evaluate the expression ",Object(r.b)("inlineCode",{parentName:"p"},"f(x * x) + x"),", we now have ",Object(r.b)("inlineCode",{parentName:"p"},"37 + x"),"; since\n",Object(r.b)("inlineCode",{parentName:"p"},"x")," here refers to the original binding, this is ",Object(r.b)("inlineCode",{parentName:"p"},"37 + 5"),", so it binds 42 to ",Object(r.b)("inlineCode",{parentName:"p"},"y"),"."),Object(r.b)("h2",{id:"type-inference"},"Type Inference"),Object(r.b)("p",null,"ReasonML does not require that we specify the types of variables most of the\ntime, because it can usually infer what types they should have from the context\nand how they are used. Looking at the example above, since 5 is an int, we know\nthat ",Object(r.b)("inlineCode",{parentName:"p"},"x")," must have type ",Object(r.b)("inlineCode",{parentName:"p"},"int"),". In the second line, the local ",Object(r.b)("inlineCode",{parentName:"p"},"x")," must also be an\n",Object(r.b)("inlineCode",{parentName:"p"},"int"),", since we can add 12 to it.",Object(r.b)("sup",Object(a.a)({parentName:"p"},{id:"fnref-1"}),Object(r.b)("a",Object(a.a)({parentName:"sup"},{href:"#fn-1",className:"footnote-ref"}),"1"))," The result of the function body will be an ",Object(r.b)("inlineCode",{parentName:"p"},"int"),", so\nthe type of ",Object(r.b)("inlineCode",{parentName:"p"},"f")," is ",Object(r.b)("inlineCode",{parentName:"p"},"int => int"),". Finally, the application of ",Object(r.b)("inlineCode",{parentName:"p"},"f")," in the third line\nchecks out, because it is applied to an integer argument (",Object(r.b)("inlineCode",{parentName:"p"},"x * x"),"), and its result\nis used in a further integer addition. We could be explicit about the types and\nadd a ",Object(r.b)("strong",{parentName:"p"},"type annotation")," to each of the bindings:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"let x: int = 5;\nlet f: int => int = (x: int) => { x + 12 };\nlet y: int = f(x * x) + x;\nlet z: string = string_of_int(y);\n")),Object(r.b)("p",null,"However, the convention in ReasonML is that type annotations are not generally\nused except as documentation and as a check that the compiler is doing what we\nthink it is."),Object(r.b)("h3",{id:"currying"},"Currying"),Object(r.b)("p",null,"When we write a function that takes multiple arguments, we may list the parameters\nin parentheses, separated by commas:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"let average = (a, b) => { float_of_int(a + b) /. 2.0 };\nlet result = average(7, 10);\n")),Object(r.b)("p",null,"This is actually a lie! In ReasonML, functions can only have a single argument.\nBehind the scenes, the code above is translated to the following:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"let average = a => { b => { float_of_int(a + b) /. 2.0 } };\nlet result = average(7)(10);\n")),Object(r.b)("p",null,"That is, ",Object(r.b)("inlineCode",{parentName:"p"},"average")," is a function that takes an integer parameter ",Object(r.b)("inlineCode",{parentName:"p"},"a")," and returns\nanother function. This second function expects to be given another integer\nparameter, named ",Object(r.b)("inlineCode",{parentName:"p"},"b"),", and then it will compute the result (which is a ",Object(r.b)("inlineCode",{parentName:"p"},"float"),"\nfor variety). The computation on the second line corresponds to this: first\n",Object(r.b)("inlineCode",{parentName:"p"},"average")," is applied to the argument 7. The resulting function is then further\napplied to the argument 10, producing the desired floating-point result."),Object(r.b)("p",null,"Here is the same code, written out more explicitly:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"let average: int => (int => float) = (a: int) => {\n  (b: int) => {\n    float_of_int(a + b) /. 2.0\n  }\n};\nlet result1: int => float = average(7);\nlet result: float = result1(10);\n")),Object(r.b)("p",null,"This replacement of multiple-parameter functions with a sequence of single-parameter\nfunctions is called ",Object(r.b)("strong",{parentName:"p"},"currying"),", named after the logician Haskell B. Curry.",Object(r.b)("sup",Object(a.a)({parentName:"p"},{id:"fnref-2"}),Object(r.b)("a",Object(a.a)({parentName:"sup"},{href:"#fn-2",className:"footnote-ref"}),"2"))," One advantage of this,\nother than the simplicity of only needing one kind of function, is that it is often\nuseful to create a ",Object(r.b)("strong",{parentName:"p"},"partially applied")," function, where some of its arguments have\nbeen supplied to create a new function ready to be given the rest. For example, suppose\nwe have a function for formatting exam grades:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),'let format_grade = (exam, total, name, points) => {\n  name ++ ", " ++ exam ++ ": " ++ string_of_int(points) ++ "/" ++ string_of_int(total) \n};\nlet demo = format_grade("Midterm", 100, "Brian", 93);\n')),Object(r.b)("p",null,"We could take advantage of currying to create a specialized function for formatting the\nmidterm grades:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),'let format_midterm = format_grade("Midterm", 100);\nlet demo1 = format_midterm("Brian", 93);\nlet demo2 = format_midterm("Alice", 97);\n')),Object(r.b)("h2",{id:"tuples"},"Tuples"),Object(r.b)("h2",{id:"records-and-variants"},"Records and Variants"),Object(r.b)("h3",{id:"pattern-matching"},"Pattern Matching"),Object(r.b)("h3",{id:"recursive-types"},"Recursive Types"),Object(r.b)("h2",{id:"connection-to-natural-deduction"},"Connection to Natural Deduction"),Object(r.b)("p",null,"TODO: another page on common patterns of recursion: map, reduce, fold, accumulator,\nauxilliary function, tail-recursion. A page on functional graphics. A summary page\non ReasonML."),Object(r.b)("div",{className:"footnotes"},Object(r.b)("hr",{parentName:"div"}),Object(r.b)("ol",{parentName:"div"},Object(r.b)("li",Object(a.a)({parentName:"ol"},{id:"fn-1"}),"ReasonML, unlike many common languages,\ndistinguishes between the integer addition operator, written ",Object(r.b)("inlineCode",{parentName:"li"},"+"),", and the\nfloating-point addition operator, which is written ",Object(r.b)("inlineCode",{parentName:"li"},"+."),". In part this is done to\nmake type inference easier.",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#fnref-1",className:"footnote-backref"}),"\u21a9")),Object(r.b)("li",Object(a.a)({parentName:"ol"},{id:"fn-2"}),'As\nis often the case when things are named, Curry did not originate this idea. He got it\nfrom Moses Sch\xf6nfinkel, who may have picked it up from Gottlob Frege, but "currying"\nis easier to say than "sch\xf6nfinkeling" or "fregeing"',"\u2026",".",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#fnref-2",className:"footnote-backref"}),"\u21a9")))))}b.isMDXComponent=!0},156:function(e,t,n){"use strict";var a=n(0),i=n(32);t.a=function(){return Object(a.useContext)(i.a)}},157:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return f}));var a=n(0),i=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=i.a.createContext({}),p=function(e){var t=i.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):c({},t,{},e)),n},b=function(e){var t=p(e.components);return i.a.createElement(l.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},m=Object(a.forwardRef)((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,o=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),b=p(n),u=a,m=b["".concat(o,".").concat(u)]||b[u]||d[u]||r;return n?i.a.createElement(m,c({ref:t},l,{components:n})):i.a.createElement(m,c({ref:t},l))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=m;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c[u]="string"==typeof e?e:a,o[1]=c;for(var l=2;l<r;l++)o[l]=n[l];return i.a.createElement.apply(null,o)}return i.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},158:function(e,t,n){"use strict";n.d(t,"a",(function(){return i}));var a=n(156);function i(e){const{siteConfig:t}=Object(a.a)(),{baseUrl:n="/"}=t||{};if(!e)return e;return/^(https?:|\/\/)/.test(e)?e:e.startsWith("/")?n+e.slice(1):n+e}}}]);