(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{121:function(n,e,t){"use strict";t.r(e),t.d(e,"frontMatter",(function(){return o})),t.d(e,"metadata",(function(){return a})),t.d(e,"rightToc",(function(){return s})),t.d(e,"default",(function(){return c}));var l=t(1),r=t(6),i=(t(0),t(182)),o={id:"doodle",title:"DPoodle Graphics"},a={id:"fp/doodle",title:"DPoodle Graphics",description:"```reason hidden",source:"@site/docs/fp/doodle.md",permalink:"/focsipedia/docs/fp/doodle",editUrl:"https://github.com/bhoward/focsipedia/edit/master/docs/fp/doodle.md",sidebar:"someSidebar",previous:{title:"Types in Functional Programming",permalink:"/focsipedia/docs/fp/types"},next:{title:"ReasonML",permalink:"/focsipedia/docs/reason"}},s=[],b={rightToc:s};function c(n){var e=n.components,t=Object(r.a)(n,["components"]);return Object(i.b)("wrapper",Object(l.a)({},b,t,{components:e,mdxType:"MDXLayout"}),Object(i.b)("pre",null,Object(i.b)("code",Object(l.a)({parentName:"pre"},{className:"language-reason",metastring:"hidden",hidden:!0}),'type point = (float, float);\ntype angle = float;\ntype pathElement =\n| MoveTo(point)\n| LineTo(point)\n| CurveTo(point, point, point);\ntype color =\n| Color(string)\n| RGBA(int, int, int, float)\n| HSLA(angle, float, float, float);\ntype fontFamily =\n| Mono\n| Sans\n| Serif;\ntype fontWeight =\n| Bold\n| Regular;\ntype fontStyle =\n| Italic\n| Normal;\ntype style =\n| LineWidth(float)\n| LineColor(color) /* TODO patterns? */\n| FillColor(color)\n| Dashed\n| Font(float, fontFamily, fontWeight, fontStyle);\ntype image =\n| Empty\n| Ellipse(float, float)\n| Rectangle(float, float)\n| Text(string)\n| OpenPath(list(pathElement))\n| ClosedPath(list(pathElement))\n| Beside(image, image)\n| Above(image, image)\n| On(image, image)\n| Styled(image, list(style))\n| Translate(image, float, float)\n| Rotate(image, angle)\n| Scale(image, float, float)\n| Bounds(image, float, float, float, float);\ntype position = TL | TC | TR | ML | MC | MR | BL | BC | BR;\nlet string_of_color = c => {\n  switch (c) {\n  | Color(s) => s\n  | RGBA(r, g, b, a) =>\n    Printf.sprintf("rgba(%d,%d,%d,%f)",\n      r, g, b, a)\n  | HSLA(h, s, l, a) =>\n    Printf.sprintf("hsla(%f,%d%%,%d%%,%f)",\n      h, int_of_float(s *. 100.), int_of_float(l *. 100.), a)\n  }\n};\nlet string_of_fontFamily = f => {\n  switch (f) {\n  | Mono => "Roboto Mono, monospace"\n  | Sans => "Roboto, sans-serif"\n  | Serif => "Lora, serif"\n  }\n}\nlet string_of_fontWeight = w => {\n  switch (w) {\n  | Bold => "bold"\n  | Regular => "normal"\n  }\n}\nlet string_of_fontStyle = s => {\n  switch (s) {\n  | Italic => "italic"\n  | Normal => "normal"\n  }\n}\nlet string_of_style = s => {\n  switch (s) {\n  | LineWidth(w) =>\n    Printf.sprintf("stroke-width=\'%f\'", w)\n  | LineColor(c) =>\n    Printf.sprintf("stroke=\'%s\'", string_of_color(c))\n  | FillColor(c) => \n    Printf.sprintf("fill=\'%s\'", string_of_color(c))\n  | Dashed =>\n    "stroke-dasharray=\'4\'"\n  | Font(size, family, weight, style) =>\n    Printf.sprintf("font-size=\'%frem\' font-family=\'%s\' font-weight=\'%s\' font-style=\'%s\'",\n      size, string_of_fontFamily(family), string_of_fontWeight(weight), string_of_fontStyle(style))\n  }\n}\nlet radians = a => {\n  a *. 3.14159265358979 /. 180.0\n};\nlet getPoint = elt => {\n  switch (elt) {\n  | MoveTo(p) => p\n  | LineTo(p) => p\n  | CurveTo(_, _, p) => p\n  }\n};\nlet rec bbox_of_points = ps => {\n  switch (ps) {\n  | [] => (0., 0., 0., 0.)\n  | [(x, y)] => (x, x, y, y)\n  | [(x, y), ...rest] => {\n      let (l, r, t, b) = bbox_of_points(rest);\n      (min(x, l), max(x, r), min(y, t), max(y, b))\n    }\n  }\n};\nlet rec bbox = img => {\n  switch (img) {\n  | Empty => (0., 0., 0., 0.)\n  | Ellipse(w, h) => (-.w /. 2., w /. 2., -.h /. 2., h /. 2.)\n  | Rectangle(w, h) => (-.w /. 2., w /. 2., -.h /. 2., h /. 2.)\n  | Text(_) => (0., 0., 0., 0.)\n  | OpenPath(elts) => {\n    bbox_of_points(List.map(getPoint, elts))\n  }\n  | ClosedPath(elts) => {\n    bbox_of_points(List.map(getPoint, elts))\n  }\n  | Beside(l, r) => {\n    let (ll, lr, lt, lb) = bbox(l);\n    let (rl, rr, rt, rb) = bbox(r);\n    let w = (lr -. ll) +. (rr -. rl);\n    (-.w /. 2., w /. 2., min(lt, rt), max(lb, rb))\n  }\n  | Above(t, b) => {\n    let (tl, tr, tt, tb) = bbox(t);\n    let (bl, br, bt, bb) = bbox(b);\n    let h = (tb -. tt) +. (bb -. bt);\n    (min(tl, bl), max(tr, br), -.h /. 2., h /. 2.)\n  }\n  | On(a, b) => {\n    let (al, ar, at, ab) = bbox(a);\n    let (bl, br, bt, bb) = bbox(b);\n    (min(al, bl), max(ar, br), min(at, bt), max(ab, bb))\n  }\n  | Styled(img, _) => bbox(img)\n  | Translate(img, x, y) => {\n    let (l, r, t, b) = bbox(img);\n    (l +. x, r +. x, t +. y, b +. y)\n  }\n  | Rotate(img, a) => {\n    let (l, r, t, b) = bbox(img);\n    let ps = [(l, t), (l, b), (r, t), (r, b)];\n    let arad = radians(a);\n    let cosa = cos(arad);\n    let sina = sin(arad);\n    let rot = ((x, y)) => { (x *. cosa -. y *. sina, x *. sina +. y *. cosa) }\n    bbox_of_points(List.map(rot, ps))\n  }\n  | Scale(img, sx, sy) => {\n    let (l, r, t, b) = bbox(img);\n    (l *. sx, r *. sx, t *. sy, b *. sy)\n  }\n  | Bounds(_, l, r, t, b) => (l, r, t, b)\n  }\n};\nlet left = img => {\n    let (l, _, _, _) = bbox(img);\n    l\n};\nlet right = img => {\n    let (_, r, _, _) = bbox(img);\n    r\n};\nlet top = img => {\n    let (_, _, t, _) = bbox(img);\n    t\n};\nlet bottom = img => {\n    let (_, _, _, b) = bbox(img);\n    b\n};\nlet width = img => {\n    let (l, r, _, _) = bbox(img);\n    r -. l\n};\nlet height = img => {\n    let (_, _, t, b) = bbox(img);\n    b -. t\n};\nlet topLeft = img => {\n    let (l, _, t, _) = bbox(img);\n    (l, t)\n};\nlet topRight = img => {\n    let (_, r, t, _) = bbox(img);\n    (r, t)\n};\nlet bottomLeft = img => {\n    let (l, _, _, b) = bbox(img);\n    (l, b)\n};\nlet bottomRight = img => {\n    let (_, r, _, b) = bbox(img);\n    (r, b)\n};\nlet rec string_of_path = path => {\n  switch (path) {\n  | [] => ""\n  | [MoveTo((x, y)), ...rest] =>\n      Printf.sprintf("M %f %f ", x, y) ++ string_of_path(rest)\n  | [LineTo((x, y)), ...rest] =>\n      Printf.sprintf("L %f %f ", x, y) ++ string_of_path(rest)\n  | [CurveTo((x1, y1), (x2, y2), (x3, y3)), ...rest] =>\n      Printf.sprintf("C %f %f, %f %f, %f %f ", x1, y1, x2, y2, x3, y3) ++ string_of_path(rest)\n  }\n};\nlet rec render = img => {\n  switch (img) {\n  | Empty => ""\n  | Ellipse(w, h) =>\n    Printf.sprintf("<ellipse rx=\'%f\' ry=\'%f\' cx=\'0\' cy=\'0\' />",\n      w /. 2., h /. 2.)\n  | Rectangle(w, h) =>\n    Printf.sprintf("<rect width=\'%f\' height=\'%f\' x=\'%f\' y=\'%f\' />",\n      w, h, -.w /. 2., -.h /. 2.)\n  | Text(s) =>\n    Printf.sprintf("<text x=\'0\' y=\'0\' text-anchor=\'middle\' dominant-baseline=\'middle\'>%s</text>", s)\n  | OpenPath(path) =>\n    Printf.sprintf("<path d=\'%s\' fill=\'none\' stroke-linejoin=\'round\' stroke-linecap=\'round\' />", string_of_path(path))\n  | ClosedPath(path) => \n    Printf.sprintf("<path d=\'%sZ\' stroke-linejoin=\'round\' stroke-linecap=\'round\' />", string_of_path(path))\n  | Beside(l, r) => {\n      let (ll, lr, _, _) = bbox(l);\n      let (rl, rr, _, _) = bbox(r);\n      let w = (lr -. ll) +. (rr -. rl);\n      Printf.sprintf("<g transform=\'translate(%f,0)\'>%s</g>",\n        -.w /. 2. -. ll, render(l))\n      ++\n      Printf.sprintf("<g transform=\'translate(%f,0)\'>%s</g>",\n        w /. 2. -. rr, render(r))\n    } \n  | Above(t, b) => {\n      let (_, _, tt, tb) = bbox(t);\n      let (_, _, bt, bb) = bbox(b);\n      let h = (tb -. tt) +. (bb -. bt);\n      Printf.sprintf("<g transform=\'translate(0,%f)\'>%s</g>",\n        -.h /. 2. -. tt, render(t))\n      ++\n      Printf.sprintf("<g transform=\'translate(0,%f)\'>%s</g>",\n        h /. 2. -. bb, render(b))\n    }\n  | On(a, b) => render(b) ++ render(a)\n  | Styled(img, stys) => {\n      let ss = List.map(s => { " " ++ string_of_style(s) }, stys);\n      Printf.sprintf("<g %s>%s</g>", List.fold_left((++), "", ss), render(img))\n    }\n  | Translate(img, x, y) =>\n    Printf.sprintf("<g transform=\'translate(%f,%f)\'>%s</g>",\n      x, y, render(img))\n  | Rotate(img, a) =>\n    Printf.sprintf("<g transform=\'rotate(%f)\'>%s</g>",\n      a, render(img))\n  | Scale(img, sx, sy) =>\n    Printf.sprintf("<g transform=\'scale(%f,%f)\'>%s</g>",\n      sx, sy, render(img))\n  | Bounds(img, _, _, _, _) => render(img)\n  }\n};\nlet draw = image => {\n  let (l, r, t, b) = bbox(image);\n  let w = r -. l;\n  let h = b -. t;\n  let padw = w *. 0.05;\n  let padh = h *. 0.05;\n  let newl = min(l -. padw, -100.);\n  let newr = max(r +. padw, 100.);\n  let newt = t -. padh;\n  let newb = b +. padh;\n  Printf.printf("<svg viewBox=\'%f %f %f %f\' width=\'100%%\' preserveAspectRatio>",\n    newl, newt, newr -. newl, newb -. newt);\n  print_string("<g fill=\'grey\' stroke=\'black\' font-family=\'Roboto Mono, monospace\' font-size=\'1rem\'>");\n  print_string(render(image));\n  print_string("</g></svg>\\n");\n};\nlet empty = Empty;\nlet circle = r => { Ellipse(2. *. r, 2. *. r) };\nlet ellipse = (w, h) => { Ellipse(w, h) };\nlet rectangle = (w, h) => { Rectangle(w, h) };\nlet square = w => { Rectangle(w, w) };\nlet triangle = (w, h) => { ClosedPath([\n    MoveTo((-. w /. 2., h /. 2.)),\n    LineTo((0., -. h /. 2.)),\n    LineTo((w /. 2., h /. 2.))\n  ]) };\nlet text = s => { Text(s) };\nlet (---) = (a, b) => { Above(a, b) };\nlet (|||) = (a, b) => { Beside(a, b) };\nlet (***) = (a, b) => { On(a, b) };\nlet fill = (c, img) => { Styled(img, [FillColor(c)]) };\nlet stroke = (c, img) => { Styled(img, [LineColor(c)]) };\nlet solid = (c, img) => { Styled(img, [FillColor(c), LineColor(c)]) };\nlet strokeWidth = (w, img) => { Styled(img, [LineWidth(w)]) };\nlet withFont = (size, family, weight, style, img) => { Styled(img, [Font(size, family, weight, style)]) };\nlet focus = (pos, img) => {\n  let (l, r, t, b) = bbox(img);\n  switch (pos) {\n  | TL => Translate(img, -.l, -.t)\n  | TC => Translate(img, -.(l +. r) /. 2., -.t)\n  | TR => Translate(img, -.r, -.t)\n  | ML => Translate(img, -.l, -.(t +. b) /. 2.)\n  | MC => Translate(img, -.(l +. r) /. 2., -.(t +. b) /. 2.)\n  | MR => Translate(img, -.r, -.(t +. b) /. 2.)\n  | BL => Translate(img, -.l, -.b)\n  | BC => Translate(img, -.(l +. r) /. 2., -.b)\n  | BR => Translate(img, -.r, -.b)\n  }\n};\nlet rotate = (a, img) => { Rotate(img, a) };\nlet translate = (dx, dy, img) => { Translate(img, dx, dy) };\nlet scalexy = (sx, sy, img) => { Scale(img, sx, sy) };\nlet scale = (s, img) => { Scale(img, s, s) };\nlet setBounds = (l, r, t, b, img) => { Bounds(img, l, r, t, b) };\nlet showBounds = img => {\n  let (l, r, t, b) = bbox(img);\n  let w = r -. l;\n  let h = b -. t;\n  On(\n    Bounds(Styled(\n      circle(max(w, h) /. 20.) ***\n        OpenPath([MoveTo((-.w /. 10., 0.)), LineTo((w /. 10., 0.))]) ***\n        OpenPath([MoveTo((0., -.h /. 10.)), LineTo((0., h /. 10.))]) ***\n        Translate(rectangle(w, h), l +. w /. 2., t +. h /. 2.),\n      [Dashed, FillColor(Color("none")), LineColor(Color("black")), LineWidth(1.0)]), 0., 0., 0., 0.),\n    img\n  )\n}\nlet polar = (r, theta) => {\n  let a = radians(theta);\n  (r *. cos(a), r *. sin(a))\n};\nlet rgb = (r, g, b) => { RGBA(r, g, b, 1.0) };\nlet rgba = (r, b, g, a) => { RGBA(r, g, b, a) };\nlet hsl = (h, s, l) => { HSLA(h, s, l, 1.0) };\nlet hsla = (h, s, l, a) => {HSLA(h, s, l, a) };\nlet moveXY = (x, y) => { MoveTo((x, y)) };\nlet lineXY = (x, y) => { LineTo((x, y)) };\nlet curveXY = (c1x, c1y, c2x, c2y, px, py) => { CurveTo((c1x, c1y), (c2x, c2y), (px, py)) };\nlet curveP = (c1, c2, p) => { CurveTo(c1, c2, p) };\nlet moveP = p => { MoveTo(p) };\nlet lineP = p => { LineTo(p) };\nlet rec circles = n => {\n  if (n == 0) {\n    Empty\n  } else {\n    let r = 10.0 *. sqrt(float_of_int(4 * n));\n    circles(n - 1) ***\n      solid(hsl(float_of_int(12 * n), 1.0, 0.5), ellipse(2. *. r, r))\n  }\n};\nlet logo = withFont(2., Mono, Bold, Normal, stroke(Color("none"), fill(Color("black"), text("DPoodle")))) *** circles(50);\ndraw(logo)\n')),Object(i.b)("p",null,"Based on the Doodle graphics library from ",Object(i.b)("a",Object(l.a)({parentName:"p"},{href:"https://creativescala.com/"}),"Creative Scala"),"."),Object(i.b)("p",null,"Here is an ugly example:"),Object(i.b)("pre",null,Object(i.b)("code",Object(l.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),'let blueFill = img => { Styled(img, [FillColor(Color("blue"))]) };\nlet wideLines = img => { Styled(img, [LineWidth(3.0)]) };\nlet redOutline = img => { Styled(img, [LineColor(Color("red"))]) };\nlet a = blueFill(Ellipse(60.0, 80.0));\nlet b = wideLines(Rectangle(50.0, 50.0));\nlet c = Ellipse(30.0, 30.0);\nlet d = Bounds(Text("Hello"), -24., 24., -7., 7.);\ndraw(On(Rotate(Scale(d, 5., 5.), 45.),\n        redOutline(Above(Beside(a, b), c))));\n')),Object(i.b)("p",null,"Here is the same with operators and other shortcuts:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"a ||| b")," is ",Object(i.b)("inlineCode",{parentName:"li"},"Beside(a, b)")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"a --- b")," is ",Object(i.b)("inlineCode",{parentName:"li"},"Above(a, b)")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"a *** b")," is ",Object(i.b)("inlineCode",{parentName:"li"},"On(a, b)"))),Object(i.b)("pre",null,Object(i.b)("code",Object(l.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),'let blueFill = fill(Color("blue"));\nlet wideLines = strokeWidth(3.0);\nlet redOutline = stroke(Color("red"));\nlet a = blueFill(ellipse(60.0, 80.0));\nlet b = wideLines(square(50.0));\nlet c = circle(30.0);\nlet d = setBounds(-24., 24., -7., 7., text("Hello"));\ndraw(rotate(45., scale(5., d)) *** redOutline((a ||| b) --- c));\n')),Object(i.b)("p",null,"Here is an example of drawing a polygon using a closed path and polar coordinates:"),Object(i.b)("pre",null,Object(i.b)("code",Object(l.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),'let polygon = (sides, size, initialAngle) => {\n  let rotation = 360. /. float_of_int(sides);\n  let getPoint = n => polar(size, rotation *. float_of_int(n) +. initialAngle);\n  let rec path = n => {\n    if (n == 0) {\n      []\n    } else {\n      [lineP(getPoint(n)), ...path(n - 1)]\n    }\n  };\n  ClosedPath([moveP(getPoint(sides)), ...path(sides - 1)])\n};\n\ndraw(solid(Color("green"), polygon(6, 30., 90.)));\n')),Object(i.b)("p",null,"Here is an arrow. The ",Object(i.b)("inlineCode",{parentName:"p"},"focus")," function moves the ",Object(i.b)("em",{parentName:"p"},"focus")," point of the image (the point used\nto line up images with ",Object(i.b)("inlineCode",{parentName:"p"},"On"),", ",Object(i.b)("inlineCode",{parentName:"p"},"Beside"),", and ",Object(i.b)("inlineCode",{parentName:"p"},"Above"),").\nThe first argument of focus is a two-letter value; the first letter is (T)op, (M)iddle, or (B)ottom, and the second is (L)eft, (C)enter, or (R)ight.\nThe value ",Object(i.b)("inlineCode",{parentName:"p"},"ML")," says to move the focus to the middle of the left edge of the bounding box, which in this\ncase is the tail end of the arrow.\nWe can use the ",Object(i.b)("inlineCode",{parentName:"p"},"showBounds")," function to visualize the bounding box and focus point."),Object(i.b)("pre",null,Object(i.b)("code",Object(l.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),'let arrow = len => {\n  strokeWidth(2., focus(ML, OpenPath([\n    moveXY(0., 0.),\n    lineXY(len, 0.),\n    lineXY(len -. 5., 5.),\n    moveXY(len, 0.),\n    lineXY(len -. 5., -5.)])))\n};\n\ndraw(arrow(50.))\n\ndraw(showBounds(arrow(50.)))\n\ndraw(arrow(50.) *** rotate(-90., arrow(30.)) *** fill(Color("white"), circle(60.)))\n')),Object(i.b)("p",null,"Using the arrow, here is a function to visualize a linked list:"),Object(i.b)("pre",null,Object(i.b)("code",Object(l.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),'let listNode = n => {\n  let valueField = solid(Color("black"), text(string_of_int(n))) *** square(20.);\n  let nextField = arrow(20.) *** square(20.);\n  fill(Color("white"), valueField ||| nextField)\n};\n\nlet rec showList = nums => {\n  switch (nums) {\n  | [] => solid(Color("black"), circle(5.))\n  | [head, ...tail] => listNode(head) ||| showList(tail)\n  }\n};\n\ndraw(showList([1, 2, 3]));\ndraw(showList([1, 2, 3, 4, 5, 6, 7, 8, 9]));\n')))}c.isMDXComponent=!0},182:function(n,e,t){"use strict";t.d(e,"a",(function(){return p})),t.d(e,"b",(function(){return m}));var l=t(0),r=t.n(l);function i(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function o(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(n);e&&(l=l.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,l)}return t}function a(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?o(Object(t),!0).forEach((function(e){i(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function s(n,e){if(null==n)return{};var t,l,r=function(n,e){if(null==n)return{};var t,l,r={},i=Object.keys(n);for(l=0;l<i.length;l++)t=i[l],e.indexOf(t)>=0||(r[t]=n[t]);return r}(n,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);for(l=0;l<i.length;l++)t=i[l],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(r[t]=n[t])}return r}var b=r.a.createContext({}),c=function(n){var e=r.a.useContext(b),t=e;return n&&(t="function"==typeof n?n(e):a({},e,{},n)),t},p=function(n){var e=c(n.components);return r.a.createElement(b.Provider,{value:e},n.children)},f={inlineCode:"code",wrapper:function(n){var e=n.children;return r.a.createElement(r.a.Fragment,{},e)}},d=Object(l.forwardRef)((function(n,e){var t=n.components,l=n.mdxType,i=n.originalType,o=n.parentName,b=s(n,["components","mdxType","originalType","parentName"]),p=c(t),d=l,m=p["".concat(o,".").concat(d)]||p[d]||f[d]||i;return t?r.a.createElement(m,a({ref:e},b,{components:t})):r.a.createElement(m,a({ref:e},b))}));function m(n,e){var t=arguments,l=e&&e.mdxType;if("string"==typeof n||l){var i=t.length,o=new Array(i);o[0]=d;var a={};for(var s in e)hasOwnProperty.call(e,s)&&(a[s]=e[s]);a.originalType=n,a.mdxType="string"==typeof n?n:l,o[1]=a;for(var b=2;b<i;b++)o[b]=t[b];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,t)}d.displayName="MDXCreateElement"}}]);