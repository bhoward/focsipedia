(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{110:function(n,e,t){"use strict";t.r(e),t.d(e,"frontMatter",(function(){return o})),t.d(e,"metadata",(function(){return a})),t.d(e,"rightToc",(function(){return s})),t.d(e,"default",(function(){return p}));var r=t(1),l=t(6),i=(t(0),t(171)),o={id:"doodle",title:"Doodle Graphics"},a={id:"fp/doodle",title:"Doodle Graphics",description:"```reason hidden",source:"@site/docs/fp/doodle.md",permalink:"/focsipedia/docs/fp/doodle",editUrl:"https://github.com/bhoward/focsipedia/edit/master/docs/fp/doodle.md",sidebar:"someSidebar",previous:{title:"Types in Functional Programming",permalink:"/focsipedia/docs/fp/types"},next:{title:"ReasonML",permalink:"/focsipedia/docs/reason"}},s=[],f={rightToc:s},b="wrapper";function p(n){var e=n.components,t=Object(l.a)(n,["components"]);return Object(i.b)(b,Object(r.a)({},f,t,{components:e,mdxType:"MDXLayout"}),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-reason",metastring:"hidden",hidden:!0}),'type point = (float, float);\ntype pathElement =\n| MoveTo(point)\n| LineTo(point)\n| CurveTo(point, point, point);\ntype color =\n| Color(string)\n| RGBA(float, float, float, float)\n| HSLA(float, float, float, float);\ntype style =\n| LineWidth(float)\n| LineColor(color) /* TODO patterns? */\n| FillColor(color)\n| Dashed; /* TODO: Font(family, size, style, ...) */\ntype angle = float;\ntype image =\n| Empty\n| Ellipse(float, float)\n| Rectangle(float, float)\n| Text(string)\n| OpenPath(list(pathElement))\n| ClosedPath(list(pathElement))\n| Beside(image, image)\n| Above(image, image)\n| On(image, image)\n| Styled(image, list(style))\n| Translate(image, float, float)\n| Rotate(image, angle)\n| Scale(image, float, float)\n| Bounds(image, float, float, float, float);\nlet string_of_color = c => {\n  switch (c) {\n  | Color(s) => s\n  | RGBA(r, g, b, a) =>\n    Printf.sprintf("rgba(%d,%d,%d,%f)",\n      int_of_float(r), int_of_float(g), int_of_float(b), a)\n  | HSLA(h, s, l, a) =>\n    Printf.sprintf("hsla(%f,%d%%,%d%%,%f)",\n      h, int_of_float(s *. 100.), int_of_float(l *. 100.), a)\n  }\n};\nlet string_of_style = s => {\n  switch (s) {\n  | LineWidth(w) =>\n    Printf.sprintf("stroke-width=\'%f\'", w)\n  | LineColor(c) =>\n    Printf.sprintf("stroke=\'%s\'", string_of_color(c))\n  | FillColor(c) => \n    Printf.sprintf("fill=\'%s\'", string_of_color(c))\n  | Dashed =>\n    "stroke-dasharray=\'4\'"\n  }\n}\nlet getPoint = elt => {\n  switch (elt) {\n  | MoveTo(p) => p\n  | LineTo(p) => p\n  | CurveTo(_, _, p) => p\n  }\n};\nlet rec bbox_of_points = ps => {\n  switch (ps) {\n  | [] => (0., 0., 0., 0.)\n  | [(x, y)] => (x, x, y, y)\n  | [(x, y), ...rest] => {\n      let (l, r, t, b) = bbox_of_points(rest);\n      (min(x, l), max(x, r), min(y, t), max(y, b))\n    }\n  }\n};\nlet rec bbox = img => {\n  switch (img) {\n  | Empty => (0., 0., 0., 0.)\n  | Ellipse(w, h) => (-.w /. 2., w /. 2., -.h /. 2., h /. 2.)\n  | Rectangle(w, h) => (-.w /. 2., w /. 2., -.h /. 2., h /. 2.)\n  | Text(_) => (0., 0., 0., 0.)\n  | OpenPath(elts) => {\n    bbox_of_points(List.map(getPoint, elts))\n  }\n  | ClosedPath(elts) => {\n    bbox_of_points(List.map(getPoint, elts))\n  }\n  | Beside(l, r) => {\n    let (ll, lr, lt, lb) = bbox(l);\n    let (rl, rr, rt, rb) = bbox(r);\n    (ll -. (rr -. rl) /. 2., rr +. (lr -. ll) /. 2., min(lt, rt), max(lb, rb))\n  }\n  | Above(t, b) => {\n    let (tl, tr, tt, tb) = bbox(t);\n    let (bl, br, bt, bb) = bbox(b);\n    (min(tl, bl), max(tr, br), tt -. (bb -. bt) /. 2., bb +. (tb -. tt) /. 2.)\n  }\n  | On(a, b) => {\n    let (al, ar, at, ab) = bbox(a);\n    let (bl, br, bt, bb) = bbox(b);\n    (min(al, bl), max(ar, br), min(at, bt), max(ab, bb))\n  }\n  | Styled(img, _) => bbox(img)\n  | Translate(img, x, y) => {\n    let (l, r, t, b) = bbox(img);\n    (l +. x, r +. x, t +. y, b +. y)\n  }\n  | Rotate(img, a) => {\n    let (l, r, t, b) = bbox(img);\n    let ps = [(l, t), (l, b), (r, t), (r, b)];\n    let arad = a *. 3.14159265358979 /. 180.0;\n    let cosa = cos(arad);\n    let sina = sin(arad);\n    let rot = ((x, y)) => { (x *. cosa -. y *. sina, x *. sina +. y *. cosa) }\n    bbox_of_points(List.map(rot, ps))\n  }\n  | Scale(img, sx, sy) => {\n    let (l, r, t, b) = bbox(img);\n    (l *. sx, r *. sx, t *. sy, b *. sy)\n  }\n  | Bounds(_, l, r, t, b) => (l, r, t, b)\n  }\n};\nlet rec width = img => {\n  let (l, r, _, _) = bbox(img);\n  r -. l\n};\nlet rec height = img => {\n  let (_, _, t, b) = bbox(img);\n  b -. t\n};\nlet rec string_of_path = path => {\n  switch (path) {\n  | [] => ""\n  | [MoveTo((x, y)), ...rest] =>\n      Printf.sprintf("M %f %f ", x, y) ++ string_of_path(rest)\n  | [LineTo((x, y)), ...rest] =>\n      Printf.sprintf("L %f %f ", x, y) ++ string_of_path(rest)\n  | [CurveTo((x1, y1), (x2, y2), (x3, y3)), ...rest] =>\n      Printf.sprintf("C %f %f, %f %f, %f %f ", x1, y1, x2, y2, x3, y3) ++ string_of_path(rest)\n  }\n};\nlet rec render = img => {\n  switch (img) {\n  | Empty => ""\n  | Ellipse(w, h) =>\n    Printf.sprintf("<ellipse rx=\'%f\' ry=\'%f\' cx=\'0\' cy=\'0\' />",\n      w /. 2., h /. 2.)\n  | Rectangle(w, h) =>\n    Printf.sprintf("<rect width=\'%f\' height=\'%f\' x=\'%f\' y=\'%f\' />",\n      w, h, -.w /. 2., -.h /. 2.)\n  | Text(s) =>\n    Printf.sprintf("<text x=\'0\' y=\'0\' text-anchor=\'middle\' dominant-baseline=\'middle\'>%s</text>", s)\n  | OpenPath(path) =>\n    Printf.sprintf("<path d=\'%s\' />", string_of_path(path))\n  | ClosedPath(path) => \n    Printf.sprintf("<path d=\'%sZ\' />", string_of_path(path))\n  | Beside(l, r) =>\n    Printf.sprintf("<g transform=\'translate(%f,0)\'>%s</g>",\n      -.width(r) /. 2., render(l))\n    ++\n    Printf.sprintf("<g transform=\'translate(%f,0)\'>%s</g>",\n      width(l) /. 2., render(r))\n  | Above(t, b) =>\n    Printf.sprintf("<g transform=\'translate(0,%f)\'>%s</g>",\n      -.height(b) /. 2., render(t))\n    ++\n    Printf.sprintf("<g transform=\'translate(0,%f)\'>%s</g>",\n      height(t) /. 2., render(b))\n  | On(a, b) => render(b) ++ render(a)\n  | Styled(img, stys) => {\n      let ss = List.map(s => { " " ++ string_of_style(s) }, stys);\n      Printf.sprintf("<g %s>%s</g>", List.fold_left((++), "", ss), render(img))\n    }\n  | Translate(img, x, y) =>\n    Printf.sprintf("<g transform=\'translate(%f,%f)\'>%s</g>",\n      x, y, render(img))\n  | Rotate(img, a) =>\n    Printf.sprintf("<g transform=\'rotate(%f)\'>%s</g>",\n      a, render(img))\n  | Scale(img, sx, sy) =>\n    Printf.sprintf("<g transform=\'scale(%f,%f)\'>%s</g>",\n      sx, sy, render(img))\n  | Bounds(img, _, _, _, _) => render(img)\n  }\n};\nlet draw = image => {\n  print_string("<svg viewBox=\'-100 -100 200 200\' width=\'100%\' preserveAspectRatio>");\n  print_string("<g fill=\'grey\' stroke=\'black\' font-size=\'14\'>");\n  print_string(render(image));\n  print_string("</g></svg>\\n");\n};\nlet circle = r => { Ellipse(2. *. r, 2. *. r) };\nlet ellipse = (w, h) => { Ellipse(w, h) };\nlet rectangle = (w, h) => { Rectangle(w, h) };\nlet square = w => { Rectangle(w, w) };\nlet (---) = (a, b) => { Above(a, b) };\nlet (|||) = (a, b) => { Beside(a, b) };\nlet (***) = (a, b) => { On(a, b) };\nlet text = s => { Text(s) };\n\nlet showBounds = img => {\n  let (l, r, t, b) = bbox(img);\n  let w = r -. l;\n  let h = b -. t;\n  On(\n    Styled(\n      circle(10.) ***\n        OpenPath([MoveTo((-20., 0.)), LineTo((20., 0.))]) ***\n        OpenPath([MoveTo((0., -20.)), LineTo((0., 20.))]) ***\n        Translate(rectangle(w, h), l +. w /. 2., t +. h /. 2.),\n      [Dashed, FillColor(Color("none")), LineColor(Color("black")), LineWidth(1.0)]),\n    img\n  )\n}\n\nlet rec foo = n => {\n  if (n == 0) {\n    Empty\n  } else {\n    On(foo(n - 1), Styled(circle(float_of_int(10 * n)),\n      [FillColor(HSLA(float_of_int(24 * n), 1.0, 0.5, 1.0))]))\n  }\n};\ndraw(On(Scale(Styled(Text("DPoodle"), [FillColor(Color("black"))]), 2.1, 2.1), foo(10)))\n')),Object(i.b)("p",null,"Here is an ugly example:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),'let blueFill = img => { Styled(img, [FillColor(Color("blue"))]) };\nlet wideLines = img => { Styled(img, [LineWidth(3.0)]) };\nlet redOutline = img => { Styled(img, [LineColor(Color("red"))]) };\nlet a = blueFill(ellipse(60.0, 80.0));\nlet b = wideLines(rectangle(50.0, 50.0));\nlet c = circle(30.0);\nlet d = Text("Hello");\ndraw(On(Rotate(Scale(d, 5., 5.), 45.),\n        redOutline(Above(Beside(a, b), c))));\n')),Object(i.b)("p",null,"Here is the same with operators:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"a ||| b")," is ",Object(i.b)("inlineCode",{parentName:"li"},"Beside(a, b)")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"a --- b")," is ",Object(i.b)("inlineCode",{parentName:"li"},"Above(a, b)")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"a *** b")," is ",Object(i.b)("inlineCode",{parentName:"li"},"On(a, b)"))),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"draw(Rotate(Scale(d, 5., 5.), 45.) *** redOutline((a ||| b) --- c));\n")))}p.isMDXComponent=!0},171:function(n,e,t){"use strict";t.d(e,"a",(function(){return p})),t.d(e,"b",(function(){return g}));var r=t(0),l=t.n(r);function i(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function o(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function a(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?o(Object(t),!0).forEach((function(e){i(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function s(n,e){if(null==n)return{};var t,r,l=function(n,e){if(null==n)return{};var t,r,l={},i=Object.keys(n);for(r=0;r<i.length;r++)t=i[r],e.indexOf(t)>=0||(l[t]=n[t]);return l}(n,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);for(r=0;r<i.length;r++)t=i[r],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(l[t]=n[t])}return l}var f=l.a.createContext({}),b=function(n){var e=l.a.useContext(f),t=e;return n&&(t="function"==typeof n?n(e):a({},e,{},n)),t},p=function(n){var e=b(n.components);return l.a.createElement(f.Provider,{value:e},n.children)},c="mdxType",d={inlineCode:"code",wrapper:function(n){var e=n.children;return l.a.createElement(l.a.Fragment,{},e)}},m=Object(r.forwardRef)((function(n,e){var t=n.components,r=n.mdxType,i=n.originalType,o=n.parentName,f=s(n,["components","mdxType","originalType","parentName"]),p=b(t),c=r,m=p["".concat(o,".").concat(c)]||p[c]||d[c]||i;return t?l.a.createElement(m,a({ref:e},f,{components:t})):l.a.createElement(m,a({ref:e},f))}));function g(n,e){var t=arguments,r=e&&e.mdxType;if("string"==typeof n||r){var i=t.length,o=new Array(i);o[0]=m;var a={};for(var s in e)hasOwnProperty.call(e,s)&&(a[s]=e[s]);a.originalType=n,a[c]="string"==typeof n?n:r,o[1]=a;for(var f=2;f<i;f++)o[f]=t[f];return l.a.createElement.apply(null,o)}return l.a.createElement.apply(null,t)}m.displayName="MDXCreateElement"}}]);