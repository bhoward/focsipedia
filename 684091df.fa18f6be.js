(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{158:function(n,e,t){"use strict";t.r(e),t.d(e,"frontMatter",(function(){return p})),t.d(e,"metadata",(function(){return u})),t.d(e,"rightToc",(function(){return a})),t.d(e,"default",(function(){return c}));var r=t(1),i=t(6),s=(t(0),t(240)),p={id:"parser-comb",title:"Recursive Descent and Parser Combinators"},u={id:"fp/parser-comb",title:"Recursive Descent and Parser Combinators",description:"(In progress)",source:"@site/docs/fp/parser-comb.md",permalink:"/focsipedia/docs/fp/parser-comb",editUrl:"https://github.com/bhoward/focsipedia/edit/master/docs/fp/parser-comb.md",sidebar:"someSidebar",previous:{title:"State Machines in Java and ReasonML",permalink:"/focsipedia/docs/fp/state"},next:{title:"Sorting Lists",permalink:"/focsipedia/docs/ds/lists"}},a=[],l={rightToc:a};function c(n){var e=n.components,t=Object(i.a)(n,["components"]);return Object(s.b)("wrapper",Object(r.a)({},l,t,{components:e,mdxType:"MDXLayout"}),Object(s.b)("p",null,"(In progress)"),Object(s.b)("p",null,"Code based on ",Object(s.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/henoc/bs-little-parser"}),"bs-little-parser"),":"),Object(s.b)("pre",null,Object(s.b)("code",Object(r.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"module Input = {\n  type t = {text: string, index: int, whitespace: string};\n\n  let fromString = s => {text: s, index: 0, whitespace: \" \\t\\n\"};\n\n  let skipWhitespace = input => {\n    let whitespace = input.whitespace;\n    let spaceChars = List.init(String.length(whitespace), String.get(whitespace));\n    \n    let rec aux = input => {\n      if (String.length(input.text) <= input.index) {\n        input \n      } else if (List.mem(input.text.[input.index], spaceChars)) {\n        aux({...input, index: input.index+1})\n      } else {\n        input\n      }\n    };\n    aux(input)\n  };\n\n  let atEnd = input => {\n    input.index == String.length(input.text)\n  };\n};\n\nmodule Result = {\n  type t('a, 'b) = Ok('a) | Error('b);\n\n  let map = (f, result) => {\n    switch (result) {\n    | Ok(r) => Ok(f(r))\n    | Error(s) => Error(s)\n    }\n  };\n\n  let get = result => {\n    switch (result) {\n    | Ok(r) => Some(r)\n    | _ => None\n    }\n  };\n};\n\nmodule Parser = {\n  type parseResult('a) = Result.t(('a, Input.t), (string, Input.t))\n  type t('a) = Input.t => parseResult('a);\n\n  let success = (result, input): parseResult('a) =>\n    Result.Ok((result, input));\n  \n  let failure = (message, input): parseResult('a) =>\n    Result.Error((message, input));\n\n  let ( <*> ) = (p: t('a), q: t('b), input) => {\n    switch (p(input)) {\n    | Result.Ok((result1, input2)) =>\n        switch (q(input2)) {\n        | Result.Ok((result2, input3)) =>\n            success((result1, result2), input3)\n        | Result.Error((message, input)) =>\n            failure(message, input)\n        }\n    | Result.Error((message, input)) =>\n        failure(message, input)\n    }\n  };\n\n  let ( <* ) = (p: t('a), q: t('b), input) => {\n    switch(p(input)) {\n    | Result.Ok((result1, input2)) =>\n        switch (q(input2)) {\n        | Result.Ok((_, input3)) =>\n            success(result1, input3)\n        | Result.Error((message, input)) =>\n            failure(message, input)\n        }\n    | Result.Error((message, input)) =>\n        failure(message, input)\n    }\n  };\n\n  let ( *> ) = (p: t('a), q: t('b), input) => {\n    switch(p(input)) {\n    | Result.Ok((_, input2)) =>\n        switch (q(input2)) {\n        | Result.Ok((result2, input3)) =>\n            success(result2, input3)\n        | Result.Error((message, input)) =>\n            failure(message, input)\n        }\n    | Result.Error((message, input)) =>\n        failure(message, input)\n    }\n  };\n\n  let ( <|> ) = (p: t('a), q: t('a), input) => {\n    switch (p(input)) {\n    | Result.Ok((s, t)) => success(s, t)\n    | _ => q(input)\n    }\n  };\n\n  let rep = (p: t('a), input) => {\n    let rec aux = (accum, input) => {\n      switch (p(input)) {\n      | Result.Ok((r, i)) => aux([r, ...accum], i)\n      | _ => success(List.rev(accum), input)\n      }\n    };\n\n    aux([], input);\n  };\n\n  let rep1 = (p: t('a)) => p <*> rep(p);\n\n  let opt = (p: t('a), input) => {\n    switch (p(input)) {\n    | Result.Ok((r, i)) => success(Some(r), i)\n    | _ => success(None, input)\n    }\n  };\n\n  let andPred = (p: t('a), input) => {\n    switch (p(input)) {\n    | Result.Ok((r, _)) => success(r, input)\n    | Result.Error((message, input)) => failure(message, input)\n    }\n  };\n\n  let notPred = (p: t('a), input) => {\n    switch (p(input)) {\n    | Result.Ok((_, i)) => failure(\"notPred failure\", i)\n    | _ => success((), input)\n    }\n  };\n\n  let ( >> ) = (p: t('a), f, input) => {\n    switch (p(input)) {\n    | Result.Ok((r, i)) => f(r, i)\n    | Result.Error((message, input)) => failure(message, input)\n    }\n  };\n\n  let ( ^^ ) = (p: t('a), f, input): parseResult('b) =>\n    Result.map(((r, i)) => (f(r), i), p(input));\n\n  let chr = (c, rawInput) => {\n    let input = Input.skipWhitespace(rawInput);\n    if (Input.atEnd(input)) {\n      failure(\"not enough input\", input)\n    } else {\n      let firstChar = input.text.[input.index];\n      if (firstChar == c) {\n        success(c, {...input, index: input.index+1})\n      } else {\n        failure(Printf.sprintf(\"mismatch: %C found, expected %C\", firstChar, c), input)\n      }\n    }\n  };\n\n  let str = (s, rawInput) => {\n    let input = Input.skipWhitespace(rawInput);\n    let slen = String.length(s);\n    if (String.length(input.text) - slen < input.index) {\n      failure(\"not enough input\", input)\n    } else {\n      let substr = String.sub(input.text, input.index, slen);\n      if (substr == s) {\n        success(s, {...input, index: input.index+slen})\n      } else {\n        failure(Printf.sprintf(\"mismatch: %S found, expected %S\", substr, s), input)\n      }\n    }\n  };\n\n  let dfa = (init, step, finish, rawInput) => {\n    let input = Input.skipWhitespace(rawInput);\n    let rec aux = (state, i) => {\n      if (Input.atEnd(i)) {\n        (state, i)\n      } else {\n        let nextChar = i.text.[i.index];\n        switch (step(state, nextChar)) {\n        | Some(nextState) => aux(nextState, {...i, index: i.index+1})\n        | None => (state, i)\n        }\n      }\n    };\n    let (finalState, input2) = aux(init, input);\n    switch (finish(finalState)) {\n    | Ok(result) => success(result, input2)\n    | Error(message) => failure(message, input2)\n    }\n  };\n\n  let eoi = (rawInput) => {\n    let input = Input.skipWhitespace(rawInput);\n    let remain = String.length(input.text) - input.index;\n    if (remain == 0) {\n      success((), input)\n    } else {\n      failure(Printf.sprintf(\"unscanned input at end of parse: %S\", String.sub(input.text, input.index, remain)), input)\n    }\n  };\n\n  let parse = (input, parser: t('a)) => {\n    parser(input)\n  };\n\n  let parseAll = (input, parser: t('a)) => {\n    (parser <* eoi)(input)\n  };\n\n  let test = (parser: t('a), s) => {\n    switch (parseAll(Input.fromString(s), parser)) {\n    | Result.Ok((r, _)) => r\n    | Result.Error((m, _)) => failwith(m)\n    }\n  }\n};\n")),Object(s.b)("p",null,"Here is an example of a parser for arithmetic expressions:"),Object(s.b)("pre",null,Object(s.b)("code",Object(r.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"open Parser;\n\ntype exp =\n  | Ident(string)\n  | Num(int)\n  | BinOp(exp, char, exp);\n\nlet isLetter = c => ('A' <= c && c <= 'Z') || ('a' <= c && c <= 'z');\nlet isDigit = c => ('0' <= c && c <= '9');\nlet isLetterOrDigit = c => isLetter(c) || isDigit(c);\n\nlet ident = dfa(\n  \"\",\n  (s, c) => if ((s == \"\" && isLetter(c)) || (s != \"\" && isLetterOrDigit(c))) {\n      Some(s ++ String.make(1, c))\n    } else {\n      None\n    },\n  s => if (s == \"\") {\n      Error(\"expected identifier\")\n    } else {\n      Ok(Ident(s))\n    }\n);\n\nlet number = dfa(\n  \"\",\n  (s, c) => if (isDigit(c)) {\n    Some(s ++ String.make(1, c))\n  } else {\n    None\n  },\n  s => if (s == \"\") {\n    Error(\"expected number\")\n  } else {\n    Ok(Num(int_of_string(s)))\n  }\n);\n\nlet addop = chr('+') <|> chr('-');\nlet mulop = chr('*') <|> chr('/');\n\nlet rec expr = input => (\n  (term <*> rep(addop <*> term))\n  ^^ ((t, ts)) => List.fold_left((l, (op, r)) => BinOp(l, op, r), t, ts)\n)(input)\nand term = input => (\n  (factor <*> rep(mulop <*> factor))\n  ^^ ((f, fs)) => List.fold_left((l, (op, r)) => BinOp(l, op, r), f, fs)\n)(input)\nand factor = input => (\n  ident\n  <|> number\n  <|> (chr('(') *> expr <* chr(')'))\n)(input);\n\nlet sample = \"3*abc + (x1 - x0) * r2d2 / 42\";\nResult.get(parseAll(Input.fromString(sample), expr));\ntest(expr, sample);\n")))}c.isMDXComponent=!0},240:function(n,e,t){"use strict";t.d(e,"a",(function(){return o})),t.d(e,"b",(function(){return d}));var r=t(0),i=t.n(r);function s(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function p(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function u(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?p(Object(t),!0).forEach((function(e){s(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):p(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function a(n,e){if(null==n)return{};var t,r,i=function(n,e){if(null==n)return{};var t,r,i={},s=Object.keys(n);for(r=0;r<s.length;r++)t=s[r],e.indexOf(t)>=0||(i[t]=n[t]);return i}(n,e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(n);for(r=0;r<s.length;r++)t=s[r],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(i[t]=n[t])}return i}var l=i.a.createContext({}),c=function(n){var e=i.a.useContext(l),t=e;return n&&(t="function"==typeof n?n(e):u({},e,{},n)),t},o=function(n){var e=c(n.components);return i.a.createElement(l.Provider,{value:e},n.children)},f={inlineCode:"code",wrapper:function(n){var e=n.children;return i.a.createElement(i.a.Fragment,{},e)}},m=Object(r.forwardRef)((function(n,e){var t=n.components,r=n.mdxType,s=n.originalType,p=n.parentName,l=a(n,["components","mdxType","originalType","parentName"]),o=c(t),m=r,d=o["".concat(p,".").concat(m)]||o[m]||f[m]||s;return t?i.a.createElement(d,u({ref:e},l,{components:t})):i.a.createElement(d,u({ref:e},l))}));function d(n,e){var t=arguments,r=e&&e.mdxType;if("string"==typeof n||r){var s=t.length,p=new Array(s);p[0]=m;var u={};for(var a in e)hasOwnProperty.call(e,a)&&(u[a]=e[a]);u.originalType=n,u.mdxType="string"==typeof n?n:r,p[1]=u;for(var l=2;l<s;l++)p[l]=t[l];return i.a.createElement.apply(null,p)}return i.a.createElement.apply(null,t)}m.displayName="MDXCreateElement"}}]);