(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{127:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return i})),a.d(t,"metadata",(function(){return c})),a.d(t,"rightToc",(function(){return p})),a.d(t,"default",(function(){return o}));var n=a(1),s=a(6),r=(a(0),a(159)),i=(a(160),{id:"types",title:"Types in Functional Programming"}),c={id:"fp/types",title:"Types in Functional Programming",description:"import useBaseUrl from '@docusaurus/useBaseUrl';",source:"@site/docs/fp/types.md",permalink:"/focsipedia/docs/fp/types",editUrl:"https://github.com/bhoward/focsipedia/edit/master/docs/fp/types.md",sidebar:"someSidebar",previous:{title:"Introduction to Functional Programming",permalink:"/focsipedia/docs/fp/intro"},next:{title:"ReasonML",permalink:"/focsipedia/docs/reason"}},p=[{value:"Functions",id:"functions",children:[]},{value:"Type Inference",id:"type-inference",children:[{value:"Currying",id:"currying",children:[]}]},{value:"Tuples",id:"tuples",children:[{value:"Tuples and Parameters",id:"tuples-and-parameters",children:[]}]},{value:"Type Aliases and Parameterized Types",id:"type-aliases-and-parameterized-types",children:[]},{value:"Constructors and Variants",id:"constructors-and-variants",children:[{value:"Pattern Matching",id:"pattern-matching",children:[]},{value:"Recursive Types",id:"recursive-types",children:[]}]},{value:"Connection to Natural Deduction",id:"connection-to-natural-deduction",children:[]},{value:"Exercises",id:"exercises",children:[]}],b={rightToc:p},m="wrapper";function o(e){var t=e.components,a=Object(s.a)(e,["components"]);return Object(r.b)(m,Object(n.a)({},b,a,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"One of the hallmarks of modern functional programming is a strong and rich\nsystems of types. The type of an expression can be thought of as the set of all\nvalues that the expression might have; by specifying the type of a parameter to\na function, it constrains the values that may be provided as input. In this\nsense, the type of a function is then a form of contract: if the input satisfies\nsome condition (is a value in the parameter type), then the output is also\nguaranteed to satisfy a condition (be a value of the result type)."),Object(r.b)("h2",{id:"functions"},"Functions"),Object(r.b)("p",null,"In ReasonML we write the type of functions from ",Object(r.b)("inlineCode",{parentName:"p"},"A")," to ",Object(r.b)("inlineCode",{parentName:"p"},"B")," as ",Object(r.b)("inlineCode",{parentName:"p"},"A => B"),". Given a\nfunction ",Object(r.b)("inlineCode",{parentName:"p"},"f")," of that type, if ",Object(r.b)("inlineCode",{parentName:"p"},"x")," is a value (or more generally any expression)\nof type ",Object(r.b)("inlineCode",{parentName:"p"},"A"),", then the ",Object(r.b)("strong",{parentName:"p"},"application")," ",Object(r.b)("inlineCode",{parentName:"p"},"f(x)")," will give us a result of type ",Object(r.b)("inlineCode",{parentName:"p"},"B"),".\nThe value ",Object(r.b)("inlineCode",{parentName:"p"},"x")," to which we apply the function is known as the ",Object(r.b)("strong",{parentName:"p"},"argument"),".\nFor example, ",Object(r.b)("inlineCode",{parentName:"p"},"string_of_int")," is a function of type ",Object(r.b)("inlineCode",{parentName:"p"},"int => string"),"; when we\napply it to an integer, it returns the string of digits representing the argument:"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"let result = string_of_int(42);\n")),Object(r.b)("p",null,"Since functions are first-class values, we may bind a function to another name:"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"let f = string_of_int;\nlet result = f(42);\n")),Object(r.b)("div",{className:"admonition admonition-warning"},Object(r.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(r.b)("h5",{parentName:"div"},Object(r.b)("div",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(r.b)("svg",Object(n.a)({parentName:"div"},{xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"}),Object(r.b)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"})))),"warning")),Object(r.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(r.b)("p",{parentName:"div"},"Because the embedded ReasonML compiler here is first converting the code to\nOCaml, and then executing the OCaml code, it actually reports types using the\nOCaml syntax, which is slightly different! For example, OCaml uses a single\narrow ",Object(r.b)("inlineCode",{parentName:"p"},"->")," for function types instead of the double arrow ",Object(r.b)("inlineCode",{parentName:"p"},"=>"),". This is\nunfortunate, but as we will see below we rarely even need to write types."))),Object(r.b)("p",null,"To create a function value, we use the double arrow to show that we are taking\na parameter, for example ",Object(r.b)("inlineCode",{parentName:"p"},"p"),", and using it to compute a result:\n",Object(r.b)("inlineCode",{parentName:"p"},"p => { ...result expression... }"),". The parameter may be any variable name","\u2014",'it\nwill represent the value of the argument just within the block containing the\nresult expressions. That is, if the variable name had been used outside the function,\nit will be temporarily "shadowed" by the new binding; when the function has returned\nits result, the local binding to the argument goes away.'),Object(r.b)("p",null,"Consider the following example:"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"let x = 5;\nlet f = x => { x + 12 };\nlet y = f(x * x) + x;\n")),Object(r.b)("p",null,"The first binding to ",Object(r.b)("inlineCode",{parentName:"p"},"x")," is the integer 5. When ",Object(r.b)("inlineCode",{parentName:"p"},"f")," is applied to its argument,\nwhich is ",Object(r.b)("inlineCode",{parentName:"p"},"x * x"),", or 25, we will temporarily bind 25 to a new, local variable\nnamed ",Object(r.b)("inlineCode",{parentName:"p"},"x")," and evaluate the body of the function: ",Object(r.b)("inlineCode",{parentName:"p"},"x + 12"),", which gives 37.\nContinuing to evaluate the expression ",Object(r.b)("inlineCode",{parentName:"p"},"f(x * x) + x"),", we now have ",Object(r.b)("inlineCode",{parentName:"p"},"37 + x"),"; since\n",Object(r.b)("inlineCode",{parentName:"p"},"x")," here refers to the original binding, this is ",Object(r.b)("inlineCode",{parentName:"p"},"37 + 5"),", so it binds 42 to ",Object(r.b)("inlineCode",{parentName:"p"},"y"),"."),Object(r.b)("h2",{id:"type-inference"},"Type Inference"),Object(r.b)("p",null,"ReasonML does not require that we specify the types of variables most of the\ntime, because it can usually infer what types they should have from the context\nand how they are used. Looking at the example above, since 5 is an int, we know\nthat ",Object(r.b)("inlineCode",{parentName:"p"},"x")," must have type ",Object(r.b)("inlineCode",{parentName:"p"},"int"),". In the second line, the local ",Object(r.b)("inlineCode",{parentName:"p"},"x")," must also be an\n",Object(r.b)("inlineCode",{parentName:"p"},"int"),", since we can add 12 to it.",Object(r.b)("sup",Object(n.a)({parentName:"p"},{id:"fnref-1"}),Object(r.b)("a",Object(n.a)({parentName:"sup"},{href:"#fn-1",className:"footnote-ref"}),"1"))," The result of the function body will be an ",Object(r.b)("inlineCode",{parentName:"p"},"int"),", so\nthe type of ",Object(r.b)("inlineCode",{parentName:"p"},"f")," is ",Object(r.b)("inlineCode",{parentName:"p"},"int => int"),". Finally, the application of ",Object(r.b)("inlineCode",{parentName:"p"},"f")," in the third line\nchecks out, because it is applied to an integer argument (",Object(r.b)("inlineCode",{parentName:"p"},"x * x"),"), and its result\nis used in a further integer addition. We could be explicit about the types and\nadd a ",Object(r.b)("strong",{parentName:"p"},"type annotation")," to each of the bindings:"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"let x: int = 5;\nlet f: int => int = (x: int) => { x + 12 };\nlet y: int = f(x * x) + x;\nlet z: string = string_of_int(y);\n")),Object(r.b)("p",null,"However, the convention in ReasonML is that type annotations are not generally\nused except as documentation and as a check that the compiler is doing what we\nthink it is."),Object(r.b)("h3",{id:"currying"},"Currying"),Object(r.b)("p",null,"When we write a function that takes multiple arguments, we may list the parameters\nin parentheses, separated by commas:"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"let average = (a, b) => { float_of_int(a + b) /. 2.0 };\nlet result = average(7, 10);\n")),Object(r.b)("p",null,"This is actually a lie! In ReasonML, functions can only have a single argument.\nBehind the scenes, the code above is translated to the following:"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"let average = a => { b => { float_of_int(a + b) /. 2.0 } };\nlet result = average(7)(10);\n")),Object(r.b)("p",null,"That is, ",Object(r.b)("inlineCode",{parentName:"p"},"average")," is a function that takes an integer parameter ",Object(r.b)("inlineCode",{parentName:"p"},"a")," and returns\nanother function. This second function expects to be given another integer\nparameter, named ",Object(r.b)("inlineCode",{parentName:"p"},"b"),", and then it will compute the result (which is a ",Object(r.b)("inlineCode",{parentName:"p"},"float"),"\nfor variety). The computation on the second line corresponds to this: first\n",Object(r.b)("inlineCode",{parentName:"p"},"average")," is applied to the argument 7. The resulting function is then further\napplied to the argument 10, producing the desired floating-point result."),Object(r.b)("p",null,"Here is the same code, written out more explicitly:"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"let average: int => (int => float) = (a: int) => {\n  (b: int) => {\n    float_of_int(a + b) /. 2.0\n  }\n};\nlet result1: int => float = average(7);\nlet result: float = result1(10);\n")),Object(r.b)("p",null,"This replacement of multiple-parameter functions with a sequence of single-parameter\nfunctions is called ",Object(r.b)("strong",{parentName:"p"},"currying"),", named after the logician Haskell B. Curry.",Object(r.b)("sup",Object(n.a)({parentName:"p"},{id:"fnref-2"}),Object(r.b)("a",Object(n.a)({parentName:"sup"},{href:"#fn-2",className:"footnote-ref"}),"2"))," One advantage of this,\nother than the simplicity of only needing one kind of function, is that it is often\nuseful to create a ",Object(r.b)("strong",{parentName:"p"},"partially applied")," function, where some of its arguments have\nbeen supplied to create a new function ready to be given the rest. For example, suppose\nwe have a function for formatting exam grades:"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),'let format_grade = (exam, total, name, points) => {\n  name ++ ", " ++ exam ++ ": " ++ string_of_int(points) ++ "/" ++ string_of_int(total) \n};\nlet demo = format_grade("Midterm", 100, "Brian", 93);\n')),Object(r.b)("p",null,"We could take advantage of currying to create a specialized function for formatting the\nmidterm grades:"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),'let format_midterm = format_grade("Midterm", 100);\nlet demo1 = format_midterm("Brian", 93);\nlet demo2 = format_midterm("Alice", 97);\n')),Object(r.b)("p",null,"The first two arguments of ",Object(r.b)("inlineCode",{parentName:"p"},"format_grade"),' have been provided with the exam name\n("Midterm") and the total number of points (100). Now we have a new function,\nbound to ',Object(r.b)("inlineCode",{parentName:"p"},"format_midterm"),", that just needs to be applied to a student name and\ngrade, and then it can produce a string with all four components."),Object(r.b)("h2",{id:"tuples"},"Tuples"),Object(r.b)("p",null,"Perhaps the most basic form of data structure is the ",Object(r.b)("strong",{parentName:"p"},"tuple"),". We have already\nseen this in the context of\n",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"../sets/functions#pairs"}),"sets and cartesian products"),": an ",Object(r.b)("span",Object(n.a)({parentName:"p"},{className:"math math-inline"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(r.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(r.b)("semantics",{parentName:"math"},Object(r.b)("mrow",{parentName:"semantics"},Object(r.b)("mi",{parentName:"mrow"},"n")),Object(r.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"n")))),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault"}),"n"))))),"-tuple is simply\nan ordered listing of ",Object(r.b)("span",Object(n.a)({parentName:"p"},{className:"math math-inline"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(r.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(r.b)("semantics",{parentName:"math"},Object(r.b)("mrow",{parentName:"semantics"},Object(r.b)("mi",{parentName:"mrow"},"n")),Object(r.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"n")))),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault"}),"n")))))," values, traditionally shown in parentheses separated\nby commas. The ReasonML syntax for a tuple type is likewise an ordered listing\nof each value's type, in parentheses and separated by commas. For example, the\ntuple ",Object(r.b)("inlineCode",{parentName:"p"},'(42, "hello", 3.1416)')," has type ",Object(r.b)("inlineCode",{parentName:"p"},"(int, string, float)"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),'let demo: (int, string, float) = (42, "hello", 3.1416);\n')),Object(r.b)("div",{className:"admonition admonition-warning"},Object(r.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(r.b)("h5",{parentName:"div"},Object(r.b)("div",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(r.b)("svg",Object(n.a)({parentName:"div"},{xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"}),Object(r.b)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"})))),"warning")),Object(r.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(r.b)("p",{parentName:"div"},"Again the OCaml syntax differs from the ReasonML syntax, so you will see tuple\ntypes printed out with the types separated by asterisks: ",Object(r.b)("inlineCode",{parentName:"p"},"int * string * float"),"\ninstead of ",Object(r.b)("inlineCode",{parentName:"p"},"(int, string, float)"),". In OCaml they chose to make it look more like\na cartesian product, while ReasonML is trying to make the type look like the\nvalues it describes."))),Object(r.b)("p",null,"In the case ",Object(r.b)("span",Object(n.a)({parentName:"p"},{className:"math math-inline"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(r.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(r.b)("semantics",{parentName:"math"},Object(r.b)("mrow",{parentName:"semantics"},Object(r.b)("mi",{parentName:"mrow"},"n"),Object(r.b)("mo",{parentName:"mrow"},"="),Object(r.b)("mn",{parentName:"mrow"},"2")),Object(r.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"n=2")))),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault"}),"n"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2777777777777778em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mrel"}),"="),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2777777777777778em"}}))),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.64444em",verticalAlign:"0em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),"2"))))),", a tuple is just the familiar ",Object(r.b)("strong",{parentName:"p"},"pair"),". For example, the type\nof two-dimensional points with integer coordinates is ",Object(r.b)("inlineCode",{parentName:"p"},"(int, int)"),". Pairs come\nwith accessor functions named ",Object(r.b)("inlineCode",{parentName:"p"},"fst")," and ",Object(r.b)("inlineCode",{parentName:"p"},"snd")," to access the first and second\ncoordinates, respectively:"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"let p = (5, 10);\nlet x = fst(p);\nlet y = snd(p);\n")),Object(r.b)("p",null,"The standard library does not provide accessor functions for arbitrary\n",Object(r.b)("span",Object(n.a)({parentName:"p"},{className:"math math-inline"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(r.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(r.b)("semantics",{parentName:"math"},Object(r.b)("mrow",{parentName:"semantics"},Object(r.b)("mi",{parentName:"mrow"},"n")),Object(r.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"n")))),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault"}),"n"))))),"-tuples.",Object(r.b)("sup",Object(n.a)({parentName:"p"},{id:"fnref-3"}),Object(r.b)("a",Object(n.a)({parentName:"sup"},{href:"#fn-3",className:"footnote-ref"}),"3"))," Instead, we may retrieve\nthe components of a tuple through an extension of the binding operation, ",Object(r.b)("inlineCode",{parentName:"p"},"let"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),'let demo = (42, "hello", 3.1416); /* construct a tuple */\nlet (a, b, c) = demo;             /* "destruct" a tuple */\n')),Object(r.b)("p",null,"If we only want to extract some of the components, the other positions may be\nfilled with a place-holder, the so-called ",Object(r.b)("strong",{parentName:"p"},"wildcard")," identifier, ",Object(r.b)("inlineCode",{parentName:"p"},"_"),"\n(underscore):"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),'let demo = (42, "hello", 3.1416);\nlet (_, greeting, _) = demo;\n')),Object(r.b)("p",null,"An ",Object(r.b)("span",Object(n.a)({parentName:"p"},{className:"math math-inline"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(r.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(r.b)("semantics",{parentName:"math"},Object(r.b)("mrow",{parentName:"semantics"},Object(r.b)("mi",{parentName:"mrow"},"n")),Object(r.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"n")))),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault"}),"n"))))),"-tuple when ",Object(r.b)("span",Object(n.a)({parentName:"p"},{className:"math math-inline"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(r.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(r.b)("semantics",{parentName:"math"},Object(r.b)("mrow",{parentName:"semantics"},Object(r.b)("mi",{parentName:"mrow"},"n"),Object(r.b)("mo",{parentName:"mrow"},"="),Object(r.b)("mn",{parentName:"mrow"},"1")),Object(r.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"n=1")))),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault"}),"n"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2777777777777778em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mrel"}),"="),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2777777777777778em"}}))),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.64444em",verticalAlign:"0em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),"1")))))," is just an ordinary value (which may be enclosed in\nparentheses as usual just for grouping purposes). However, the case when\n",Object(r.b)("span",Object(n.a)({parentName:"p"},{className:"math math-inline"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(r.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(r.b)("semantics",{parentName:"math"},Object(r.b)("mrow",{parentName:"semantics"},Object(r.b)("mi",{parentName:"mrow"},"n"),Object(r.b)("mo",{parentName:"mrow"},"="),Object(r.b)("mn",{parentName:"mrow"},"0")),Object(r.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"n=0")))),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault"}),"n"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2777777777777778em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mrel"}),"="),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2777777777777778em"}}))),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.64444em",verticalAlign:"0em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),"0")))))," is more interesting: the only value is the empty tuple, ",Object(r.b)("inlineCode",{parentName:"p"},"()"),", and its type\nis named ",Object(r.b)("inlineCode",{parentName:"p"},"unit"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"let a: unit = ();\n")),Object(r.b)("p",null,"Since there is only one value of type ",Object(r.b)("inlineCode",{parentName:"p"},"unit"),", it carries no information. We\nwill use it when we need to specify a type but its value does not matter. For\nexample, look at the types of the print functions in ReasonML:"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"let a = print_int;\nlet b = print_string;\nlet c = print_float;\nlet d = print_newline;\n")),Object(r.b)("p",null,"All of them return a value of type ",Object(r.b)("inlineCode",{parentName:"p"},"unit")," because there is nothing to be\nreturned. In fact, this is a strong hint that these functions do their work via\nside-effects (albeit the relatively benign side-effect of sending some\ncharacters to the console). The ",Object(r.b)("inlineCode",{parentName:"p"},"print_newline")," function also takes ",Object(r.b)("inlineCode",{parentName:"p"},"unit")," as\nits argument type","\u2014","it needs no input, but there still needs to be some\nargument passed in so that it knows to do its job (emitting an end-of-line\ncharacter). Note the difference between the function value expression\n",Object(r.b)("inlineCode",{parentName:"p"},"print_newline"),", as seen above in the binding to ",Object(r.b)("inlineCode",{parentName:"p"},"d"),", and the function ",Object(r.b)("em",{parentName:"p"},"call"),"\nexpression ",Object(r.b)("inlineCode",{parentName:"p"},"print_newline()"),", which actually produces output:"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),'print_string("line 1, ");\nprint_newline;\nprint_string("still line 1");\nprint_newline();\nprint_string("line 2");\n')),Object(r.b)("h3",{id:"tuples-and-parameters"},"Tuples and Parameters"),Object(r.b)("p",null,"It might seem that tuples should be used to pass multiple parameters to\nfunctions, but as we have seen, ReasonML handles this by currying the function\ninto a series of functions each taking a single parameter. We can force it\nto pass tuples of arguments, and bind them to tuples of parameters, by\nincluding an extra pair of parentheses:"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),'let f: ((string, int)) => string = ((name, points)) => {\n  name ++ ": " ++ string_of_int(points) ++ "/100"\n};\nprint_string( f(("Brian", 93)) );\n')),Object(r.b)("p",null,"Now, that's ugly, and unless you really need to do that, don't do it. However,\nthis brings up an interesting equivalence of types. Note that the type for ",Object(r.b)("inlineCode",{parentName:"p"},"f"),"\nhere is ",Object(r.b)("inlineCode",{parentName:"p"},"((string, int)) => string"),"; in terms of sets, this is the set of\nfunctions ",Object(r.b)("span",Object(n.a)({parentName:"p"},{className:"math math-inline"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(r.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(r.b)("semantics",{parentName:"math"},Object(r.b)("mrow",{parentName:"semantics"},Object(r.b)("msup",{parentName:"mrow"},Object(r.b)("mtext",{parentName:"msup"},"string"),Object(r.b)("mrow",{parentName:"msup"},Object(r.b)("mtext",{parentName:"mrow"},"string"),Object(r.b)("mo",{parentName:"mrow"},"\xd7"),Object(r.b)("mtext",{parentName:"mrow"},"int")))),Object(r.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"\\text{string}^{\\text{string}\\times\\text{int}}")))),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"1.082702em",verticalAlign:"-0.19444em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord text"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),"string")),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"msupsub"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-t"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-r"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"vlist",style:{height:"0.888262em"}}),Object(r.b)("span",Object(n.a)({parentName:"span"},{style:{top:"-3.12076em",marginRight:"0.05em"}}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"pstrut",style:{height:"2.7em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"sizing reset-size6 size3 mtight"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord mtight"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord text mtight"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord mtight"}),"string")),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mbin mtight"}),"\xd7"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord text mtight"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord mtight"}),"int")))))))))))))),". Compare this with the\nequivalent but curried function ",Object(r.b)("inlineCode",{parentName:"p"},"g"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),'let g: string => int => string = (name, points) => {\n  name ++ ": " ++ string_of_int(points) ++ "/100"\n};\nprint_string( g("Brian", 93) );\n')),Object(r.b)("p",null,"The type of ",Object(r.b)("inlineCode",{parentName:"p"},"g")," here is ",Object(r.b)("inlineCode",{parentName:"p"},"string => int => string"),"; in terms of sets, this is the\nset ",Object(r.b)("span",Object(n.a)({parentName:"p"},{className:"math math-inline"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(r.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(r.b)("semantics",{parentName:"math"},Object(r.b)("mrow",{parentName:"semantics"},Object(r.b)("mo",Object(n.a)({parentName:"mrow"},{stretchy:"false"}),"("),Object(r.b)("msup",{parentName:"mrow"},Object(r.b)("mtext",{parentName:"msup"},"string"),Object(r.b)("mtext",{parentName:"msup"},"int")),Object(r.b)("msup",{parentName:"mrow"},Object(r.b)("mo",Object(n.a)({parentName:"msup"},{stretchy:"false"}),")"),Object(r.b)("mtext",{parentName:"msup"},"string"))),Object(r.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"(\\text{string}^{\\text{int}})^{\\text{string}}")))),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"1.138262em",verticalAlign:"-0.25em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mopen"}),"("),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord text"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),"string")),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"msupsub"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-t"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-r"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"vlist",style:{height:"0.888262em"}}),Object(r.b)("span",Object(n.a)({parentName:"span"},{style:{top:"-3.12076em",marginRight:"0.05em"}}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"pstrut",style:{height:"2.7em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"sizing reset-size6 size3 mtight"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord mtight"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord text mtight"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord mtight"}),"int")))))))))),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mclose"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mclose"}),")"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"msupsub"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-t"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-r"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"vlist",style:{height:"0.830502em"}}),Object(r.b)("span",Object(n.a)({parentName:"span"},{style:{top:"-3.063em",marginRight:"0.05em"}}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"pstrut",style:{height:"2.7em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"sizing reset-size6 size3 mtight"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord mtight"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord text mtight"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord mtight"}),"string")))))))))))))),". If these types are truly equivalent,\nin the sense that every function in one corresponds to a unique function in the other,\nthen that suggests that there might be a general equivalence of the form"),Object(r.b)("div",{className:"math math-display"},Object(r.b)("span",Object(n.a)({parentName:"div"},{className:"katex-display"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(r.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(r.b)("semantics",{parentName:"math"},Object(r.b)("mrow",{parentName:"semantics"},Object(r.b)("msup",{parentName:"mrow"},Object(r.b)("mi",{parentName:"msup"},"A"),Object(r.b)("mrow",{parentName:"msup"},Object(r.b)("mi",{parentName:"mrow"},"B"),Object(r.b)("mo",{parentName:"mrow"},"\xd7"),Object(r.b)("mi",{parentName:"mrow"},"C"))),Object(r.b)("mo",{parentName:"mrow"},"\u2261"),Object(r.b)("mo",Object(n.a)({parentName:"mrow"},{stretchy:"false"}),"("),Object(r.b)("msup",{parentName:"mrow"},Object(r.b)("mi",{parentName:"msup"},"A"),Object(r.b)("mi",{parentName:"msup"},"C")),Object(r.b)("msup",{parentName:"mrow"},Object(r.b)("mo",Object(n.a)({parentName:"msup"},{stretchy:"false"}),")"),Object(r.b)("mi",{parentName:"msup"},"B"))),Object(r.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"A^{B\\times C}\\equiv(A^C)^B")))),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.891331em",verticalAlign:"0em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault"}),"A"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"msupsub"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-t"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-r"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"vlist",style:{height:"0.891331em"}}),Object(r.b)("span",Object(n.a)({parentName:"span"},{style:{top:"-3.113em",marginRight:"0.05em"}}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"pstrut",style:{height:"2.7em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"sizing reset-size6 size3 mtight"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord mtight"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault mtight",style:{marginRight:"0.05017em"}}),"B"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mbin mtight"}),"\xd7"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault mtight",style:{marginRight:"0.07153em"}}),"C"))))))))),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2777777777777778em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mrel"}),"\u2261"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2777777777777778em"}}))),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"1.1413309999999999em",verticalAlign:"-0.25em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mopen"}),"("),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault"}),"A"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"msupsub"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-t"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-r"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"vlist",style:{height:"0.8913309999999999em"}}),Object(r.b)("span",Object(n.a)({parentName:"span"},{style:{top:"-3.113em",marginRight:"0.05em"}}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"pstrut",style:{height:"2.7em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"sizing reset-size6 size3 mtight"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault mtight",style:{marginRight:"0.07153em"}}),"C")))))))),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mclose"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mclose"}),")"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"msupsub"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-t"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-r"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"vlist",style:{height:"0.8913309999999999em"}}),Object(r.b)("span",Object(n.a)({parentName:"span"},{style:{top:"-3.113em",marginRight:"0.05em"}}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"pstrut",style:{height:"2.7em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"sizing reset-size6 size3 mtight"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault mtight",style:{marginRight:"0.05017em"}}),"B"))))))))))))),Object(r.b)("p",null,"This is indeed true (and it should remind you of a corresponding fact about exponents from\nordinary algebra), and we can write the functions in ReasonML that mediate this\nequivalence:"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"let curry = (f: (('b, 'c)) => 'a) => {\n  (b: 'b) => (c: 'c) => f((b, c))\n};\nlet uncurry = (g: 'b => 'c => 'a) => {\n  ((b, c): ('b, 'c)) => g(b)(c)\n};\n")),Object(r.b)("p",null,"That is, given any function from the pair type ",Object(r.b)("inlineCode",{parentName:"p"},"('b, 'c)")," to ",Object(r.b)("inlineCode",{parentName:"p"},"'a")," (type variables in\nReasonML always start with an apostrophe (",Object(r.b)("inlineCode",{parentName:"p"},"'"),")), we can apply the ",Object(r.b)("inlineCode",{parentName:"p"},"curry")," function to\nit to get the corresponding curried function of type ",Object(r.b)("inlineCode",{parentName:"p"},"'b => 'c => 'a"),". The ",Object(r.b)("inlineCode",{parentName:"p"},"uncurry"),"\nfunction is the inverse of this. Since we have functions going each direction that\nare inverses to each other, this shows that the two types (or sets) are equivalent."),Object(r.b)("h2",{id:"type-aliases-and-parameterized-types"},"Type Aliases and Parameterized Types"),Object(r.b)("p",null,"Given the importance of types, and potentially complicated type expressions, in\nReasonML, it should not be a surprise that they can be named and manipulated\nmuch like ordinary values with variables and functions.",Object(r.b)("sup",Object(n.a)({parentName:"p"},{id:"fnref-4"}),Object(r.b)("a",Object(n.a)({parentName:"sup"},{href:"#fn-4",className:"footnote-ref"}),"4"))," We give a name to a type with the ",Object(r.b)("inlineCode",{parentName:"p"},"type")," statement:"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"type int_point = (int, int);\ntype math_op = float => float => float;\nlet p: int_point = (5, 10);\nlet plus: math_op = (+.);\n")),Object(r.b)("p",null,"If we have a family of types where one or more parts can be substituted with an\narbitrary type, then we can introduce a ",Object(r.b)("strong",{parentName:"p"},"parameterized type alias")," by adding\ntype parameters. As we saw above, type variables start with an apostrophe:"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"type point('a) = ('a, 'a);\ntype binary_op('operand, 'result) = 'operand => 'operand => 'result;\ntype printer('t) = 't => unit;\nlet p1: point(int) = (5, 10);\nlet p2: point(float) = (5.0, 10.0);\nlet int_plus: binary_op(int, int) = (+);\nlet string_eq: binary_op(string, bool) = (==);\nlet print_point: printer(point(int)) = ((x, y)) => {\n  Printf.printf(\"(%d, %d)\", x, y)\n};\nprint_point(p1);\n")),Object(r.b)("div",{className:"admonition admonition-warning"},Object(r.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(r.b)("h5",{parentName:"div"},Object(r.b)("div",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(r.b)("svg",Object(n.a)({parentName:"div"},{xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"}),Object(r.b)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"})))),"warning")),Object(r.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(r.b)("p",{parentName:"div"},"Once again, OCaml displays parameterized types slightly differently. Instead of\n",Object(r.b)("inlineCode",{parentName:"p"},"point('a)")," and ",Object(r.b)("inlineCode",{parentName:"p"},"binary_op('a, 'b)"),", the name of the type comes after: ",Object(r.b)("inlineCode",{parentName:"p"},"'a point"),"\nand ",Object(r.b)("inlineCode",{parentName:"p"},"('a, 'b) binary_op"),"."))),Object(r.b)("h2",{id:"constructors-and-variants"},"Constructors and Variants"),Object(r.b)("p",null,"A tuple is a rather generic way of packaging up data. When you are building a larger\nprogram, it would not be very meaningful to see a value like ",Object(r.b)("inlineCode",{parentName:"p"},'("Brian", 93)')," out of\ncontext. Just as programmers are encouraged to use symbolic names for constants (for\nexample, ",Object(r.b)("inlineCode",{parentName:"p"},"LINE_WIDTH")," instead of 80), we can attach names to particular uses of tuples\nto make them more readable and maintainable. If we create a type alias where the\nright-hand-side prefixes the tuple with a ",Object(r.b)("strong",{parentName:"p"},"constructor")," name (which needs to start\nwith a capital letter in ReasonML), then it will introduce a new type of tuples that\nneed to be labeled with that constructor:"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),'type grade_entry = Entry(string, int);\nlet entry = Entry("Brian", 93);\n')),Object(r.b)("p",null,"If we want to extract the components of this new type, we use a corresponding\nnamed pattern in the ",Object(r.b)("inlineCode",{parentName:"p"},"let")," binding:"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"let Entry(name, grade) = entry;\n")),Object(r.b)("p",null,"Here is another version of the ",Object(r.b)("inlineCode",{parentName:"p"},"format_grade")," example, using the above ",Object(r.b)("inlineCode",{parentName:"p"},"grade_entry"),"\ntype plus another that describes a particular grading item (with a title and maximum\nnumber of points). Even though both are essentially a pair of a string and an integer,\nwe can now tell them apart:"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),'type grade_entry = Entry(string, int);\ntype grading_item = Item(string, int);\nlet format_grade = (item, entry) => {\n  let Item(title, max) = item;\n  let Entry(name, grade) = entry;\n  name ++ ", " ++ title ++ ": " ++ string_of_int(grade) ++ "/" ++ string_of_int(max)\n};\nlet demo = format_grade(Item("Midterm", 100), Entry("Brian", 93));\n')),Object(r.b)("p",null,"So far we have seen types where all of the data have the same form: the same number\nof components, each with the same set of types, across all values of the type. However,\nmost interesting data will come in several forms, and our programs will need to make\nappropriate decisions based on the form of each piece of data."),Object(r.b)("h3",{id:"pattern-matching"},"Pattern Matching"),Object(r.b)("h3",{id:"recursive-types"},"Recursive Types"),Object(r.b)("h2",{id:"connection-to-natural-deduction"},"Connection to Natural Deduction"),Object(r.b)("h2",{id:"exercises"},"Exercises"),Object(r.b)("p",null,"TODO: another page on common patterns of recursion: map, reduce, fold, accumulator,\nauxilliary function, tail-recursion, mutual recursion. A page on functional graphics.\nA summary page on ReasonML."),Object(r.b)("div",{className:"footnotes"},Object(r.b)("hr",{parentName:"div"}),Object(r.b)("ol",{parentName:"div"},Object(r.b)("li",Object(n.a)({parentName:"ol"},{id:"fn-1"}),"ReasonML, unlike many common languages,\ndistinguishes between the integer addition operator, written ",Object(r.b)("inlineCode",{parentName:"li"},"+"),", and the\nfloating-point addition operator, which is written ",Object(r.b)("inlineCode",{parentName:"li"},"+."),". In part this is done to\nmake type inference easier.",Object(r.b)("a",Object(n.a)({parentName:"li"},{href:"#fnref-1",className:"footnote-backref"}),"\u21a9")),Object(r.b)("li",Object(n.a)({parentName:"ol"},{id:"fn-2"}),'As\nis often the case when things are named, Curry did not originate this idea. He got it\nfrom Moses Sch\xf6nfinkel, who may have picked it up from Gottlob Frege, but "currying"\nis easier to say than "sch\xf6nfinkeling" or "fregeing"',"\u2026",".",Object(r.b)("a",Object(n.a)({parentName:"li"},{href:"#fnref-2",className:"footnote-backref"}),"\u21a9")),Object(r.b)("li",Object(n.a)({parentName:"ol"},{id:"fn-3"}),"Part of the reason for this is simply tradition, but another\nimportant factor is that ReasonML does not have an easy way to give a type for a\nfunction that would take an ",Object(r.b)("span",Object(n.a)({parentName:"li"},{className:"math math-inline"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(r.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(r.b)("semantics",{parentName:"math"},Object(r.b)("mrow",{parentName:"semantics"},Object(r.b)("mi",{parentName:"mrow"},"n")),Object(r.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"n")))),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault"}),"n"))))),"-tuple plus an integer, say from 1 to ",Object(r.b)("span",Object(n.a)({parentName:"li"},{className:"math math-inline"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(r.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(r.b)("semantics",{parentName:"math"},Object(r.b)("mrow",{parentName:"semantics"},Object(r.b)("mi",{parentName:"mrow"},"n")),Object(r.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"n")))),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault"}),"n"))))),", and\nreturn that component of the tuple; since each component may have a different\ntype, what would the return type of that accessor be?",Object(r.b)("a",Object(n.a)({parentName:"li"},{href:"#fnref-3",className:"footnote-backref"}),"\u21a9")),Object(r.b)("li",Object(n.a)({parentName:"ol"},{id:"fn-4"}),"ReasonML does not go\nquite all the way with making types be first-class values. There is currently\nactive work on creating industrial-strength languages with so-called ",Object(r.b)("strong",{parentName:"li"},"dependent\ntypes"),", where types are values and values can be used in types. Good examples are\nAgda (",Object(r.b)("a",Object(n.a)({parentName:"li"},{href:"https://github.com/agda/agda"}),"https://github.com/agda/agda"),"), Idris (",Object(r.b)("a",Object(n.a)({parentName:"li"},{href:"https://www.idris-lang.org/"}),"https://www.idris-lang.org/"),"), and Lean\n(",Object(r.b)("a",Object(n.a)({parentName:"li"},{href:"https://leanprover.github.io/"}),"https://leanprover.github.io/"),").",Object(r.b)("a",Object(n.a)({parentName:"li"},{href:"#fnref-4",className:"footnote-backref"}),"\u21a9")))))}o.isMDXComponent=!0},158:function(e,t,a){"use strict";var n=a(0),s=a(32);t.a=function(){return Object(n.useContext)(s.a)}},159:function(e,t,a){"use strict";a.d(t,"a",(function(){return o})),a.d(t,"b",(function(){return d}));var n=a(0),s=a.n(n);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function c(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function p(e,t){if(null==e)return{};var a,n,s=function(e,t){if(null==e)return{};var a,n,s={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(s[a]=e[a]);return s}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(s[a]=e[a])}return s}var b=s.a.createContext({}),m=function(e){var t=s.a.useContext(b),a=t;return e&&(a="function"==typeof e?e(t):c({},t,{},e)),a},o=function(e){var t=m(e.components);return s.a.createElement(b.Provider,{value:t},e.children)},l="mdxType",O={inlineCode:"code",wrapper:function(e){var t=e.children;return s.a.createElement(s.a.Fragment,{},t)}},j=Object(n.forwardRef)((function(e,t){var a=e.components,n=e.mdxType,r=e.originalType,i=e.parentName,b=p(e,["components","mdxType","originalType","parentName"]),o=m(a),l=n,j=o["".concat(i,".").concat(l)]||o[l]||O[l]||r;return a?s.a.createElement(j,c({ref:t},b,{components:a})):s.a.createElement(j,c({ref:t},b))}));function d(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var r=a.length,i=new Array(r);i[0]=j;var c={};for(var p in t)hasOwnProperty.call(t,p)&&(c[p]=t[p]);c.originalType=e,c[l]="string"==typeof e?e:n,i[1]=c;for(var b=2;b<r;b++)i[b]=a[b];return s.a.createElement.apply(null,i)}return s.a.createElement.apply(null,a)}j.displayName="MDXCreateElement"},160:function(e,t,a){"use strict";a.d(t,"a",(function(){return s}));var n=a(158);function s(e){const{siteConfig:t}=Object(n.a)(),{baseUrl:a="/"}=t||{};if(!e)return e;return/^(https?:|\/\/)/.test(e)?e:e.startsWith("/")?a+e.slice(1):a+e}}}]);