(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{137:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return o})),t.d(n,"metadata",(function(){return i})),t.d(n,"rightToc",(function(){return d})),t.d(n,"default",(function(){return s}));var a=t(1),l=t(6),r=(t(0),t(219)),o={id:"scaladoodle",title:"Scala Doodle"},i={id:"fp/scaladoodle",title:"Scala Doodle",description:"This is the code for the DePauw Scala version of the Doodle library (as used on [scalafiddle.io](https://scalafiddle.io/sf/gDzN6Mw/37)):",source:"@site/docs/fp/scaladoodle.md",permalink:"/focsipedia/docs/fp/scaladoodle",editUrl:"https://github.com/bhoward/focsipedia/edit/master/docs/fp/scaladoodle.md"},d=[],u={rightToc:d};function s(e){var n=e.components,t=Object(l.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},u,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("p",null,"This is the code for the DePauw Scala version of the Doodle library (as used on ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://scalafiddle.io/sf/gDzN6Mw/37"}),"scalafiddle.io"),"):"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),'import fiddle.Fiddle, Fiddle.println\nimport scalajs.js\n\n@js.annotation.JSExportTopLevel("ScalaFiddle")\nobject ScalaFiddle {\n  import org.scalajs.dom.CanvasRenderingContext2D\n  \n  sealed trait Image {\n    def left: Double\n    def right: Double\n    def top: Double\n    def bottom: Double\n    def width: Double = right - left\n    def height: Double = bottom - top\n    def render: Unit\n    def draw: Unit = Translate(this, 10-left, 10-top).lineColor(Color.black).fillColor(Color.transparent).render\n    \n    def beside(that: Image): Image = Beside(this, that)\n    def above(that: Image): Image = Above(this, that)\n    def below(that: Image): Image = Above(that, this)\n    def on(that: Image): Image = Layer(that, this)\n    def under(that: Image): Image = Layer(this, that)\n    \n    def fillColor(c: Pattern): Image = Styled(this, FillColor(c))\n    def lineColor(c: Pattern): Image = Styled(this, LineColor(c))\n    def lineWidth(w: Double): Image = Styled(this, LineWidth(w))\n    def color(c: Pattern): Image = Styled(Styled(this, FillColor(c)), LineColor(c))\n    def font(value: String): Image = Styled(this, Font(value))\n    def dashed: Image = Styled(this, Dashed)\n    \n    def bounds(left: Double, right: Double, top: Double, bottom: Double): Image = Bounds(this, left, right, top, bottom)\n    def resize(w: Double, h: Double): Image = Bounds(this, -w/2, w/2, -h/2, h/2)\n    def recenter: Image = Translate(this, -(left + right)/2, -(top + bottom)/2)\n    \n    def showBounds: Image = this under (\n      Rectangle(width, height).translate(left + width/2, top + height/2) under\n      Circle(10) under\n      Path(List(MoveTo(Point(-20, 0)), LineTo(Point(20, 0))), false) under\n      Path(List(MoveTo(Point(0, -20)), LineTo(Point(0, 20))), false)\n    ).lineColor(Color.black).dashed.resize(0, 0)\n    \n    def translate(x: Double, y: Double): Image = Translate(this, x, y)\n    def at(x: Double, y: Double): Image = Translate(this, x, y)\n    def at(p: Point): Image = Translate(this, p.x, p.y)\n    def at(v: Vec): Image = Translate(this, v.x, v.y)\n    \n    def rotate(angle: Angle): Image = Rotate(this, angle)\n    def scale(factor: Double): Image = Scale(this, factor, factor)\n    def scale(xfactor: Double, yfactor: Double): Image = Scale(this, xfactor, yfactor)\n    \n    def byTopLeft: Image = Translate(this, -left, -top)\n    def byBottomLeft: Image = Translate(this, -left, -bottom)\n    def byTopRight: Image = Translate(this, -right, -top)\n    def byBottomRight: Image = Translate(this, -right, -bottom)\n    def byTop: Image = Translate(this, 0, -top)\n    def byBottom: Image = Translate(this, 0, -bottom)\n    def byLeft: Image = Translate(this, -left, 0)\n    def byRight: Image = Translate(this, -right, 0)\n    \n    def topLeft: Point = Point(left, top)\n    def bottomLeft: Point = Point(left, bottom)\n    def topRight: Point = Point(right, top)\n    def bottomRight: Point = Point(right, bottom)\n  }\n  \n  object Image {\n    def circle(radius: Double): Image = Circle(radius)\n    def rectangle(width: Double, height: Double): Image = Rectangle(width, height)\n    def triangle(width: Double, height: Double): Image = Triangle(width, height)\n    def ellipse(width: Double, height: Double): Image = Ellipse(width, height)\n    def openPath(path: List[PathElement]): Image = Path(path, false)\n    def closedPath(path: List[PathElement]): Image = Path(path, true)\n    def text(string: String): Image = Text(string)\n    def empty: Image = Rectangle(0, 0)\n  }\n  \n  import Image._\n\n  final case class Rectangle(w: Double, h: Double) extends Image {\n    val left = -w/2\n    val right = w/2\n    val top = -h/2\n    val bottom = h/2\n    def render: Unit = {\n      val d = Fiddle.draw\n      d.fillRect(left, top, width, height)\n      d.strokeRect(left, top, width, height)\n    }\n  }\n  \n  final case class Triangle(w: Double, h: Double) extends Image {\n    val left = -w/2\n    val right = w/2\n    val top = -h/2\n    val bottom = h/2\n    def render: Unit = {\n      val d = Fiddle.draw\n      d.beginPath()\n      d.moveTo(left, bottom)\n      d.lineTo(0, top)\n      d.lineTo(right, bottom)\n      d.closePath()\n      d.fill()\n      d.stroke()\n    }\n  }\n  \n  final case class Circle(r: Double) extends Image {\n    val left = -r\n    val right = r\n    val top = -r\n    val bottom = r\n    def render: Unit = {\n      val d = Fiddle.draw\n      d.beginPath()\n      d.arc(0, 0, r, 0, 2 * math.Pi)\n      d.closePath()\n      d.fill()\n      d.stroke()\n    }\n  }\n  \n  final case class Ellipse(w: Double, h: Double) extends Image {\n    val left = -w/2\n    val right = w/2\n    val top = -h/2\n    val bottom = h/2\n    def render: Unit = {\n      val d = Fiddle.draw\n      d.save()\n      d.scale(1.0, h / w)\n      d.beginPath()\n      d.arc(0, 0, w/2, 0, 2 * math.Pi)\n      d.closePath()\n      d.fill()\n      d.stroke()\n      d.restore()\n    }\n  }\n  \n  final case class Path(path: List[PathElement], closed: Boolean) extends Image {\n    val points = path.map(_.p)\n    val xs = points.map(_.x)\n    val ys = points.map(_.y)\n    val left = xs.min min 0\n    val right = xs.max max 0\n    val top = ys.min min 0\n    val bottom = ys.max max 0\n    def render: Unit = {\n      val d = Fiddle.draw\n      d.beginPath()\n      d.moveTo(0, 0)\n      path.foreach(_.trace(d))\n      if (closed) d.closePath()\n      d.fill()\n      d.stroke()\n    }\n  }\n\n  final case class Text(string: String) extends Image {\n    val left = 0\n    val right = 0\n    val top = 0\n    val bottom = 0\n    def render: Unit = {\n      val d = Fiddle.draw\n      d.textAlign = "center"\n      d.textBaseline = "middle"\n      d.fillText(string, 0, 0)\n      d.strokeText(string, 0, 0)\n    }\n  }\n\n  final case class Beside(l: Image, r: Image) extends Image {\n    override val width = l.width + r.width\n    val left = -width/2\n    val right = width/2\n    val top = l.top min r.top\n    val bottom = l.bottom max r.bottom\n    def render: Unit = {\n      val d = Fiddle.draw\n      d.save()\n      d.translate(left - l.left, 0)\n      l.render\n      d.translate(l.right - r.left, 0)\n      r.render\n      d.restore()\n    }\n  }\n  \n  final case class Above(t: Image, b: Image) extends Image {\n    override val height = t.height + b.height\n    val left = t.left min b.left\n    val right = t.right max b.right\n    val top = -height/2\n    val bottom = height/2\n    def render: Unit = {\n      val d = Fiddle.draw\n      d.save()\n      d.translate(0, top - t.top)\n      t.render\n      d.translate(0, t.bottom - b.top)\n      b.render\n      d.restore()\n    }\n  }\n  \n  final case class Layer(layers: Image*) extends Image {\n    val left = layers.map(_.left).min\n    val right = layers.map(_.right).max\n    val top = layers.map(_.top).min\n    val bottom = layers.map(_.bottom).max\n    def render: Unit = {\n      val d = Fiddle.draw\n      for (layer <- layers) layer.render\n    }\n  }\n  \n  final case class Styled(image: Image, style: Style) extends Image {\n    val left = image.left\n    val right = image.right\n    val top = image.top\n    val bottom = image.bottom\n    def render: Unit = {\n      val d = Fiddle.draw\n      d.save()\n      style(d)\n      image.render\n      d.restore()\n    }\n  }\n  \n  final case class Translate(image: Image, x: Double, y: Double) extends Image {\n    val left = image.left + x\n    val right = image.right + x\n    val top = image.top + y\n    val bottom = image.bottom + y\n    def render: Unit = {\n      val d = Fiddle.draw\n      d.save()\n      d.translate(x, y)\n      image.render\n      d.restore()\n    }\n  }\n  \n  final case class Rotate(image: Image, angle: Angle) extends Image {\n    val points = List(image.topLeft, image.topRight, image.bottomLeft, image.bottomRight).map(_.rotate(angle))\n    val xs = points.map(_.x)\n    val ys = points.map(_.y)\n    val left = xs.min\n    val right = xs.max\n    val top = ys.min\n    val bottom = ys.max\n    def render: Unit = {\n      val d = Fiddle.draw\n      d.save()\n      d.rotate(angle.toRadians)\n      image.render\n      d.restore()\n    }\n  }\n  \n  final case class Scale(image: Image, xfactor: Double, yfactor: Double) extends Image {\n    val left = image.left * xfactor min image.right * xfactor\n    val right = image.left * xfactor max image.right * xfactor\n    val top = image.top * yfactor min image.bottom * yfactor\n    val bottom = image.top * yfactor max image.bottom * yfactor\n    def render: Unit = {\n      val d = Fiddle.draw\n      d.save()\n      d.scale(xfactor, yfactor)\n      image.render\n      d.restore()\n    }\n  }\n  \n  final case class Bounds(image: Image, left: Double, right: Double, top: Double, bottom: Double) extends Image {\n    def render: Unit = image.render\n  }\n  \n  sealed trait Style {\n    def apply(d: CanvasRenderingContext2D): Unit\n  }\n  \n  final case class LineWidth(w: Double) extends Style {\n    def apply(d: CanvasRenderingContext2D): Unit = {\n      d.lineWidth = w\n    }\n  }\n  \n  final case class LineColor(c: Pattern) extends Style {\n    def apply(d: CanvasRenderingContext2D): Unit = {\n      d.strokeStyle = c.value\n    }\n  }\n  \n  final case class FillColor(c: Pattern) extends Style {\n    def apply(d: CanvasRenderingContext2D): Unit = {\n      d.fillStyle = c.value\n    }\n  }\n  \n  final case object Dashed extends Style {\n    def apply(d: CanvasRenderingContext2D): Unit = {\n      d.setLineDash(scala.scalajs.js.Array(4.0, 2.0))\n    }\n  }\n  \n  final case class Font(value: String) extends Style {\n    def apply(d: CanvasRenderingContext2D): Unit = {\n      d.font = value\n    }\n  }\n  \n  sealed trait Pattern {\n    def value: js.Any\n  }\n  \n  final case class LinearGradient(start: Point, end: Point, stops: Seq[(Normalized, Color)]) extends Pattern {\n    def value: js.Any = {\n      val d = Fiddle.draw\n      val gradient = d.createLinearGradient(start.x, start.y, end.x, end.y)\n      for ((pos, c) <- stops) gradient.addColorStop(pos.value, c.value.toString)\n      gradient\n    }\n  }\n  \n  final case class RadialGradient(start: Point, startRadius: Double, end: Point, endRadius: Double, stops: Seq[(Normalized, Color)]) extends Pattern {\n    def value: js.Any = {\n      val d = Fiddle.draw\n      val gradient = d.createRadialGradient(start.x, start.y, startRadius,\n        end.x, end.y, endRadius)\n      for ((pos, c) <- stops) gradient.addColorStop(pos.value, c.value.toString)\n      gradient\n    }\n  }\n  \n  object Pattern {\n    def linearGradient(start: Point, end: Point, stops: (Normalized, Color)*): Pattern =\n      LinearGradient(start, end, stops)\n    def radialGradient(start: Point, startRadius: Double,\n        end: Point, endRadius: Double, stops: (Normalized, Color)*) =\n      RadialGradient(start, startRadius, end, endRadius, stops)\n    def dichromaticVertical(color1: Color, color2: Color, length: Double): Pattern =\n      linearGradient(Point.zero, Point(0, length), (0.normalized, color1), (1.normalized, color2))\n    def dichromaticHorizontal(color1: Color, color2: Color, length: Double): Pattern =\n      linearGradient(Point.zero, Point(length, 0), (0.normalized, color1), (1.normalized, color2))\n    def dichromaticRadial(color1: Color, color2: Color, radius: Double): Pattern =\n      radialGradient(Point.zero, 0, Point.zero, radius, (0.normalized, color1), (1.normalized, color2))\n  }\n  \n  import Pattern._\n  \n  final case class Color(red: UByte, green: UByte, blue: UByte, alpha: Normalized = 1.0.normalized) extends Pattern {\n    val value: js.Any = s"rgba($red, $green, $blue, $alpha)"\n    \n    def hue: Angle = hsl._1\n    def saturation: Normalized = hsl._2\n    def lightness: Normalized = hsl._3\n    \n    def hsl: (Angle, Normalized, Normalized) = {\n      val r = red.toNormalized.value\n      val g = green.toNormalized.value\n      val b = blue.toNormalized.value\n      val cMax = r max g max b\n      val cMin = r min g min b\n      val delta = cMax - cMin\n  \n      val unnormalizedHue =\n        if(cMax == r)\n          60 * (((g - b) / delta))\n        else if(cMax == g)\n          60 * (((b - r) / delta) + 2)\n        else\n          60 * (((r - g) / delta) + 4)\n      val hue = unnormalizedHue.degrees\n  \n      val lightness = Normalized.clip((cMax + cMin) / 2)\n  \n      val saturation =\n        if(delta == 0.0)\n          0.normalized\n        else\n          Normalized.clip(delta / (1 - math.abs(2 * lightness.value - 1)))\n  \n      (hue, saturation, lightness)\n    }\n    \n    def hue(h: Angle): Color = {\n      val (_, s, l) = hsl\n      Color.hsla(h, s, l, alpha)\n    }\n  \n    def saturation(s: Normalized): Color = {\n      val (h, _, l) = hsl\n      Color.hsla(h, s, l, alpha)\n    }\n  \n    def lightness(l: Normalized): Color = {\n      val (h, s, _) = hsl\n      Color.hsla(h, s, l, alpha)\n    }\n  \n    def alpha(a: Normalized): Color =\n      Color(red, green, blue, a)\n  \n    def spin(angle: Angle) = {\n      val (h, s, l) = hsl\n      Color.hsla(h + angle, s, l, alpha)\n    }\n  \n    def lighten(lightness: Normalized) = {\n      val (h, s, l) = hsl\n      Color.hsla(h, s, Normalized.clip(l.value + lightness.value), alpha)\n    }\n  \n    def darken(darkness: Normalized) = {\n      val (h, s, l) = hsl\n      Color.hsla(h, s, Normalized.clip(l.value - darkness.value), alpha)\n    }\n  \n    def saturate(saturation: Normalized) = {\n      val (h, s, l) = hsl\n      Color.hsla(h, Normalized.clip(s.value + saturation.value), l, alpha)\n    }\n  \n    def desaturate(desaturation: Normalized) = {\n      val (h, s, l) = hsl\n      Color.hsla(h, Normalized.clip(s.value - desaturation.value), l, alpha)\n    }\n  \n    def fadeIn(opacity: Normalized) = {\n      Color(red, green, blue, Normalized.clip(alpha.value + opacity.value))\n    }\n  \n    def fadeOut(opacity: Normalized) = {\n      Color(red, green, blue, Normalized.clip(alpha.value - opacity.value))\n    }\n  \n    def lightenBy(lightness: Normalized) = {\n      val (h, s, l) = hsl\n      Color.hsla(h, s, Normalized.clip(l.value * (1 + lightness.value)), alpha)\n    }\n  \n    def darkenBy(darkness: Normalized) = {\n      val (h, s, l) = hsl\n      Color.hsla(h, s, Normalized.clip(l.value * (1 - darkness.value)), alpha)\n    }\n  \n    def saturateBy(saturation: Normalized) = {\n      val (h, s, l) = hsl\n      Color.hsla(h, Normalized.clip(s.value * (1 + saturation.value)), l, alpha)\n    }\n  \n    def desaturateBy(desaturation: Normalized) = {\n      val (h, s, l) = hsl\n      Color.hsla(h, Normalized.clip(s.value * (1 - desaturation.value)), l, alpha)\n    }\n  \n    def fadeInBy(opacity: Normalized) = {\n      Color(red, green, blue, Normalized.clip(alpha.value * (1 + opacity.value)))\n    }\n  \n    def fadeOutBy(opacity: Normalized) = {\n      Color(red, green, blue, Normalized.clip(alpha.value * (1 - opacity.value)))\n    }\n  }\n  \n  object Color {\n    def rgb(r: UByte, g: UByte, b: UByte): Color = Color(r, g, b)\n    def rgba(r: UByte, g: UByte, b: UByte, a: Normalized): Color = Color(r, g, b, a)\n    def hsl(h: Angle, s: Normalized, l: Normalized): Color = hsla(h, s, l, 1.normalized)\n    def hsla(h: Angle, s: Normalized, l: Normalized, a: Normalized): Color = {\n          if (s.value == 0.0) {\n            val lightness = l.toUnsignedByte\n            rgba(lightness, lightness, lightness, a)\n          } else {\n            def hueToRgb(p: Double, q: Double, t: Normalized): Normalized =\n              Normalized.wrap(\n                if (t.value < 1.0/6.0) p + (q - p) * 6 * t.value\n                else if (t.value < 0.5) q\n                else if (t.value < 2.0/3.0) p + (q - p) * 6 * (2.0/3.0 - t.value)\n                else p)\n  \n            val lightness = l.value\n            val saturation = s.value\n            val q =\n              if (lightness < 0.5) lightness * (1 + saturation)\n              else lightness + saturation - lightness * saturation\n            val p = 2 * lightness - q\n            val r = hueToRgb(p, q, Normalized.wrap((h + 120.degrees).toTurns))\n            val g = hueToRgb(p, q, Normalized.wrap(h.toTurns))\n            val b = hueToRgb(p, q, Normalized.wrap((h - 120.degrees).toTurns))\n  \n            rgba(r.toUnsignedByte, g.toUnsignedByte, b.toUnsignedByte, a)\n          }\n    }\n    \n    val transparent          = rgba(0x00.uByte, 0x00.uByte, 0x00.uByte, 0.normalized)\n    val aliceBlue            = rgb(0xf0.uByte, 0xf8.uByte, 0xff.uByte)\n    val antiqueWhite         = rgb(0xfa.uByte, 0xeb.uByte, 0xd7.uByte)\n    val aqua                 = rgb(0x00.uByte, 0xff.uByte, 0xff.uByte)\n    val aquamarine           = rgb(0x7f.uByte, 0xff.uByte, 0xd4.uByte)\n    val azure                = rgb(0xf0.uByte, 0xff.uByte, 0xff.uByte)\n    val beige                = rgb(0xf5.uByte, 0xf5.uByte, 0xdc.uByte)\n    val bisque               = rgb(0xff.uByte, 0xe4.uByte, 0xc4.uByte)\n    val black                = rgb(0x00.uByte, 0x00.uByte, 0x00.uByte)\n    val blanchedAlmond       = rgb(0xff.uByte, 0xeb.uByte, 0xcd.uByte)\n    val blue                 = rgb(0x00.uByte, 0x00.uByte, 0xff.uByte)\n    val blueViolet           = rgb(0x8a.uByte, 0x2b.uByte, 0xe2.uByte)\n    val brown                = rgb(0xa5.uByte, 0x2a.uByte, 0x2a.uByte)\n    val burlyWood            = rgb(0xde.uByte, 0xb8.uByte, 0x87.uByte)\n    val cadetBlue            = rgb(0x5f.uByte, 0x9e.uByte, 0xa0.uByte)\n    val chartreuse           = rgb(0x7f.uByte, 0xff.uByte, 0x00.uByte)\n    val chocolate            = rgb(0xd2.uByte, 0x69.uByte, 0x1e.uByte)\n    val coral                = rgb(0xff.uByte, 0x7f.uByte, 0x50.uByte)\n    val cornflowerBlue       = rgb(0x64.uByte, 0x95.uByte, 0xed.uByte)\n    val cornSilk             = rgb(0xff.uByte, 0xf8.uByte, 0xdc.uByte)\n    val crimson              = rgb(0xdc.uByte, 0x14.uByte, 0x3c.uByte)\n    val cyan                 = rgb(0x00.uByte, 0xff.uByte, 0xff.uByte)\n    val darkBlue             = rgb(0x00.uByte, 0x00.uByte, 0x8b.uByte)\n    val darkCyan             = rgb(0x00.uByte, 0x8b.uByte, 0x8b.uByte)\n    val darkGoldenrod        = rgb(0xb8.uByte, 0x86.uByte, 0x0b.uByte)\n    val darkGray             = rgb(0xa9.uByte, 0xa9.uByte, 0xa9.uByte)\n    val darkGrey             = rgb(0xa9.uByte, 0xa9.uByte, 0xa9.uByte)\n    val darkGreen            = rgb(0x00.uByte, 0x64.uByte, 0x00.uByte)\n    val darkKhaki            = rgb(0xbd.uByte, 0xb7.uByte, 0x6b.uByte)\n    val darkMagenta          = rgb(0x8b.uByte, 0x00.uByte, 0x8b.uByte)\n    val darkOliveGreen       = rgb(0x55.uByte, 0x6b.uByte, 0x2f.uByte)\n    val darkOrange           = rgb(0xff.uByte, 0x8c.uByte, 0x00.uByte)\n    val darkOrchid           = rgb(0x99.uByte, 0x32.uByte, 0xcc.uByte)\n    val darkRed              = rgb(0x8b.uByte, 0x00.uByte, 0x00.uByte)\n    val darkSalmon           = rgb(0xe9.uByte, 0x96.uByte, 0x7a.uByte)\n    val darkSeaGreen         = rgb(0x8f.uByte, 0xbc.uByte, 0x8f.uByte)\n    val darkSlateBlue        = rgb(0x48.uByte, 0x3d.uByte, 0x8b.uByte)\n    val darkSlateGray        = rgb(0x2f.uByte, 0x4f.uByte, 0x4f.uByte)\n    val darkSlateGrey        = rgb(0x2f.uByte, 0x4f.uByte, 0x4f.uByte)\n    val darkTurquoise        = rgb(0x00.uByte, 0xce.uByte, 0xd1.uByte)\n    val darkViolet           = rgb(0x94.uByte, 0x00.uByte, 0xd3.uByte)\n    val deepPink             = rgb(0xff.uByte, 0x14.uByte, 0x93.uByte)\n    val deepSkyBlue          = rgb(0x00.uByte, 0xbf.uByte, 0xff.uByte)\n    val dimGray              = rgb(0x69.uByte, 0x69.uByte, 0x69.uByte)\n    val dimGrey              = rgb(0x69.uByte, 0x69.uByte, 0x69.uByte)\n    val dodgerBlue           = rgb(0x1e.uByte, 0x90.uByte, 0xff.uByte)\n    val fireBrick            = rgb(0xb2.uByte, 0x22.uByte, 0x22.uByte)\n    val floralWhite          = rgb(0xff.uByte, 0xfa.uByte, 0xf0.uByte)\n    val forestGreen          = rgb(0x22.uByte, 0x8b.uByte, 0x22.uByte)\n    val fuchsia              = rgb(0xff.uByte, 0x00.uByte, 0xff.uByte)\n    val gainsboro            = rgb(0xdc.uByte, 0xdc.uByte, 0xdc.uByte)\n    val ghostWhite           = rgb(0xf8.uByte, 0xf8.uByte, 0xff.uByte)\n    val gold                 = rgb(0xff.uByte, 0xd7.uByte, 0x00.uByte)\n    val goldenrod            = rgb(0xda.uByte, 0xa5.uByte, 0x20.uByte)\n    val gray                 = rgb(0x80.uByte, 0x80.uByte, 0x80.uByte)\n    val grey                 = rgb(0x80.uByte, 0x80.uByte, 0x80.uByte)\n    val green                = rgb(0x00.uByte, 0x80.uByte, 0x00.uByte)\n    val greenYellow          = rgb(0xad.uByte, 0xff.uByte, 0x2f.uByte)\n    val honeydew             = rgb(0xf0.uByte, 0xff.uByte, 0xf0.uByte)\n    val hotpink              = rgb(0xff.uByte, 0x69.uByte, 0xb4.uByte)\n    val indianRed            = rgb(0xcd.uByte, 0x5c.uByte, 0x5c.uByte)\n    val indigo               = rgb(0x4b.uByte, 0x00.uByte, 0x82.uByte)\n    val ivory                = rgb(0xff.uByte, 0xff.uByte, 0xf0.uByte)\n    val khaki                = rgb(0xf0.uByte, 0xe6.uByte, 0x8c.uByte)\n    val lavender             = rgb(0xe6.uByte, 0xe6.uByte, 0xfa.uByte)\n    val lavenderBlush        = rgb(0xff.uByte, 0xf0.uByte, 0xf5.uByte)\n    val lawngreen            = rgb(0x7c.uByte, 0xfc.uByte, 0x00.uByte)\n    val lemonChiffon         = rgb(0xff.uByte, 0xfa.uByte, 0xcd.uByte)\n    val lightBlue            = rgb(0xad.uByte, 0xd8.uByte, 0xe6.uByte)\n    val lightCoral           = rgb(0xf0.uByte, 0x80.uByte, 0x80.uByte)\n    val lightCyan            = rgb(0xe0.uByte, 0xff.uByte, 0xff.uByte)\n    val lightGoldenrodYellow = rgb(0xfa.uByte, 0xfa.uByte, 0xd2.uByte)\n    val lightGray            = rgb(0xd3.uByte, 0xd3.uByte, 0xd3.uByte)\n    val lightGrey            = rgb(0xd3.uByte, 0xd3.uByte, 0xd3.uByte)\n    val lightGreen           = rgb(0x90.uByte, 0xee.uByte, 0x90.uByte)\n    val lightPink            = rgb(0xff.uByte, 0xb6.uByte, 0xc1.uByte)\n    val lightSalmon          = rgb(0xff.uByte, 0xa0.uByte, 0x7a.uByte)\n    val lightSeaGreen        = rgb(0x20.uByte, 0xb2.uByte, 0xaa.uByte)\n    val lightSkyBlue         = rgb(0x87.uByte, 0xce.uByte, 0xfa.uByte)\n    val lightSlateGray       = rgb(0x77.uByte, 0x88.uByte, 0x99.uByte)\n    val lightSlateGrey       = rgb(0x77.uByte, 0x88.uByte, 0x99.uByte)\n    val lightSteelBlue       = rgb(0xb0.uByte, 0xc4.uByte, 0xde.uByte)\n    val lightYellow          = rgb(0xff.uByte, 0xff.uByte, 0xe0.uByte)\n    val lime                 = rgb(0x00.uByte, 0xff.uByte, 0x00.uByte)\n    val limeGreen            = rgb(0x32.uByte, 0xcd.uByte, 0x32.uByte)\n    val linen                = rgb(0xfa.uByte, 0xf0.uByte, 0xe6.uByte)\n    val magenta              = rgb(0xff.uByte, 0x00.uByte, 0xff.uByte)\n    val maroon               = rgb(0x80.uByte, 0x00.uByte, 0x00.uByte)\n    val mediumAquamarine     = rgb(0x66.uByte, 0xcd.uByte, 0xaa.uByte)\n    val mediumBlue           = rgb(0x00.uByte, 0x00.uByte, 0xcd.uByte)\n    val mediumOrchid         = rgb(0xba.uByte, 0x55.uByte, 0xd3.uByte)\n    val mediumPurple         = rgb(0x93.uByte, 0x70.uByte, 0xd8.uByte)\n    val mediumSeaGreen       = rgb(0x3c.uByte, 0xb3.uByte, 0x71.uByte)\n    val mediumSlateBlue      = rgb(0x7b.uByte, 0x68.uByte, 0xee.uByte)\n    val mediumSpringGreen    = rgb(0x00.uByte, 0xfa.uByte, 0x9a.uByte)\n    val mediumTurquoise      = rgb(0x48.uByte, 0xd1.uByte, 0xcc.uByte)\n    val mediumVioletRed      = rgb(0xc7.uByte, 0x15.uByte, 0x85.uByte)\n    val midnightBlue         = rgb(0x19.uByte, 0x19.uByte, 0x70.uByte)\n    val mintCream            = rgb(0xf5.uByte, 0xff.uByte, 0xfa.uByte)\n    val mistyRose            = rgb(0xff.uByte, 0xe4.uByte, 0xe1.uByte)\n    val moccasin             = rgb(0xff.uByte, 0xe4.uByte, 0xb5.uByte)\n    val navajoWhite          = rgb(0xff.uByte, 0xde.uByte, 0xad.uByte)\n    val navy                 = rgb(0x00.uByte, 0x00.uByte, 0x80.uByte)\n    val oldLace              = rgb(0xfd.uByte, 0xf5.uByte, 0xe6.uByte)\n    val olive                = rgb(0x80.uByte, 0x80.uByte, 0x00.uByte)\n    val oliveDrab            = rgb(0x6b.uByte, 0x8e.uByte, 0x23.uByte)\n    val orange               = rgb(0xff.uByte, 0xa5.uByte, 0x00.uByte)\n    val orangeRed            = rgb(0xff.uByte, 0x45.uByte, 0x00.uByte)\n    val orchid               = rgb(0xda.uByte, 0x70.uByte, 0xd6.uByte)\n    val paleGoldenrod        = rgb(0xee.uByte, 0xe8.uByte, 0xaa.uByte)\n    val paleGreen            = rgb(0x98.uByte, 0xfb.uByte, 0x98.uByte)\n    val paleTurquoise        = rgb(0xaf.uByte, 0xee.uByte, 0xee.uByte)\n    val paleVioletRed        = rgb(0xd8.uByte, 0x70.uByte, 0x93.uByte)\n    val papayaWhip           = rgb(0xff.uByte, 0xef.uByte, 0xd5.uByte)\n    val peachPuff            = rgb(0xff.uByte, 0xda.uByte, 0xb9.uByte)\n    val peru                 = rgb(0xcd.uByte, 0x85.uByte, 0x3f.uByte)\n    val pink                 = rgb(0xff.uByte, 0xc0.uByte, 0xcb.uByte)\n    val plum                 = rgb(0xdd.uByte, 0xa0.uByte, 0xdd.uByte)\n    val powderBlue           = rgb(0xb0.uByte, 0xe0.uByte, 0xe6.uByte)\n    val purple               = rgb(0x80.uByte, 0x00.uByte, 0x80.uByte)\n    val rebeccaPurple        = rgb(0x66.uByte, 0x33.uByte, 0x99.uByte)\n    val red                  = rgb(0xff.uByte, 0x00.uByte, 0x00.uByte)\n    val rosyBrown            = rgb(0xbc.uByte, 0x8f.uByte, 0x8f.uByte)\n    val royalBlue            = rgb(0x41.uByte, 0x69.uByte, 0xe1.uByte)\n    val saddleBrown          = rgb(0x8b.uByte, 0x45.uByte, 0x13.uByte)\n    val salmon               = rgb(0xfa.uByte, 0x80.uByte, 0x72.uByte)\n    val sandyBrown           = rgb(0xf4.uByte, 0xa4.uByte, 0x60.uByte)\n    val seaGreen             = rgb(0x2e.uByte, 0x8b.uByte, 0x57.uByte)\n    val seaShell             = rgb(0xff.uByte, 0xf5.uByte, 0xee.uByte)\n    val sienna               = rgb(0xa0.uByte, 0x52.uByte, 0x2d.uByte)\n    val silver               = rgb(0xc0.uByte, 0xc0.uByte, 0xc0.uByte)\n    val skyBlue              = rgb(0x87.uByte, 0xce.uByte, 0xeb.uByte)\n    val slateBlue            = rgb(0x6a.uByte, 0x5a.uByte, 0xcd.uByte)\n    val slateGray            = rgb(0x70.uByte, 0x80.uByte, 0x90.uByte)\n    val slateGrey            = rgb(0x70.uByte, 0x80.uByte, 0x90.uByte)\n    val snow                 = rgb(0xff.uByte, 0xfa.uByte, 0xfa.uByte)\n    val springGreen          = rgb(0x00.uByte, 0xff.uByte, 0x7f.uByte)\n    val steelBlue            = rgb(0x46.uByte, 0x82.uByte, 0xb4.uByte)\n    val tan                  = rgb(0xd2.uByte, 0xb4.uByte, 0x8c.uByte)\n    val teal                 = rgb(0x00.uByte, 0x80.uByte, 0x80.uByte)\n    val thistle              = rgb(0xd8.uByte, 0xbf.uByte, 0xd8.uByte)\n    val tomato               = rgb(0xff.uByte, 0x63.uByte, 0x47.uByte)\n    val turquoise            = rgb(0x40.uByte, 0xe0.uByte, 0xd0.uByte)\n    val violet               = rgb(0xee.uByte, 0x82.uByte, 0xee.uByte)\n    val wheat                = rgb(0xf5.uByte, 0xde.uByte, 0xb3.uByte)\n    val white                = rgb(0xff.uByte, 0xff.uByte, 0xff.uByte)\n    val whiteSmoke           = rgb(0xf5.uByte, 0xf5.uByte, 0xf5.uByte)\n    val yellow               = rgb(0xff.uByte, 0xff.uByte, 0x00.uByte)\n    val yellowGreen          = rgb(0x9a.uByte, 0xcd.uByte, 0x33.uByte)\n  }\n  \n  class UByte(val value: Int) {\n    override def toString: String = value.toString\n    def toNormalized: Normalized = Normalized.clip(value / 255.0)\n  }\n  \n  object UByte {\n    def clip(n: Int): UByte = new UByte(n max 0 min 255)\n  }\n  \n  implicit class IntUByteOps(n: Int) {\n    def uByte: UByte = UByte.clip(n)\n  }\n  \n  class Normalized(val value: Double) {\n    override def toString: String = value.toString\n    def toUnsignedByte: UByte = math.round(value * 255).toInt.uByte\n  }\n  \n  object Normalized {\n    def clip(x: Double): Normalized = new Normalized(x max 0.0 min 1.0)\n    def wrap(x: Double): Normalized = new Normalized(if (0 <= x && x <= 1) x else x - math.floor(x))\n  }\n  \n  implicit class DoubleNormalizedOps(x: Double) {\n    def normalized: Normalized = Normalized.clip(x)\n  }\n  \n  class Angle(val toRadians: Double) {\n    def +(that: Angle): Angle = Angle(toRadians + that.toRadians)\n    def -(that: Angle): Angle = Angle(toRadians - that.toRadians)\n    def *(x: Double): Angle = Angle(toRadians * x)\n    def /(x: Double): Angle = Angle(toRadians / x)\n    def unary_- : Angle = Angle(-toRadians)\n    def toDegrees: Double = toRadians / Angle.TwoPi * 360\n    def toTurns: Double = toRadians / Angle.TwoPi\n    def cos: Double = math.cos(toRadians)\n    def sin: Double = math.sin(toRadians)\n  }\n  \n  object Angle {\n    val TwoPi = math.Pi * 2\n    val zero = Angle(0.0)\n    val one = Angle(TwoPi)\n  \n    def degrees(deg: Double): Angle = Angle(deg * TwoPi / 360.0)\n    def radians(rad: Double): Angle = Angle(rad)\n    def turns(t: Double): Angle = Angle(t * TwoPi)\n    def apply(radians: Double): Angle = new Angle(radians)\n  }\n  \n  implicit class DoubleAngleOps(x: Double) {\n    def radians: Angle = Angle.radians(x)\n    def degrees: Angle = Angle.degrees(x)\n    def turns: Angle = Angle.turns(x)\n    def *(angle: Angle): Angle = angle * x\n  }\n  \n  final case class Vec(x: Double, y: Double) {\n    def +(that: Vec): Vec = Vec(x + that.x, y + that.y)\n    def -(that: Vec): Vec = Vec(x - that.x, y - that.y)\n    def unary_- : Vec = Vec(-x, -y)\n\n    def *(d: Double): Vec = Vec(x * d, y * d)\n    def /(d: Double): Vec = Vec(x / d, y / d)\n    \n    def angle: Angle = Angle.radians(math.atan2(y, x))\n    def length: Double = math.sqrt(x*x + y*y)\n\n    def normalize: Vec = {\n      val len = length\n      if (len == 0) Vec(1, 0) else this / len\n    }\n\n    def rotate(by: Angle): Vec = Vec.polar(length, angle + by)\n    def dot(that: Vec): Double = x * that.x + y * that.y\n    def cross(that: Vec): Double = x * that.y - y * that.x\n    def toPoint: Point = Point(x, y)\n  }\n  \n  object Vec {\n    val zero = Vec(0, 0)\n    val unitX = Vec(1, 0)\n    val unitY = Vec(0, 1)\n    def polar(r: Double, a: Angle): Vec = Vec(r * a.cos, r * a.sin)\n    def polar(a: Angle): Vec = polar(1, a)\n  }\n  \n  implicit class DoubleVecOps(x: Double) {\n    def *(vec: Vec): Vec = vec * x\n  }\n  \n  final case class Point(x: Double, y: Double) {\n    def +(that: Vec): Point = Point(x + that.x, y + that.y)\n    def -(that: Point): Vec = Vec(x - that.x, y - that.y)\n\n    def angle: Angle = Angle.radians(math.atan2(y, x))\n    def length: Double = math.sqrt(x*x + y*y)\n    def toVec: Vec = Vec(x, y)\n\n    def rotate(by: Angle): Point = Point.polar(length, angle + by)\n  }\n  \n  object Point {\n    val zero = Point(0, 0)\n    def cartesian(x: Double, y: Double): Point = Point(x, y)\n    def polar(r: Double, a: Angle): Point = Point(r * a.cos, r * a.sin)\n  }\n  \n  import Point._\n\n  sealed trait PathElement {\n    def p: Point\n    def trace(d: CanvasRenderingContext2D): Unit\n  }\n  \n  object PathElement {\n    def moveTo(p: Point): PathElement = MoveTo(p)\n    def lineTo(p: Point): PathElement = LineTo(p)\n    def curveTo(c1: Point, c2: Point, p: Point): PathElement = CurveTo(c1, c2, p)\n  }\n  \n  import PathElement._\n\n  final case class MoveTo(p: Point) extends PathElement {\n    def trace(d: CanvasRenderingContext2D): Unit = d.moveTo(p.x, p.y)\n  }\n  \n  final case class LineTo(p: Point) extends PathElement {\n    def trace(d: CanvasRenderingContext2D): Unit = d.lineTo(p.x, p.y)\n  }\n  \n  final case class CurveTo(c1: Point, c2: Point, p: Point) extends PathElement {\n    def trace(d: CanvasRenderingContext2D): Unit = d.bezierCurveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y)\n  }\n  \n  object Turtle {\n    case class TurtleState(at: Vec, heading: Angle)\n    \n    def draw(instructions: List[Instruction]): Image = {\n      def iterate(state: TurtleState, instructions: List[Instruction]): List[PathElement] =\n        instructions match {\n          case Nil =>\n            Nil\n          case i :: is =>\n            val (newState, elements) = process(state, i)\n            elements ++ iterate(newState, is)\n        }\n        \n      def process(state: TurtleState, instruction: Instruction): (TurtleState, List[PathElement]) = {\n        import PathElement._\n      \n        instruction match {\n          case Forward(d) =>\n            val nowAt = state.at + Vec.polar(d, state.heading)\n            val element = lineTo(nowAt.toPoint)\n            (state.copy(at = nowAt), List(element))\n          case Turn(a) =>\n            val nowHeading = state.heading + a\n            (state.copy(heading = nowHeading), List())\n          case Branch(is) =>\n            val branchedElements = iterate(state, is)\n            (state, branchedElements :+ moveTo(state.at.toPoint))\n          case NoOp =>\n            (state, List())\n        }\n      }\n    \n      openPath(iterate(TurtleState(Vec.zero, Angle.zero), instructions))\n    }\n  }\n  \n  sealed trait Instruction\n  \n  object Instruction {\n    def forward(distance: Double): Instruction = Forward(distance)\n    def turn(angle: Angle): Instruction = Turn(angle)\n    def branch(instructions: Instruction*): Instruction = Branch(instructions.toList)\n    def noop: Instruction = NoOp\n  }\n  \n  import Instruction._\n\n  final case class Forward(distance: Double) extends Instruction\n  \n  final case class Turn(angle: Angle) extends Instruction\n  \n  final case class Branch(instructions: List[Instruction]) extends Instruction\n  \n  final case object NoOp extends Instruction\n  \n  abstract class Random[T] { self =>\n    def run: T\n  \n    def map[U](f: T => U): Random[U] = new Random[U] {\n      def run: U = f(self.run)\n    }\n  \n    def flatMap[U](f: T => Random[U]): Random[U] = new Random[U] {\n      def run: U = f(self.run).run\n    }\n  }\n\n  object Random {\n    val rng = new scala.util.Random\n  \n    def always[T](value: T): Random[T] = new Random[T] {\n      def run: T = value\n    }\n  \n    def double: Random[Double] = new Random[Double] {\n      def run: Double = rng.nextDouble\n    }\n  \n    def int: Random[Int] = new Random[Int] {\n      def run: Int = rng.nextInt\n    }\n  \n    def natural(limit: Int): Random[Int] = new Random[Int] {\n      def run: Int = rng.nextInt(limit)\n    }\n  \n    def oneOf[T](values: T*): Random[T] = new Random[T] {\n      def run: T = values(rng.nextInt(values.size))\n    }\n  \n    def normal(mean: Double, stdDev: Double): Random[Double] = new Random[Double] {\n      def run: Double = mean + stdDev * rng.nextGaussian\n    }\n  \n    def normal: Random[Double] = normal(0, 1)\n  }\n  \n  implicit def drawRandomImage(r: Random[Image]) = new {\n    def draw: Unit = r.run.draw\n  }\n  \n  // $FiddleStart\n  def polygon(sides: Int, size: Int, initialRotation: Angle): Image = {\n    def iter(n: Int, rotation: Angle): List[PathElement] = n match {\n      case 0 =>\n        Nil\n      case n =>\n        LineTo(polar(size, rotation * n + initialRotation)) :: iter(n - 1, rotation)\n    }\n    \n    closedPath(moveTo(polar(size, initialRotation)) :: iter(sides, 360.degrees / sides))\n  }\n  \n  val gradient = linearGradient(Point(-80, -80), Point(80, 80),\n    (0.normalized, Color.red),\n    (0.5.normalized, Color.green),\n    (1.normalized, Color.blue))\n  \n  val a = polygon(9, 80, 20.degrees).fillColor(gradient).lineWidth(4)\n  \n  def squareSpiral(steps: Int, distance: Double, angle: Angle, increment: Double): Image = {\n    Turtle.draw((1 to steps).toList.flatMap { n =>\n      List(forward(distance + (n * increment)), turn(angle))\n    })\n  }\n  \n  val b = squareSpiral(180, 0, 91.degrees, 1).recenter.lineColor(Color.maroon)\n  \n  def randomCircle(r: Double, color: Random[Color]): Random[Image] =\n    color map (fill => Image.circle(r) fillColor fill)\n    \n  def randomAngle: Random[Angle] = Random.double.map(x => x.turns)\n  \n  def randomColor(s: Normalized, l: Normalized): Random[Color] =\n    randomAngle map (hue => Color.hsl(hue, s, l))\n  \n  val randomPastel = randomColor(0.7.normalized, 0.7.normalized)\n  \n  def randomConcentricCircles(count: Int, size: Int): Random[Image] =\n    count match {\n      case 0 => Random.always(Image.empty)\n      case n =>\n        for {\n          circle <- randomCircle(size, randomPastel)\n          circles <- randomConcentricCircles(n-1, size + 5)\n        } yield circle on circles\n    }\n  \n  val rc = randomConcentricCircles(7, 50)\n  \n  def parametricCircle(angle: Angle): Point = Point.polar(80, angle)\n  \n  def sample(start: Angle, samples: Int): Image = {\n    // Angle.one is one complete turn. I.e. 360 degrees\n    val step = Angle.one / samples\n    val dot = triangle(10, 10)\n    def loop(count: Int): Image = {\n      val angle = step * count\n      count match {\n        case 0 => Image.empty\n        case n => dot.at(parametricCircle(angle).toVec).color(Color.fireBrick.spin(angle)) on loop(n - 1)\n        \n      }\n    }\n    loop(samples)\n  }\n  \n  val radGrad = dichromaticRadial(Color.white, Color.purple, 60)\n  \n  val d = text("Hello World").font("20px serif").fillColor(radGrad).rotate(45.degrees) on\n    sample(0.degrees, 72)\n  \n  val result = for {\n    c <- rc\n  } yield ((a beside (b on a.scale(0.5).byLeft.showBounds.resize(0, 0))) above (c beside d))\n  \n  result.draw\n  // $FiddleEnd\n}\n')))}s.isMDXComponent=!0},219:function(e,n,t){"use strict";t.d(n,"a",(function(){return y})),t.d(n,"b",(function(){return f}));var a=t(0),l=t.n(a);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function d(e,n){if(null==e)return{};var t,a,l=function(e,n){if(null==e)return{};var t,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var u=l.a.createContext({}),s=function(e){var n=l.a.useContext(u),t=n;return e&&(t="function"==typeof e?e(n):i({},n,{},e)),t},y=function(e){var n=s(e.components);return l.a.createElement(u.Provider,{value:n},e.children)},x={inlineCode:"code",wrapper:function(e){var n=e.children;return l.a.createElement(l.a.Fragment,{},n)}},g=Object(a.forwardRef)((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,o=e.parentName,u=d(e,["components","mdxType","originalType","parentName"]),y=s(t),g=a,f=y["".concat(o,".").concat(g)]||y[g]||x[g]||r;return t?l.a.createElement(f,i({ref:n},u,{components:t})):l.a.createElement(f,i({ref:n},u))}));function f(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,o=new Array(r);o[0]=g;var i={};for(var d in n)hasOwnProperty.call(n,d)&&(i[d]=n[d]);i.originalType=e,i.mdxType="string"==typeof e?e:a,o[1]=i;for(var u=2;u<r;u++)o[u]=t[u];return l.a.createElement.apply(null,o)}return l.a.createElement.apply(null,t)}g.displayName="MDXCreateElement"}}]);