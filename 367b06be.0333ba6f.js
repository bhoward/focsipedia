(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{120:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return a})),t.d(n,"metadata",(function(){return o})),t.d(n,"rightToc",(function(){return s})),t.d(n,"default",(function(){return p}));var l=t(1),r=t(6),i=(t(0),t(180)),a={id:"doodle",title:"Doodle Graphics"},o={id:"fp/doodle",title:"Doodle Graphics",description:"```reason hidden",source:"@site/docs/fp/doodle.md",permalink:"/focsipedia/docs/fp/doodle",editUrl:"https://github.com/bhoward/focsipedia/edit/master/docs/fp/doodle.md",sidebar:"someSidebar",previous:{title:"Types in Functional Programming",permalink:"/focsipedia/docs/fp/types"},next:{title:"ReasonML",permalink:"/focsipedia/docs/reason"}},s=[],b={rightToc:s},c="wrapper";function p(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(i.b)(c,Object(l.a)({},b,t,{components:n,mdxType:"MDXLayout"}),Object(i.b)("pre",null,Object(i.b)("code",Object(l.a)({parentName:"pre"},{className:"language-reason",metastring:"hidden",hidden:!0}),"type point = (float, float);\ntype angle = float;\ntype pathElement =\n| MoveTo(point)\n| LineTo(point)\n| CurveTo(point, point, point);\ntype color =\n| Color(string)\n| RGBA(int, int, int, float)\n| HSLA(angle, float, float, float);\ntype style =\n| LineWidth(float)\n| LineColor(color) /* TODO patterns? */\n| FillColor(color)\n| Dashed; /* TODO: Font(family, size, style, ...) */\ntype image =\n| Empty\n| Ellipse(float, float)\n| Rectangle(float, float)\n| Text(string)\n| OpenPath(list(pathElement))\n| ClosedPath(list(pathElement))\n| Beside(image, image)\n| Above(image, image)\n| On(image, image)\n| Styled(image, list(style))\n| Translate(image, float, float)\n| Rotate(image, angle)\n| Scale(image, float, float)\n| Bounds(image, float, float, float, float);\ntype position = TL | TC | TR | ML | MC | MR | BL | BC | BR;\nlet string_of_color = c => {\n  switch (c) {\n  | Color(s) => s\n  | RGBA(r, g, b, a) =>\n    Printf.sprintf(\"rgba(%d,%d,%d,%f)\",\n      r, g, b, a)\n  | HSLA(h, s, l, a) =>\n    Printf.sprintf(\"hsla(%f,%d%%,%d%%,%f)\",\n      h, int_of_float(s *. 100.), int_of_float(l *. 100.), a)\n  }\n};\nlet string_of_style = s => {\n  switch (s) {\n  | LineWidth(w) =>\n    Printf.sprintf(\"stroke-width='%f'\", w)\n  | LineColor(c) =>\n    Printf.sprintf(\"stroke='%s'\", string_of_color(c))\n  | FillColor(c) => \n    Printf.sprintf(\"fill='%s'\", string_of_color(c))\n  | Dashed =>\n    \"stroke-dasharray='4'\"\n  }\n}\nlet radians = a => {\n  a *. 3.14159265358979 /. 180.0\n};\nlet getPoint = elt => {\n  switch (elt) {\n  | MoveTo(p) => p\n  | LineTo(p) => p\n  | CurveTo(_, _, p) => p\n  }\n};\nlet rec bbox_of_points = ps => {\n  switch (ps) {\n  | [] => (0., 0., 0., 0.)\n  | [(x, y)] => (x, x, y, y)\n  | [(x, y), ...rest] => {\n      let (l, r, t, b) = bbox_of_points(rest);\n      (min(x, l), max(x, r), min(y, t), max(y, b))\n    }\n  }\n};\nlet rec bbox = img => {\n  switch (img) {\n  | Empty => (0., 0., 0., 0.)\n  | Ellipse(w, h) => (-.w /. 2., w /. 2., -.h /. 2., h /. 2.)\n  | Rectangle(w, h) => (-.w /. 2., w /. 2., -.h /. 2., h /. 2.)\n  | Text(_) => (0., 0., 0., 0.)\n  | OpenPath(elts) => {\n    bbox_of_points(List.map(getPoint, elts))\n  }\n  | ClosedPath(elts) => {\n    bbox_of_points(List.map(getPoint, elts))\n  }\n  | Beside(l, r) => {\n    let (ll, lr, lt, lb) = bbox(l);\n    let (rl, rr, rt, rb) = bbox(r);\n    let w = (lr -. ll) +. (rr -. rl);\n    (-.w /. 2., w /. 2., min(lt, rt), max(lb, rb))\n  }\n  | Above(t, b) => {\n    let (tl, tr, tt, tb) = bbox(t);\n    let (bl, br, bt, bb) = bbox(b);\n    let h = (tb -. tt) +. (bb -. bt);\n    (min(tl, bl), max(tr, br), -.h /. 2., h /. 2.)\n  }\n  | On(a, b) => {\n    let (al, ar, at, ab) = bbox(a);\n    let (bl, br, bt, bb) = bbox(b);\n    (min(al, bl), max(ar, br), min(at, bt), max(ab, bb))\n  }\n  | Styled(img, _) => bbox(img)\n  | Translate(img, x, y) => {\n    let (l, r, t, b) = bbox(img);\n    (l +. x, r +. x, t +. y, b +. y)\n  }\n  | Rotate(img, a) => {\n    let (l, r, t, b) = bbox(img);\n    let ps = [(l, t), (l, b), (r, t), (r, b)];\n    let arad = radians(a);\n    let cosa = cos(arad);\n    let sina = sin(arad);\n    let rot = ((x, y)) => { (x *. cosa -. y *. sina, x *. sina +. y *. cosa) }\n    bbox_of_points(List.map(rot, ps))\n  }\n  | Scale(img, sx, sy) => {\n    let (l, r, t, b) = bbox(img);\n    (l *. sx, r *. sx, t *. sy, b *. sy)\n  }\n  | Bounds(_, l, r, t, b) => (l, r, t, b)\n  }\n};\nlet rec width = img => {\n  let (l, r, _, _) = bbox(img);\n  r -. l\n};\nlet rec height = img => {\n  let (_, _, t, b) = bbox(img);\n  b -. t\n};\nlet rec string_of_path = path => {\n  switch (path) {\n  | [] => \"\"\n  | [MoveTo((x, y)), ...rest] =>\n      Printf.sprintf(\"M %f %f \", x, y) ++ string_of_path(rest)\n  | [LineTo((x, y)), ...rest] =>\n      Printf.sprintf(\"L %f %f \", x, y) ++ string_of_path(rest)\n  | [CurveTo((x1, y1), (x2, y2), (x3, y3)), ...rest] =>\n      Printf.sprintf(\"C %f %f, %f %f, %f %f \", x1, y1, x2, y2, x3, y3) ++ string_of_path(rest)\n  }\n};\nlet rec render = img => {\n  switch (img) {\n  | Empty => \"\"\n  | Ellipse(w, h) =>\n    Printf.sprintf(\"<ellipse rx='%f' ry='%f' cx='0' cy='0' />\",\n      w /. 2., h /. 2.)\n  | Rectangle(w, h) =>\n    Printf.sprintf(\"<rect width='%f' height='%f' x='%f' y='%f' />\",\n      w, h, -.w /. 2., -.h /. 2.)\n  | Text(s) =>\n    Printf.sprintf(\"<text x='0' y='0' text-anchor='middle' dominant-baseline='middle'>%s</text>\", s)\n  | OpenPath(path) =>\n    Printf.sprintf(\"<path d='%s' fill='none' stroke-linejoin='round' stroke-linecap='round' />\", string_of_path(path))\n  | ClosedPath(path) => \n    Printf.sprintf(\"<path d='%sZ' stroke-linejoin='round' stroke-linecap='round' />\", string_of_path(path))\n  | Beside(l, r) => {\n      let (ll, lr, _, _) = bbox(l);\n      let (rl, rr, _, _) = bbox(r);\n      let w = (lr -. ll) +. (rr -. rl);\n      Printf.sprintf(\"<g transform='translate(%f,0)'>%s</g>\",\n        -.w /. 2. -. ll, render(l))\n      ++\n      Printf.sprintf(\"<g transform='translate(%f,0)'>%s</g>\",\n        w /. 2. -. rr, render(r))\n    } \n  | Above(t, b) => {\n      let (_, _, tt, tb) = bbox(t);\n      let (_, _, bt, bb) = bbox(b);\n      let h = (tb -. tt) +. (bb -. bt);\n      Printf.sprintf(\"<g transform='translate(0,%f)'>%s</g>\",\n        -.h /. 2. -. tt, render(t))\n      ++\n      Printf.sprintf(\"<g transform='translate(0,%f)'>%s</g>\",\n        h /. 2. -. bb, render(b))\n    }\n  | On(a, b) => render(b) ++ render(a)\n  | Styled(img, stys) => {\n      let ss = List.map(s => { \" \" ++ string_of_style(s) }, stys);\n      Printf.sprintf(\"<g %s>%s</g>\", List.fold_left((++), \"\", ss), render(img))\n    }\n  | Translate(img, x, y) =>\n    Printf.sprintf(\"<g transform='translate(%f,%f)'>%s</g>\",\n      x, y, render(img))\n  | Rotate(img, a) =>\n    Printf.sprintf(\"<g transform='rotate(%f)'>%s</g>\",\n      a, render(img))\n  | Scale(img, sx, sy) =>\n    Printf.sprintf(\"<g transform='scale(%f,%f)'>%s</g>\",\n      sx, sy, render(img))\n  | Bounds(img, _, _, _, _) => render(img)\n  }\n};\nlet draw = image => {\n  let (l, r, t, b) = bbox(image);\n  let w = r -. l;\n  let h = b -. t;\n  let padw = w *. 0.05;\n  let padh = h *. 0.05;\n  let newl = min(l -. padw, -100.);\n  let newr = max(r +. padw, 100.);\n  let newt = t -. padh;\n  let newb = b +. padh;\n  Printf.printf(\"<svg viewBox='%f %f %f %f' width='100%%' preserveAspectRatio>\",\n    newl, newt, newr -. newl, newb -. newt);\n  print_string(\"<g fill='grey' stroke='black' font-size='14'>\");\n  print_string(render(image));\n  print_string(\"</g></svg>\\n\");\n};\nlet empty = Empty;\nlet circle = r => { Ellipse(2. *. r, 2. *. r) };\nlet ellipse = (w, h) => { Ellipse(w, h) };\nlet rectangle = (w, h) => { Rectangle(w, h) };\nlet square = w => { Rectangle(w, w) };\nlet text = s => { Text(s) };\nlet (---) = (a, b) => { Above(a, b) };\nlet (|||) = (a, b) => { Beside(a, b) };\nlet (***) = (a, b) => { On(a, b) };\nlet fill = (c, img) => { Styled(img, [FillColor(c)]) };\nlet stroke = (c, img) => { Styled(img, [LineColor(c)]) };\nlet solid = (c, img) => { Styled(img, [FillColor(c), LineColor(c)]) };\nlet strokeWidth = (w, img) => { Styled(img, [LineWidth(w)]) };\nlet focus = (pos, img) => {\n  let (l, r, t, b) = bbox(img);\n  switch (pos) {\n  | TL => Translate(img, -.l, -.t)\n  | TC => Translate(img, -.(l +. r) /. 2., -.t)\n  | TR => Translate(img, -.r, -.t)\n  | ML => Translate(img, -.l, -.(t +. b) /. 2.)\n  | MC => Translate(img, -.(l +. r) /. 2., -.(t +. b) /. 2.)\n  | MR => Translate(img, -.r, -.(t +. b) /. 2.)\n  | BL => Translate(img, -.l, -.b)\n  | BC => Translate(img, -.(l +. r) /. 2., -.b)\n  | BR => Translate(img, -.r, -.b)\n  }\n};\nlet rotate = (a, img) => { Rotate(img, a) };\nlet translate = (dx, dy, img) => { Translate(img, dx, dy) };\nlet scalexy = (sx, sy, img) => { Scale(img, sx, sy) };\nlet scale = (s, img) => { Scale(img, s, s) };\nlet setBounds = (l, r, t, b, img) => { Bounds(img, l, r, t, b) };\nlet showBounds = img => {\n  let (l, r, t, b) = bbox(img);\n  let w = r -. l;\n  let h = b -. t;\n  On(\n    Bounds(Styled(\n      circle(max(w, h) /. 20.) ***\n        OpenPath([MoveTo((-.w /. 10., 0.)), LineTo((w /. 10., 0.))]) ***\n        OpenPath([MoveTo((0., -.h /. 10.)), LineTo((0., h /. 10.))]) ***\n        Translate(rectangle(w, h), l +. w /. 2., t +. h /. 2.),\n      [Dashed, FillColor(Color(\"none\")), LineColor(Color(\"black\")), LineWidth(1.0)]), 0., 0., 0., 0.),\n    img\n  )\n}\nlet polar = (r, theta) => {\n  let a = radians(theta);\n  (r *. cos(a), r *. sin(a))\n};\nlet rgb = (r, g, b) => { RGBA(r, g, b, 1.0) };\nlet rgba = (r, b, g, a) => { RGBA(r, g, b, a) };\nlet hsl = (h, s, l) => { HSLA(h, s, l, 1.0) };\nlet hsla = (h, s, l, a) => {HSLA(h, s, l, a) };\nlet moveXY = (x, y) => { MoveTo((x, y)) };\nlet lineXY = (x, y) => { LineTo((x, y)) };\nlet curveXY = (c1x, c1y, c2x, c2y, px, py) => { CurveTo((c1x, c1y), (c2x, c2y), (px, py)) };\nlet curveP = (c1, c2, p) => { CurveTo(c1, c2, p) };\nlet moveP = p => { MoveTo(p) };\nlet lineP = p => { LineTo(p) };\nlet rec circles = n => {\n  if (n == 0) {\n    Empty\n  } else {\n    circles(n - 1) ***\n      fill(hsl(float_of_int(24 * n), 1.0, 0.5), circle(float_of_int(10 * n)))\n  }\n};\nlet logo = scale(2.1, fill(Color(\"black\"), text(\"DPoodle\"))) *** circles(10);\ndraw(logo)\n")),Object(i.b)("p",null,"Here is an ugly example:"),Object(i.b)("pre",null,Object(i.b)("code",Object(l.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),'let blueFill = img => { Styled(img, [FillColor(Color("blue"))]) };\nlet wideLines = img => { Styled(img, [LineWidth(3.0)]) };\nlet redOutline = img => { Styled(img, [LineColor(Color("red"))]) };\nlet a = blueFill(Ellipse(60.0, 80.0));\nlet b = wideLines(Rectangle(50.0, 50.0));\nlet c = Ellipse(30.0, 30.0);\nlet d = Bounds(Text("Hello"), -20., 20., -7., 7.);\ndraw(On(Rotate(Scale(d, 5., 5.), 45.),\n        redOutline(Above(Beside(a, b), c))));\n')),Object(i.b)("p",null,"Here is the same with operators and other shortcuts:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"a ||| b")," is ",Object(i.b)("inlineCode",{parentName:"li"},"Beside(a, b)")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"a --- b")," is ",Object(i.b)("inlineCode",{parentName:"li"},"Above(a, b)")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"a *** b")," is ",Object(i.b)("inlineCode",{parentName:"li"},"On(a, b)"))),Object(i.b)("pre",null,Object(i.b)("code",Object(l.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),'let blueFill = fill(Color("blue"));\nlet wideLines = strokeWidth(3.0);\nlet redOutline = stroke(Color("red"));\nlet a = blueFill(ellipse(60.0, 80.0));\nlet b = wideLines(square(50.0));\nlet c = circle(30.0);\nlet d = setBounds(-20., 20., -7., 7., text("Hello"));\ndraw(rotate(45., scale(5., d)) *** redOutline((a ||| b) --- c));\n')),Object(i.b)("p",null,"Here is an example of drawing a polygon using a closed path and polar coordinates:"),Object(i.b)("pre",null,Object(i.b)("code",Object(l.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),'let polygon = (sides, size, initialAngle) => {\n  let rotation = 360. /. float_of_int(sides);\n  let getPoint = n => polar(size, rotation *. float_of_int(n) +. initialAngle);\n  let rec path = n => {\n    if (n == 0) {\n      []\n    } else {\n      [lineP(getPoint(n)), ...path(n - 1)]\n    }\n  };\n  ClosedPath([moveP(getPoint(sides)), ...path(sides - 1)])\n};\n\ndraw(solid(Color("green"), polygon(6, 30., 90.)));\n')),Object(i.b)("p",null,"Here is an arrow. The ",Object(i.b)("inlineCode",{parentName:"p"},"focus")," function moves the ",Object(i.b)("em",{parentName:"p"},"focus")," point of the image (the point used\nto line up images with ",Object(i.b)("inlineCode",{parentName:"p"},"On"),", ",Object(i.b)("inlineCode",{parentName:"p"},"Beside"),", and ",Object(i.b)("inlineCode",{parentName:"p"},"Above"),").\nThe first argument of focus is a two-letter value; the first letter is (T)op, (M)iddle, or (B)ottom, and the second is (L)eft, (C)enter, or (R)ight.\nThe value ",Object(i.b)("inlineCode",{parentName:"p"},"ML")," says to move the focus to the middle of the left edge of the bounding box, which in this\ncase is the tail end of the arrow.\nWe can use the ",Object(i.b)("inlineCode",{parentName:"p"},"showBounds")," function to visualize the bounding box and focus point."),Object(i.b)("pre",null,Object(i.b)("code",Object(l.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),'let arrow = len => {\n  strokeWidth(2., focus(ML, OpenPath([\n    moveXY(0., 0.),\n    lineXY(len, 0.),\n    lineXY(len -. 5., 5.),\n    moveXY(len, 0.),\n    lineXY(len -. 5., -5.)])))\n};\n\ndraw(arrow(50.))\n\ndraw(showBounds(arrow(50.)))\n\ndraw(arrow(50.) *** rotate(-90., arrow(30.)) *** fill(Color("white"), circle(60.)))\n')),Object(i.b)("p",null,"Using the arrow, here is a function to visualize a linked list:"),Object(i.b)("pre",null,Object(i.b)("code",Object(l.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),'let listNode = n => {\n  let valueField = solid(Color("black"), text(string_of_int(n))) *** square(20.);\n  let nextField = arrow(20.) *** square(20.);\n  fill(Color("white"), valueField ||| nextField)\n};\n\nlet rec showList = nums => {\n  switch (nums) {\n  | [] => solid(Color("black"), circle(5.))\n  | [head, ...tail] => listNode(head) ||| showList(tail)\n  }\n};\n\ndraw(showList([1, 2, 3]));\ndraw(showList([1, 2, 3, 4, 5, 6, 7, 8, 9]));\n')))}p.isMDXComponent=!0},180:function(e,n,t){"use strict";t.d(n,"a",(function(){return p})),t.d(n,"b",(function(){return g}));var l=t(0),r=t.n(l);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);n&&(l=l.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,l)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,l,r=function(e,n){if(null==e)return{};var t,l,r={},i=Object.keys(e);for(l=0;l<i.length;l++)t=i[l],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(l=0;l<i.length;l++)t=i[l],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var b=r.a.createContext({}),c=function(e){var n=r.a.useContext(b),t=n;return e&&(t="function"==typeof e?e(n):o({},n,{},e)),t},p=function(e){var n=c(e.components);return r.a.createElement(b.Provider,{value:n},e.children)},d="mdxType",f={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},m=Object(l.forwardRef)((function(e,n){var t=e.components,l=e.mdxType,i=e.originalType,a=e.parentName,b=s(e,["components","mdxType","originalType","parentName"]),p=c(t),d=l,m=p["".concat(a,".").concat(d)]||p[d]||f[d]||i;return t?r.a.createElement(m,o({ref:n},b,{components:t})):r.a.createElement(m,o({ref:n},b))}));function g(e,n){var t=arguments,l=n&&n.mdxType;if("string"==typeof e||l){var i=t.length,a=new Array(i);a[0]=m;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o[d]="string"==typeof e?e:l,a[1]=o;for(var b=2;b<i;b++)a[b]=t[b];return r.a.createElement.apply(null,a)}return r.a.createElement.apply(null,t)}m.displayName="MDXCreateElement"}}]);