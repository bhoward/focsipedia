(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{110:function(n,t,e){"use strict";e.r(t),e.d(t,"frontMatter",(function(){return i})),e.d(t,"metadata",(function(){return a})),e.d(t,"rightToc",(function(){return s})),e.d(t,"default",(function(){return p}));var r=e(1),l=e(6),o=(e(0),e(169)),i={id:"doodle",title:"Doodle Graphics"},a={id:"fp/doodle",title:"Doodle Graphics",description:"```reason hidden",source:"@site/docs/fp/doodle.md",permalink:"/focsipedia/docs/fp/doodle",editUrl:"https://github.com/bhoward/focsipedia/edit/master/docs/fp/doodle.md",sidebar:"someSidebar",previous:{title:"Types in Functional Programming",permalink:"/focsipedia/docs/fp/types"},next:{title:"ReasonML",permalink:"/focsipedia/docs/reason"}},s=[],f={rightToc:s},c="wrapper";function p(n){var t=n.components,e=Object(l.a)(n,["components"]);return Object(o.b)(c,Object(r.a)({},f,e,{components:t,mdxType:"MDXLayout"}),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-reason",metastring:"hidden",hidden:!0}),"type point = (float, float);\ntype pathElement =\n| MoveTo(point)\n| LineTo(point)\n| CurveTo(point, point, point);\ntype color =\n| Color(string)\n| RGBA(float, float, float, float)\n| HSLA(float, float, float, float);\ntype style =\n| LineWidth(float)\n| LineColor(color) /* TODO patterns? */\n| FillColor(color)\n| Dashed; /* TODO: Font(family, size, style, ...) */\ntype angle = float;\ntype image =\n| Empty\n| Ellipse(float, float)\n| Rectangle(float, float)\n| Text(string)\n| OpenPath(list(pathElement))\n| ClosedPath(list(pathElement))\n| Beside(image, image)\n| Above(image, image)\n| On(image, image)\n| Styled(image, style)\n| Translate(image, float, float)\n| Rotate(image, angle)\n| Scale(image, float, float)\n| Bounds(image, float, float, float, float);\nlet string_of_color = c => {\n  switch (c) {\n  | Color(s) => s\n  | RGBA(r, g, b, a) =>\n    Printf.sprintf(\"rgba(%d,%d,%d,%f)\",\n      int_of_float(r), int_of_float(g), int_of_float(b), a)\n  | HSLA(h, s, l, a) =>\n    Printf.sprintf(\"hsla(%f,%d%%,%d%%,%f)\",\n      h, int_of_float(s *. 100.), int_of_float(l *. 100.), a)\n  }\n};\nlet getPoint = elt => {\n  switch (elt) {\n  | MoveTo(p) => p\n  | LineTo(p) => p\n  | CurveTo(_, _, p) => p\n  }\n};\nlet rec bbox_of_points = ps => {\n  switch (ps) {\n  | [] => (0., 0., 0., 0.)\n  | [(x, y)] => (x, x, y, y)\n  | [(x, y), ...rest] => {\n      let (l, r, t, b) = bbox_of_points(rest);\n      (min(x, l), max(x, r), min(y, t), max(y, b))\n    }\n  }\n};\nlet rec bbox = img => {\n  switch (img) {\n  | Empty => (0., 0., 0., 0.)\n  | Ellipse(w, h) => (-.w /. 2., w /. 2., -.h /. 2., h /. 2.)\n  | Rectangle(w, h) => (-.w /. 2., w /. 2., -.h /. 2., h /. 2.)\n  | Text(_) => (0., 0., 0., 0.)\n  | OpenPath(elts) => {\n    bbox_of_points(List.map(getPoint, elts))\n  }\n  | ClosedPath(elts) => {\n    bbox_of_points(List.map(getPoint, elts))\n  }\n  | Beside(l, r) => {\n    let (ll, lr, lt, lb) = bbox(l);\n    let (rl, rr, rt, rb) = bbox(r);\n    (ll -. (rr -. rl) /. 2., rr +. (lr -. ll) /. 2., min(lt, rt), max(lb, rb))\n  }\n  | Above(t, b) => {\n    let (tl, tr, tt, tb) = bbox(t);\n    let (bl, br, bt, bb) = bbox(b);\n    (min(tl, bl), max(tr, br), tt -. (bb -. bt) /. 2., bb +. (tb -. tt) /. 2.)\n  }\n  | On(a, b) => {\n    let (al, ar, at, ab) = bbox(a);\n    let (bl, br, bt, bb) = bbox(b);\n    (min(al, bl), max(ar, br), min(at, bt), max(ab, bb))\n  }\n  | Styled(img, _) => bbox(img)\n  | Translate(img, x, y) => {\n    let (l, r, t, b) = bbox(img);\n    (l +. x, r +. x, t +. y, b +. y)\n  }\n  | Rotate(img, a) => {\n    let (l, r, t, b) = bbox(img);\n    let ps = [(l, t), (l, b), (r, t), (r, b)];\n    let arad = a *. 3.14159265358979 /. 180.0;\n    let cosa = cos(arad);\n    let sina = sin(arad);\n    let rot = ((x, y)) => { (x *. cosa -. y *. sina, x *. sina +. y *. cosa) }\n    bbox_of_points(List.map(rot, ps))\n  }\n  | Scale(img, sx, sy) => {\n    let (l, r, t, b) = bbox(img);\n    (l *. sx, r *. sx, t *. sy, b *. sy)\n  }\n  | Bounds(_, l, r, t, b) => (l, r, t, b)\n  }\n};\nlet rec width = img => {\n  let (l, r, _, _) = bbox(img);\n  r -. l\n};\nlet rec height = img => {\n  let (_, _, t, b) = bbox(img);\n  b -. t\n};\nlet rec render = img => {\n  switch (img) {\n  | Empty => \"\"\n  | Ellipse(w, h) =>\n    Printf.sprintf(\"<ellipse rx='%f' ry='%f' cx='0' cy='0' />\",\n      w /. 2., h /. 2.)\n  | Rectangle(w, h) =>\n    Printf.sprintf(\"<rect width='%f' height='%f' x='%f' y='%f' />\",\n      w, h, -.w /. 2., -.h /. 2.)\n  | Text(s) =>\n    Printf.sprintf(\"<text x='0' y='0' text-anchor='middle' dominant-baseline='middle'>%s</text>\", s)\n  | OpenPath(path) => \"\" /* TODO */\n  | ClosedPath(path) => \"\" /* TODO */\n  | Beside(l, r) =>\n    Printf.sprintf(\"<g transform='translate(%f,0)'>%s</g>\",\n      -.width(r) /. 2., render(l))\n    ++\n    Printf.sprintf(\"<g transform='translate(%f,0)'>%s</g>\",\n      width(l) /. 2., render(r))\n  | Above(t, b) =>\n    Printf.sprintf(\"<g transform='translate(0,%f)'>%s</g>\",\n      -.height(b) /. 2., render(t))\n    ++\n    Printf.sprintf(\"<g transform='translate(0,%f)'>%s</g>\",\n      height(t) /. 2., render(b))\n  | On(a, b) => render(b) ++ render(a)\n  | Styled(img, sty) => {\n      switch (sty) {\n      | LineWidth(w) =>\n        Printf.sprintf(\"<g stroke-width='%f'>%s</g>\", w, render(img))\n      | LineColor(c) =>\n        Printf.sprintf(\"<g stroke='%s'>%s</g>\", string_of_color(c), render(img))\n      | FillColor(c) => \n        Printf.sprintf(\"<g fill='%s'>%s</g>\", string_of_color(c), render(img))\n      | Dashed =>\n        Printf.sprintf(\"<g stroke-dasharray='4'>%s</g>\", render(img))\n      }\n    }\n  | Translate(img, x, y) =>\n    Printf.sprintf(\"<g transform='translate(%f,%f)'>%s</g>\",\n      x, y, render(img))\n  | Rotate(img, a) =>\n    Printf.sprintf(\"<g transform='rotate(%f)'>%s</g>\",\n      a, render(img))\n  | Scale(img, sx, sy) =>\n    Printf.sprintf(\"<g transform='scale(%f,%f)'>%s</g>\",\n      sx, sy, render(img))\n  | Bounds(img, _, _, _, _) => render(img)\n  }\n};\nlet draw = image => {\n  print_string(\"<svg viewBox='-100 -100 200 200' width='100%' preserveAspectRatio>\");\n  print_string(\"<g fill='grey' stroke='black' font-size='14'>\");\n  print_string(render(image));\n  print_string(\"</g></svg>\");\n};\nlet circle = r => { Ellipse(2. *. r, 2. *. r) };\nlet ellipse = (w, h) => { Ellipse(w, h) };\nlet rectangle = (w, h) => { Rectangle(w, h) };\nlet text = s => { Text(s) };\nlet showBounds = img => {\n  let (l, r, t, b) = bbox(img);\n  let w = r -. l;\n  let h = b -. t;\n  On(\n    Styled(\n      Styled(\n        Styled(\n          Styled(\n            On(\n              circle(10.), /* TODO add the crosshairs */\n              Translate(rectangle(w, h), l +. w /. 2., t +. h /. 2.)),\n            Dashed),\n          FillColor(Color(\"none\"))),\n        LineColor(Color(\"black\"))),\n      LineWidth(1.0)),\n    img\n  )\n}\n\nlet rec foo = n => {\n  if (n == 0) {\n    Empty\n  } else {\n    On(foo(n - 1), Styled(circle(float_of_int(10 * n)),\n      FillColor(HSLA(float_of_int(24 * n), 1.0, 0.5, 1.0))))\n  }\n};\ndraw(On(Scale(Styled(Text(\"DPoodle\"), FillColor(Color(\"black\"))), 2.1, 2.1), foo(10)))\n")),Object(o.b)("p",null,"Here is an ugly example:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),'let blueFill = img => { Styled(img, FillColor(Color("blue"))) };\nlet wideLines = img => { Styled(img, LineWidth(3.0)) };\nlet redOutline = img => { Styled(img, LineColor(Color("red"))) };\nlet a = blueFill(ellipse(60.0, 80.0));\nlet b = wideLines(rectangle(50.0, 50.0));\nlet c = circle(30.0);\nlet d = Text("Hello");\ndraw(On(Rotate(Scale(d, 5., 5.), 45.),\n        redOutline(Above(Beside(a, b), c))));\n')))}p.isMDXComponent=!0},169:function(n,t,e){"use strict";e.d(t,"a",(function(){return p})),e.d(t,"b",(function(){return m}));var r=e(0),l=e.n(r);function o(n,t,e){return t in n?Object.defineProperty(n,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):n[t]=e,n}function i(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),e.push.apply(e,r)}return e}function a(n){for(var t=1;t<arguments.length;t++){var e=null!=arguments[t]?arguments[t]:{};t%2?i(Object(e),!0).forEach((function(t){o(n,t,e[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):i(Object(e)).forEach((function(t){Object.defineProperty(n,t,Object.getOwnPropertyDescriptor(e,t))}))}return n}function s(n,t){if(null==n)return{};var e,r,l=function(n,t){if(null==n)return{};var e,r,l={},o=Object.keys(n);for(r=0;r<o.length;r++)e=o[r],t.indexOf(e)>=0||(l[e]=n[e]);return l}(n,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);for(r=0;r<o.length;r++)e=o[r],t.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(n,e)&&(l[e]=n[e])}return l}var f=l.a.createContext({}),c=function(n){var t=l.a.useContext(f),e=t;return n&&(e="function"==typeof n?n(t):a({},t,{},n)),e},p=function(n){var t=c(n.components);return l.a.createElement(f.Provider,{value:t},n.children)},b="mdxType",d={inlineCode:"code",wrapper:function(n){var t=n.children;return l.a.createElement(l.a.Fragment,{},t)}},g=Object(r.forwardRef)((function(n,t){var e=n.components,r=n.mdxType,o=n.originalType,i=n.parentName,f=s(n,["components","mdxType","originalType","parentName"]),p=c(e),b=r,g=p["".concat(i,".").concat(b)]||p[b]||d[b]||o;return e?l.a.createElement(g,a({ref:t},f,{components:e})):l.a.createElement(g,a({ref:t},f))}));function m(n,t){var e=arguments,r=t&&t.mdxType;if("string"==typeof n||r){var o=e.length,i=new Array(o);i[0]=g;var a={};for(var s in t)hasOwnProperty.call(t,s)&&(a[s]=t[s]);a.originalType=n,a[b]="string"==typeof n?n:r,i[1]=a;for(var f=2;f<o;f++)i[f]=e[f];return l.a.createElement.apply(null,i)}return l.a.createElement.apply(null,e)}g.displayName="MDXCreateElement"}}]);