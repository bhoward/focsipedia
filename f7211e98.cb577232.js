(window.webpackJsonp=window.webpackJsonp||[]).push([[145],{248:function(e,a,t){"use strict";t.r(a),t.d(a,"frontMatter",(function(){return m})),t.d(a,"metadata",(function(){return r})),t.d(a,"rightToc",(function(){return i})),t.d(a,"default",(function(){return p}));var n=t(1),s=t(6),c=(t(0),t(256)),m=(t(258),{id:"lists",title:"Sorting Lists"}),r={id:"ds/lists",isDocsHomePage:!1,title:"Sorting Lists",description:"We have already seen how to work with lists in a functional language.",source:"@site/docs/ds/lists.md",permalink:"/focsipedia/docs/ds/lists",editUrl:"https://github.com/bhoward/focsipedia/edit/master/docs/ds/lists.md",sidebar:"someSidebar",previous:{title:"Lambda Calculus",permalink:"/focsipedia/docs/fp/lambda"},next:{title:"Trees",permalink:"/focsipedia/docs/ds/trees"}},i=[{value:"Insertion Sort",id:"insertion-sort",children:[]},{value:"Selection Sort",id:"selection-sort",children:[]},{value:"Running Time of Insertion and Selection Sort",id:"running-time-of-insertion-and-selection-sort",children:[]},{value:"Merge Sort",id:"merge-sort",children:[]},{value:"Quicksort",id:"quicksort",children:[]},{value:"Exercises",id:"exercises",children:[]}],b={rightToc:i};function p(e){var a=e.components,t=Object(s.a)(e,["components"]);return Object(c.b)("wrapper",Object(n.a)({},b,t,{components:a,mdxType:"MDXLayout"}),Object(c.b)("p",null,"We have already seen ",Object(c.b)("a",Object(n.a)({parentName:"p"},{href:"../fp/map-reduce"}),"how to work with lists in a functional language"),".\nThe focus here will be on functional approaches to sorting lists; for simplicity we will work with lists of integers, although the techniques extend to any type with a total ordering relation."),Object(c.b)("h2",{id:"insertion-sort"},"Insertion Sort"),Object(c.b)("p",null,"One of the simplest methods for sorting a list is based on the ",Object(c.b)("inlineCode",{parentName:"p"},"insert")," function, which adds one element in the correct position within an already sorted list.\nSuppose that ",Object(c.b)("inlineCode",{parentName:"p"},"nums")," is a (possibly empty) list of numbers, arranged in non-decreasing order, and we wish to insert the number ",Object(c.b)("inlineCode",{parentName:"p"},"n"),".\nIf ",Object(c.b)("inlineCode",{parentName:"p"},"nums")," is empty, then the result will just be the list ",Object(c.b)("inlineCode",{parentName:"p"},"[n]"),"; otherwise, split the list into a ",Object(c.b)("inlineCode",{parentName:"p"},"head")," element (which must be the smallest) and a ",Object(c.b)("inlineCode",{parentName:"p"},"tail")," list.\nIf ",Object(c.b)("inlineCode",{parentName:"p"},"n")," is no larger than ",Object(c.b)("inlineCode",{parentName:"p"},"head"),", then ",Object(c.b)("inlineCode",{parentName:"p"},"n")," will be the smallest number overall, and we may insert it in front of ",Object(c.b)("inlineCode",{parentName:"p"},"head"),".\nOn the other hand, if ",Object(c.b)("inlineCode",{parentName:"p"},"n")," is larger than ",Object(c.b)("inlineCode",{parentName:"p"},"head"),", then ",Object(c.b)("inlineCode",{parentName:"p"},"head")," is still the smallest and must come first, while ",Object(c.b)("inlineCode",{parentName:"p"},"n")," must be inserted somewhere in the ",Object(c.b)("inlineCode",{parentName:"p"},"tail"),".\nHowever, inserting ",Object(c.b)("inlineCode",{parentName:"p"},"n")," into the ",Object(c.b)("inlineCode",{parentName:"p"},"tail")," is the same problem we started with (insert a number into a sorted list), except the list is smaller","\u2014","this is exactly the setup we need to make a recursive call to finish the job."),Object(c.b)("p",null,"In code, here is the procedure we just described:"),Object(c.b)("pre",null,Object(c.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"let rec insert = (nums, n) => {\n  switch (nums) {\n  | [] => [n]\n  | [head, ...tail] =>\n    if (n <= head) {\n      [n, ...nums]\n    } else {\n      [head, ...insert(tail, n)]\n    }\n  }\n};\n\ninsert([], 42);\ninsert([63], 42);\ninsert([17, 63], 42);\ninsert([17, 39], 42);\n")),Object(c.b)("p",null,"Once we have the ",Object(c.b)("inlineCode",{parentName:"p"},"insert")," function, it is easy to build a sorting function based on it.\nIf we want to sort an empty list, then we are done.\nOtherwise, we have a non-empty list that may be split (using pattern matching) into a head and a tail.\nRecursively sorting the tail will give us a sorted list, and then we just need to insert the head into it:"),Object(c.b)("pre",null,Object(c.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"let rec insertion_sort = nums => {\n  switch (nums) {\n  | [] => []\n  | [head, ...tail] => insert(insertion_sort(tail), head)\n  }\n};\n\ninsertion_sort([3, 1, 4, 1, 5, 9, 2, 6, 5]);\n")),Object(c.b)("p",null,"Although this is simple, the call to ",Object(c.b)("inlineCode",{parentName:"p"},"insertion_sort")," is not a tail-recursive call","\u2014","that is, the recursive call is not the last thing done, because it still needs to call ",Object(c.b)("inlineCode",{parentName:"p"},"insert")," after the recursion finishes.\nThat can cause problems when the list is large, because each recursive call needs to be saved on the function-call stack and we run the danger of overflowing the stack."),Object(c.b)("p",null,"Another approach is to traverse the list from left to right, building up a sorted list by inserting each successive element (thus the sorted list is an ",Object(c.b)("strong",{parentName:"p"},"accumulator"),"\u2014","an extra argument that collects the result as the calculation proceeds; this is a common trick when making a function tail-recursive). Because the last action of the ",Object(c.b)("inlineCode",{parentName:"p"},"aux")," function in the recursive case is to call itself, this solution is properly tail-recursive and the ReasonML compiler will be able to produce code that doesn't overflow the stack no matter how many numbers we are sorting.",Object(c.b)("sup",Object(n.a)({parentName:"p"},{id:"fnref-1"}),Object(c.b)("a",Object(n.a)({parentName:"sup"},{href:"#fn-1",className:"footnote-ref"}),"1"))),Object(c.b)("pre",null,Object(c.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"let insertion_sort_left = nums => {\n  let rec aux = (sorted, nums) => {\n    switch (nums) {\n    | [] => sorted\n    | [head, ...tail] => aux(insert(sorted, head), tail)\n    }\n  };\n  aux([], nums)\n};\n\ninsertion_sort_left([3, 1, 4, 1, 5, 9, 2, 6, 5]);\n")),Object(c.b)("p",null,"Note that the helper function here (",Object(c.b)("inlineCode",{parentName:"p"},"aux"),") is essentially the same as the ",Object(c.b)("inlineCode",{parentName:"p"},"reduce")," function we saw in the ",Object(c.b)("a",Object(n.a)({parentName:"p"},{href:"../fp/map-reduce"}),"MapReduce")," section.\nThe ReasonML standard library provides the ",Object(c.b)("inlineCode",{parentName:"p"},"reduce")," function under the name ",Object(c.b)("inlineCode",{parentName:"p"},"List.fold_left"),", so we can also define insertion sort as:"),Object(c.b)("pre",null,Object(c.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"let insertion_sort_left2 = nums => {\n  List.fold_left(insert, [], nums)\n};\n\ninsertion_sort_left2([3, 1, 4, 1, 5, 9, 2, 6, 5]);\n")),Object(c.b)("p",null,"Using currying, we can simplify this to ",Object(c.b)("inlineCode",{parentName:"p"},"let insertion_sort_left2 = List.fold_left(insert, [])"),"."),Object(c.b)("h2",{id:"selection-sort"},"Selection Sort"),Object(c.b)("p",null,'Instead of having to go through the list to find the correct insertion point each time we want to add a number to the sorted list, we might try to do more work "up front" and choose the numbers to be added in the correct order.\nThis is the idea behind ',Object(c.b)("strong",{parentName:"p"},"selection sort"),": given a non-empty list of numbers, if we can separate the smallest number from the rest, then that number will definitely be the head of the resulting sorted list and we will never have to adjust its position during the rest of the sorting operation.\nSo, our first goal is to write a ",Object(c.b)("inlineCode",{parentName:"p"},"select")," function that takes a non-empty list and splits it into the smallest element plus a list of all of the other elements."),Object(c.b)("p",null,"We may approach this using recursion: to find the smallest element in the list, first find the smallest element in the tail of the list (if any), then compare it against the head and keep the smaller of the two.\nThe result should be a pair of the smallest element plus a list of all of the other elements.\nThis leads to the following code:"),Object(c.b)("pre",null,Object(c.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"/* Precondition: nums is non-empty */\nlet rec select = nums => {\n  switch (nums) {\n  | [n] => (n, [])\n  | [head, ...tail] => {\n      /* We know that tail is non-empty */\n      let (small, rest) = select(tail);\n      if (head <= small) {\n        (head, tail)\n      } else {\n        (small, [head, ...rest])\n      }\n    }\n  }\n};\n\nselect([42]);\nselect([3, 1, 4, 1, 5, 9, 2, 6, 5]);\n")),Object(c.b)("p",null,"Note that it only makes sense to call ",Object(c.b)("inlineCode",{parentName:"p"},"select")," on a non-empty list, so we must make sure that we satisfy that precondition when making the recursive call.\nReasonML warns us that we are not handling all of the cases with our patterns, but we may ignore the warning here."),Object(c.b)("p",null,"The ",Object(c.b)("inlineCode",{parentName:"p"},"select")," function is not tail-recursive, so again we might look for an alternate way to compute it using an accumulator and a helper function.\nThink of the usual process of searching a list for the smallest element: choose the first element as our initial guess, and then examine each of the rest of the numbers, refining our guess whenever we find a smaller element.\nIf our accumulator is the pair consisting of the smallest element seen so far (our current guess), plus a list of all of the other numbers examined, then we can view the selection process as a left-to-right reduction:"),Object(c.b)("pre",null,Object(c.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"/* Precondition: nums is non-empty */\nlet select_left = nums => {\n  let rec aux = (nums, accum) => {\n    switch (nums) {\n    | [] => accum\n    | [head, ...tail] => {\n        let (small, rest) = accum;\n        if (head < small) {\n          aux(tail, (head, [small, ...rest]))\n        } else {\n          aux(tail, (small, [head, ...rest]))\n        }\n      }\n    }\n  };\n  \n  switch (nums) {\n  | [head, ...tail] => aux(tail, (head, []))\n  }\n};\n\nselect_left([42]);\nselect_left([3, 1, 4, 1, 5, 9, 2, 6, 5]);\n")),Object(c.b)("p",null,"Once we have a selection function, the selection sort is easy to write recursively:"),Object(c.b)("pre",null,Object(c.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"let rec selection_sort = nums => {\n  switch (nums) {\n  | [] => []\n  | _ => {\n      let (small, rest) = select(nums);\n      [small, ...selection_sort(rest)]\n    }\n  }\n};\n\nselection_sort([3, 1, 4, 1, 5, 9, 2, 6, 5]);\n")),Object(c.b)("p",null,"One of the exercises asks you to find a way to write this using tail-recursion."),Object(c.b)("h2",{id:"running-time-of-insertion-and-selection-sort"},"Running Time of Insertion and Selection Sort"),Object(c.b)("p",null,"The ",Object(c.b)("inlineCode",{parentName:"p"},"insert")," and ",Object(c.b)("inlineCode",{parentName:"p"},"select")," functions each make a pass through all of the elements in their list argument, at least in the worst case (insertion will stop early if it finds the correct position, but selection needs to examine the entire list).\nWhen doing an insertion sort, the ",Object(c.b)("inlineCode",{parentName:"p"},"insert")," function is called on successively longer lists, so its running time will be proportional to the sum ",Object(c.b)("span",Object(n.a)({parentName:"p"},{className:"math math-inline"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(c.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(c.b)("semantics",{parentName:"math"},Object(c.b)("mrow",{parentName:"semantics"},Object(c.b)("mn",{parentName:"mrow"},"1"),Object(c.b)("mo",{parentName:"mrow"},"+"),Object(c.b)("mn",{parentName:"mrow"},"2"),Object(c.b)("mo",{parentName:"mrow"},"+"),Object(c.b)("mo",{parentName:"mrow"},"\u2026"),Object(c.b)("mo",{parentName:"mrow"},"+"),Object(c.b)("mi",{parentName:"mrow"},"N")),Object(c.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"1+2+\\ldots+N")))),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.72777em",verticalAlign:"-0.08333em"}})),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),"1"),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2222222222222222em"}})),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mbin"}),"+"),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2222222222222222em"}}))),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.72777em",verticalAlign:"-0.08333em"}})),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),"2"),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2222222222222222em"}})),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mbin"}),"+"),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2222222222222222em"}}))),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.66666em",verticalAlign:"-0.08333em"}})),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"minner"}),"\u2026"),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2222222222222222em"}})),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mbin"}),"+"),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2222222222222222em"}}))),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}})),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault",style:{marginRight:"0.10903em"}}),"N"))))),", where ",Object(c.b)("span",Object(n.a)({parentName:"p"},{className:"math math-inline"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(c.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(c.b)("semantics",{parentName:"math"},Object(c.b)("mrow",{parentName:"semantics"},Object(c.b)("mi",{parentName:"mrow"},"N")),Object(c.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"N")))),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}})),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault",style:{marginRight:"0.10903em"}}),"N")))))," is the size of the list to be sorted. We have seen that this sum is ",Object(c.b)("span",Object(n.a)({parentName:"p"},{className:"math math-inline"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(c.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(c.b)("semantics",{parentName:"math"},Object(c.b)("mrow",{parentName:"semantics"},Object(c.b)("mfrac",{parentName:"mrow"},Object(c.b)("mrow",{parentName:"mfrac"},Object(c.b)("mi",{parentName:"mrow"},"N"),Object(c.b)("mo",Object(n.a)({parentName:"mrow"},{stretchy:"false"}),"("),Object(c.b)("mi",{parentName:"mrow"},"N"),Object(c.b)("mo",{parentName:"mrow"},"+"),Object(c.b)("mn",{parentName:"mrow"},"1"),Object(c.b)("mo",Object(n.a)({parentName:"mrow"},{stretchy:"false"}),")")),Object(c.b)("mn",{parentName:"mfrac"},"2"))),Object(c.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"\\frac{N(N+1)}{2}")))),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"1.355em",verticalAlign:"-0.345em"}})),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mopen nulldelimiter"})),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mfrac"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-t vlist-t2"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-r"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"vlist",style:{height:"1.01em"}}),Object(c.b)("span",Object(n.a)({parentName:"span"},{style:{top:"-2.6550000000000002em"}}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"pstrut",style:{height:"3em"}})),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"sizing reset-size6 size3 mtight"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mord mtight"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mord mtight"}),"2")))),Object(c.b)("span",Object(n.a)({parentName:"span"},{style:{top:"-3.23em"}}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"pstrut",style:{height:"3em"}})),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"frac-line",style:{borderBottomWidth:"0.04em"}}))),Object(c.b)("span",Object(n.a)({parentName:"span"},{style:{top:"-3.485em"}}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"pstrut",style:{height:"3em"}})),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"sizing reset-size6 size3 mtight"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mord mtight"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault mtight",style:{marginRight:"0.10903em"}}),"N"),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mopen mtight"}),"("),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault mtight",style:{marginRight:"0.10903em"}}),"N"),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mbin mtight"}),"+"),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mord mtight"}),"1"),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mclose mtight"}),")"))))),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-s"}),"\u200b")),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-r"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"vlist",style:{height:"0.345em"}}),Object(c.b)("span",{parentName:"span"}))))),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mclose nulldelimiter"}))))))),", which is quadratic in ",Object(c.b)("span",Object(n.a)({parentName:"p"},{className:"math math-inline"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(c.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(c.b)("semantics",{parentName:"math"},Object(c.b)("mrow",{parentName:"semantics"},Object(c.b)("mi",{parentName:"mrow"},"N")),Object(c.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"N")))),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}})),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault",style:{marginRight:"0.10903em"}}),"N")))))," (",Object(c.b)("em",{parentName:"p"},"i.e."),", we say that it is ",Object(c.b)("span",Object(n.a)({parentName:"p"},{className:"math math-inline"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(c.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(c.b)("semantics",{parentName:"math"},Object(c.b)("mrow",{parentName:"semantics"},Object(c.b)("mi",{parentName:"mrow"},"O"),Object(c.b)("mo",Object(n.a)({parentName:"mrow"},{stretchy:"false"}),"("),Object(c.b)("msup",{parentName:"mrow"},Object(c.b)("mi",{parentName:"msup"},"N"),Object(c.b)("mn",{parentName:"msup"},"2")),Object(c.b)("mo",Object(n.a)({parentName:"mrow"},{stretchy:"false"}),")")),Object(c.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"O(N^2)")))),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"1.064108em",verticalAlign:"-0.25em"}})),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault",style:{marginRight:"0.02778em"}}),"O"),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mopen"}),"("),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault",style:{marginRight:"0.10903em"}}),"N"),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"msupsub"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-t"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-r"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"vlist",style:{height:"0.8141079999999999em"}}),Object(c.b)("span",Object(n.a)({parentName:"span"},{style:{top:"-3.063em",marginRight:"0.05em"}}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"pstrut",style:{height:"2.7em"}})),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"sizing reset-size6 size3 mtight"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mord mtight"}),"2")))))))),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mclose"}),")"))))),"). Similarly, when doing a selection sort, the ",Object(c.b)("inlineCode",{parentName:"p"},"select")," function is initially called on a list of size ",Object(c.b)("span",Object(n.a)({parentName:"p"},{className:"math math-inline"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(c.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(c.b)("semantics",{parentName:"math"},Object(c.b)("mrow",{parentName:"semantics"},Object(c.b)("mi",{parentName:"mrow"},"N")),Object(c.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"N")))),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}})),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault",style:{marginRight:"0.10903em"}}),"N"))))),", and then on successively smaller lists: ",Object(c.b)("span",Object(n.a)({parentName:"p"},{className:"math math-inline"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(c.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(c.b)("semantics",{parentName:"math"},Object(c.b)("mrow",{parentName:"semantics"},Object(c.b)("mi",{parentName:"mrow"},"N"),Object(c.b)("mo",{parentName:"mrow"},"+"),Object(c.b)("mo",Object(n.a)({parentName:"mrow"},{stretchy:"false"}),"("),Object(c.b)("mi",{parentName:"mrow"},"N"),Object(c.b)("mo",{parentName:"mrow"},"\u2212"),Object(c.b)("mn",{parentName:"mrow"},"1"),Object(c.b)("mo",Object(n.a)({parentName:"mrow"},{stretchy:"false"}),")"),Object(c.b)("mo",{parentName:"mrow"},"+"),Object(c.b)("mo",{parentName:"mrow"},"\u2026"),Object(c.b)("mo",{parentName:"mrow"},"+"),Object(c.b)("mn",{parentName:"mrow"},"2"),Object(c.b)("mo",{parentName:"mrow"},"+"),Object(c.b)("mn",{parentName:"mrow"},"1")),Object(c.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"N+(N-1)+\\ldots+2+1")))),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.76666em",verticalAlign:"-0.08333em"}})),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault",style:{marginRight:"0.10903em"}}),"N"),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2222222222222222em"}})),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mbin"}),"+"),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2222222222222222em"}}))),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}})),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mopen"}),"("),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault",style:{marginRight:"0.10903em"}}),"N"),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2222222222222222em"}})),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mbin"}),"\u2212"),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2222222222222222em"}}))),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}})),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),"1"),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mclose"}),")"),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2222222222222222em"}})),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mbin"}),"+"),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2222222222222222em"}}))),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.66666em",verticalAlign:"-0.08333em"}})),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"minner"}),"\u2026"),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2222222222222222em"}})),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mbin"}),"+"),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2222222222222222em"}}))),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.72777em",verticalAlign:"-0.08333em"}})),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),"2"),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2222222222222222em"}})),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mbin"}),"+"),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2222222222222222em"}}))),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.64444em",verticalAlign:"0em"}})),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),"1"))))),", which is the same sum in reverse."),Object(c.b)("p",null,"Therefore, the worst-case running time of both sorting algorithms is ",Object(c.b)("span",Object(n.a)({parentName:"p"},{className:"math math-inline"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(c.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(c.b)("semantics",{parentName:"math"},Object(c.b)("mrow",{parentName:"semantics"},Object(c.b)("mi",{parentName:"mrow"},"O"),Object(c.b)("mo",Object(n.a)({parentName:"mrow"},{stretchy:"false"}),"("),Object(c.b)("msup",{parentName:"mrow"},Object(c.b)("mi",{parentName:"msup"},"N"),Object(c.b)("mn",{parentName:"msup"},"2")),Object(c.b)("mo",Object(n.a)({parentName:"mrow"},{stretchy:"false"}),")")),Object(c.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"O(N^2)")))),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"1.064108em",verticalAlign:"-0.25em"}})),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault",style:{marginRight:"0.02778em"}}),"O"),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mopen"}),"("),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault",style:{marginRight:"0.10903em"}}),"N"),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"msupsub"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-t"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-r"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"vlist",style:{height:"0.8141079999999999em"}}),Object(c.b)("span",Object(n.a)({parentName:"span"},{style:{top:"-3.063em",marginRight:"0.05em"}}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"pstrut",style:{height:"2.7em"}})),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"sizing reset-size6 size3 mtight"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mord mtight"}),"2")))))))),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mclose"}),")"))))),", and they are known as ",Object(c.b)("strong",{parentName:"p"},"quadratic sorts"),". The average case for insertion sort might seem to be better, because on average the insertion process will only have to traverse half of the list to find the correct insertion point (as long as the input is random).\nHowever, that gives us a running time proportional to ",Object(c.b)("span",Object(n.a)({parentName:"p"},{className:"math math-inline"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(c.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(c.b)("semantics",{parentName:"math"},Object(c.b)("mrow",{parentName:"semantics"},Object(c.b)("mfrac",{parentName:"mrow"},Object(c.b)("mn",{parentName:"mfrac"},"1"),Object(c.b)("mn",{parentName:"mfrac"},"4")),Object(c.b)("msup",{parentName:"mrow"},Object(c.b)("mi",{parentName:"msup"},"N"),Object(c.b)("mn",{parentName:"msup"},"2"))),Object(c.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"\\frac{1}{4}N^2")))),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"1.190108em",verticalAlign:"-0.345em"}})),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mopen nulldelimiter"})),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mfrac"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-t vlist-t2"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-r"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"vlist",style:{height:"0.845108em"}}),Object(c.b)("span",Object(n.a)({parentName:"span"},{style:{top:"-2.6550000000000002em"}}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"pstrut",style:{height:"3em"}})),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"sizing reset-size6 size3 mtight"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mord mtight"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mord mtight"}),"4")))),Object(c.b)("span",Object(n.a)({parentName:"span"},{style:{top:"-3.23em"}}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"pstrut",style:{height:"3em"}})),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"frac-line",style:{borderBottomWidth:"0.04em"}}))),Object(c.b)("span",Object(n.a)({parentName:"span"},{style:{top:"-3.394em"}}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"pstrut",style:{height:"3em"}})),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"sizing reset-size6 size3 mtight"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mord mtight"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mord mtight"}),"1"))))),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-s"}),"\u200b")),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-r"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"vlist",style:{height:"0.345em"}}),Object(c.b)("span",{parentName:"span"}))))),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mclose nulldelimiter"}))),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault",style:{marginRight:"0.10903em"}}),"N"),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"msupsub"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-t"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-r"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"vlist",style:{height:"0.8141079999999999em"}}),Object(c.b)("span",Object(n.a)({parentName:"span"},{style:{top:"-3.063em",marginRight:"0.05em"}}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"pstrut",style:{height:"2.7em"}})),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"sizing reset-size6 size3 mtight"}),Object(c.b)("span",Object(n.a)({parentName:"span"},{className:"mord mtight"}),"2")))))))))))),", which is still quadratic.\nFor lists with millions of items, a quadratic sort will perform trillions of operations, which might be too long to wait (even at a billion operations per second, that could easily take on the order of an hour).\nSo, we might wonder if there is a faster approach to such a fundamental operation as sorting."),Object(c.b)("h2",{id:"merge-sort"},"Merge Sort"),Object(c.b)("h2",{id:"quicksort"},"Quicksort"),Object(c.b)("h2",{id:"exercises"},"Exercises"),Object(c.b)("ol",null,Object(c.b)("li",{parentName:"ol"},Object(c.b)("p",{parentName:"li"},"Rewrite the ",Object(c.b)("inlineCode",{parentName:"p"},"select_left")," function as an application of ",Object(c.b)("inlineCode",{parentName:"p"},"List.fold_left")," to an appropriate reduction function. When ",Object(c.b)("inlineCode",{parentName:"p"},"select_left(nums)")," is called on a non-empty list ",Object(c.b)("inlineCode",{parentName:"p"},"nums"),", the initial value passed into the reduction should be the pair ",Object(c.b)("inlineCode",{parentName:"p"},"(head, [])"),", representing the initial guess that the head of ",Object(c.b)("inlineCode",{parentName:"p"},"nums")," is the smallest number, with an empty list of other numbers examined so far."),Object(c.b)("details",Object(n.a)({parentName:"li"},{className:"custom-block spoiler-block"}),Object(c.b)("summary",Object(n.a)({parentName:"details"},{className:"custom-block-heading"}),"Answer"),Object(c.b)("div",Object(n.a)({parentName:"details"},{className:"custom-block-body"}),Object(c.b)("pre",{parentName:"div"},Object(c.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reason"}),"let select_left2 = nums => {\n  let aux = ((small, rest), n) => {\n    if (n < small) {\n      (n, [small, ...rest])\n    } else {\n      (small, [n, ...rest])\n    }\n  };\n  switch (nums) {\n  | [head, ...tail] => List.fold_left(aux, (head, []), tail)\n  }\n};\n"))))),Object(c.b)("li",{parentName:"ol"},Object(c.b)("p",{parentName:"li"},"Find a way to write the selection sort algorithm using only tail-recursive functions. ",Object(c.b)("em",{parentName:"p"},"Hint: Instead of selecting the smallest element, modify ",Object(c.b)("inlineCode",{parentName:"em"},"select_left")," to separate out the largest element, then write a sorting function that accumulates the sorted list from back to front.")),Object(c.b)("details",Object(n.a)({parentName:"li"},{className:"custom-block spoiler-block"}),Object(c.b)("summary",Object(n.a)({parentName:"details"},{className:"custom-block-heading"}),"Answer"),Object(c.b)("div",Object(n.a)({parentName:"details"},{className:"custom-block-body"}),Object(c.b)("pre",{parentName:"div"},Object(c.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reason"}),"/* Precondition: nums is non-empty */\nlet select_max_left = nums => {\n  let rec aux = (nums, accum) => {\n    switch (nums) {\n    | [] => accum\n    | [head, ...tail] => {\n        let (large, rest) = accum;\n        if (head > large) {\n          aux(tail, (head, [large, ...rest]))\n        } else {\n          aux(tail, (large, [head, ...rest]))\n        }\n      }\n    }\n  };\n  \n  switch (nums) {\n  | [head, ...tail] => aux(tail, (head, []))\n  }\n};\n\nlet ssort = nums => {\n  let rec aux = (nums, sorted) => {\n    switch (nums) {\n    | [] => sorted\n    | _ => {\n        let (large, rest) = select_max_left(nums);\n                aux(rest, [large, ...sorted])\n          }\n    }\n    };\n  aux(nums, [])\n};\n")))))),Object(c.b)("div",{className:"footnotes"},Object(c.b)("hr",{parentName:"div"}),Object(c.b)("ol",{parentName:"div"},Object(c.b)("li",Object(n.a)({parentName:"ol"},{id:"fn-1"}),"In fact, when the compiler sees a tail-recursive call, it can essentially turn the recursive call into a loop back up to the top of the function, without needing to push a new function call on the stack. It is able to do this because it knows there is nothing left to do in the original call, so there is no need to return to where we left off.",Object(c.b)("a",Object(n.a)({parentName:"li"},{href:"#fnref-1",className:"footnote-backref"}),"\u21a9")))))}p.isMDXComponent=!0},256:function(e,a,t){"use strict";t.d(a,"a",(function(){return l})),t.d(a,"b",(function(){return j}));var n=t(0),s=t.n(n);function c(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function m(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function r(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?m(Object(t),!0).forEach((function(a){c(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):m(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function i(e,a){if(null==e)return{};var t,n,s=function(e,a){if(null==e)return{};var t,n,s={},c=Object.keys(e);for(n=0;n<c.length;n++)t=c[n],a.indexOf(t)>=0||(s[t]=e[t]);return s}(e,a);if(Object.getOwnPropertySymbols){var c=Object.getOwnPropertySymbols(e);for(n=0;n<c.length;n++)t=c[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var b=s.a.createContext({}),p=function(e){var a=s.a.useContext(b),t=a;return e&&(t="function"==typeof e?e(a):r({},a,{},e)),t},l=function(e){var a=p(e.components);return s.a.createElement(b.Provider,{value:a},e.children)},o={inlineCode:"code",wrapper:function(e){var a=e.children;return s.a.createElement(s.a.Fragment,{},a)}},O=Object(n.forwardRef)((function(e,a){var t=e.components,n=e.mdxType,c=e.originalType,m=e.parentName,b=i(e,["components","mdxType","originalType","parentName"]),l=p(t),O=n,j=l["".concat(m,".").concat(O)]||l[O]||o[O]||c;return t?s.a.createElement(j,r({ref:a},b,{components:t})):s.a.createElement(j,r({ref:a},b))}));function j(e,a){var t=arguments,n=a&&a.mdxType;if("string"==typeof e||n){var c=t.length,m=new Array(c);m[0]=O;var r={};for(var i in a)hasOwnProperty.call(a,i)&&(r[i]=a[i]);r.originalType=e,r.mdxType="string"==typeof e?e:n,m[1]=r;for(var b=2;b<c;b++)m[b]=t[b];return s.a.createElement.apply(null,m)}return s.a.createElement.apply(null,t)}O.displayName="MDXCreateElement"},257:function(e,a,t){"use strict";var n=t(0),s=t(35);a.a=function(){return Object(n.useContext)(s.a)}},258:function(e,a,t){"use strict";t.d(a,"a",(function(){return c}));var n=t(257),s=t(259);function c(e,{forcePrependBaseUrl:a=!1,absolute:t=!1}={}){const{siteConfig:{baseUrl:c="/",url:m}={}}=Object(n.a)();if(!e)return e;if(a)return c+e;if(!Object(s.a)(e))return e;const r=c+e.replace(/^\//,"");return t?m+r:r}},259:function(e,a,t){"use strict";function n(e){return!1===/^(https?:|\/\/|mailto:|tel:)/.test(e)}t.d(a,"a",(function(){return n}))}}]);