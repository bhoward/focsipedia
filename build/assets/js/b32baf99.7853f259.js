"use strict";(self.webpackChunkfocsipedia=self.webpackChunkfocsipedia||[]).push([[5281],{5311:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>r,contentTitle:()=>a,default:()=>l,frontMatter:()=>o,metadata:()=>c,toc:()=>d});var t=s(4848),i=s(8453);const o={id:"methods",title:"Methods in Scala"},a=void 0,c={id:"methods",title:"Methods in Scala",description:"You may be wondering why the section on functions in Java and Scala",source:"@site/focsipedia-docs/target/mdoc/methods.md",sourceDirName:".",slug:"/methods",permalink:"/focsipedia/docs/methods",draft:!1,unlisted:!1,editUrl:"https://github.com/bhoward/focsipedia/tree/master/focsipedia-docs/target/mdoc/methods.md",tags:[],version:"current",frontMatter:{id:"methods",title:"Methods in Scala"},sidebar:"mySidebar",previous:{title:"Overview of Functional Programming",permalink:"/focsipedia/docs/fp/overview"},next:{title:"Currying",permalink:"/focsipedia/docs/fp/curry"}},r={},d=[{value:"Operators as Methods",id:"operators-as-methods",level:2}];function h(e){const n={a:"a",code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",section:"section",strong:"strong",sup:"sup",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["You may be wondering why the section on ",(0,t.jsx)(n.a,{href:"/focsipedia/docs/fp/intro",children:"functions"}),' in Java and Scala\noccasionally uses the word "method" instead of "function."']}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.strong,{children:"method"})," is a special kind of function in object-oriented programming that is definined\nin the context of a ",(0,t.jsx)(n.strong,{children:"class"})," of objects.\nIn a method call such as ",(0,t.jsx)(n.code,{children:"a.m(b, c)"}),", the ",(0,t.jsx)(n.strong,{children:"receiver"})," of the method call\u2014that is,\nthe object before the dot, ",(0,t.jsx)(n.em,{children:"a"}),"\u2014\nis used to select which implementation of the method to use.\nDifferent classes of objects may implement methods in different ways, and the ",(0,t.jsx)(n.strong,{children:"sender"}),"\nof the method call relies on the object to know the correct implementation (that is, the\ndecision is ",(0,t.jsx)(n.strong,{children:"object-oriented"}),")."]}),"\n",(0,t.jsxs)(n.p,{children:["The method call ",(0,t.jsx)(n.code,{children:"a.m(b, c)"})," effectively turns into a call to the function ",(0,t.jsx)(n.code,{children:"f(a, b, c)"}),",\nwhere ",(0,t.jsx)(n.em,{children:"f"})," is the implementation of method ",(0,t.jsx)(n.em,{children:"m"})," suitable for object ",(0,t.jsx)(n.em,{children:"a"}),".\nThe receiver ",(0,t.jsx)(n.em,{children:"a"})," is passed in as an extra argument\nto ",(0,t.jsx)(n.em,{children:"f"})," and is typically accessed through a special keyword such as ",(0,t.jsx)(n.em,{children:"this"})," or ",(0,t.jsx)(n.em,{children:"self"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Here is an example in Scala of defining two classes of shapes, ",(0,t.jsx)(n.em,{children:"Circle"})," and ",(0,t.jsx)(n.em,{children:"Square"}),",\nwhich each define a method ",(0,t.jsx)(n.em,{children:"area"})," (with no parameters).\nTo express that they both implement this method, we also define a ",(0,t.jsx)(n.strong,{children:"trait"})," (similar to\na Java interface) that declares this fact:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"trait Shape:\n  def area: Double\n\nclass Circle(val radius: Double) extends Shape:\n  def area: Double = math.Pi * radius * radius\n\nclass Square(val side: Double) extends Shape:\n  def area: Double = side * side\n\nval s = Circle(1.0)\n// s: Circle = repl.MdocSession$MdocApp$Circle@79111bae\nprintln(s.area)\n// 3.141592653589793\n"})}),"\n",(0,t.jsxs)(n.p,{children:["When we call ",(0,t.jsx)(n.code,{children:"s.area"}),", the compiler generates code to look up the ",(0,t.jsx)(n.em,{children:"area"})," method in the class\nof ",(0,t.jsx)(n.em,{children:"s"})," (which will be ",(0,t.jsx)(n.em,{children:"Circle"})," in this example), and then call that method with ",(0,t.jsx)(n.em,{children:"s"})," passed in\nas the ",(0,t.jsx)(n.code,{children:"this"})," object.\nThe ",(0,t.jsx)(n.em,{children:"Circle"})," version of ",(0,t.jsx)(n.em,{children:"area"})," takes that hidden ",(0,t.jsx)(n.code,{children:"this"})," object and uses it to look up the\nfield ",(0,t.jsx)(n.em,{children:"radius"})," of object ",(0,t.jsx)(n.em,{children:"s"})," when it is computing the expression ",(0,t.jsx)(n.code,{children:"math.Pi * radius * radius"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"operators-as-methods",children:"Operators as Methods"}),"\n",(0,t.jsxs)(n.p,{children:["An interesting fact about Scala is that the operators, such as ",(0,t.jsx)(n.code,{children:"+"}),", ",(0,t.jsx)(n.code,{children:"*"}),", and ",(0,t.jsx)(n.code,{children:"=="}),",\nare actually methods of their left-hand operand. That is, ",(0,t.jsx)(n.code,{children:"x + y"})," is equivalent to\n",(0,t.jsx)(n.code,{children:"x.+(y)"}),", and a compound expression such as ",(0,t.jsx)(n.code,{children:"a + b * c"})," becomes ",(0,t.jsx)(n.code,{children:"a.+(b.*(c))"})," (note\nthat this takes into account the usual higher precedence of multiplication over addition)."]}),"\n",(0,t.jsxs)(n.p,{children:["In Scala, it is possible to define new methods (including operators) on existing types,\nsuch as ",(0,t.jsx)(n.code,{children:"Int"}),", through ",(0,t.jsx)(n.strong,{children:"extension methods"}),".\nFor example, if we wanted to define an exponentiation operator on ",(0,t.jsx)(n.code,{children:"Int"}),", and\ncall it ",(0,t.jsx)(n.code,{children:"***"}),", we could define it as follows:",(0,t.jsx)(n.sup,{children:(0,t.jsx)(n.a,{href:"#user-content-fn-1",id:"user-content-fnref-1","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"extension (n: Int)\n  def ***(p: Int): Int = {\n    if p == 0 then\n      1\n    else if p % 2 == 0 then\n      (n * n) *** (p / 2)\n    else\n      n * (n *** (p - 1))\n  }\nprintln(2 *** 3)\n// 8\n"})}),"\n",(0,t.jsxs)(n.p,{children:["(The first line identifies this method as a new implementation to be used when the\nreceiver of the ",(0,t.jsx)(n.code,{children:"***(p)"})," method is an ",(0,t.jsx)(n.code,{children:"Int"}),"; the receiver is given the explicit name ",(0,t.jsx)(n.em,{children:"n"}),".)"]}),"\n","\n",(0,t.jsxs)(n.section,{"data-footnotes":!0,className:"footnotes",children:[(0,t.jsx)(n.h2,{className:"sr-only",id:"footnote-label",children:"Footnotes"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{id:"user-content-fn-1",children:["\n",(0,t.jsxs)(n.p,{children:["The code here is based on the solution to an exercise in the ",(0,t.jsx)(n.a,{href:"/focsipedia/docs/logic/recursion",children:"Recursion"})," section.] ",(0,t.jsx)(n.a,{href:"#user-content-fnref-1","data-footnote-backref":"","aria-label":"Back to reference 1",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n"]}),"\n"]})]})}function l(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>c});var t=s(6540);const i={},o=t.createContext(i);function a(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);