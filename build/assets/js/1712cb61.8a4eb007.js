"use strict";(self.webpackChunkfocsipedia=self.webpackChunkfocsipedia||[]).push([[6306],{325:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>o});var s=a(4848),t=a(8453);const i={id:"types",title:"Types in Functional Programming"},r=void 0,l={id:"fp/types",title:"Types in Functional Programming",description:"One of the hallmarks of modern functional programming is a strong and rich",source:"@site/focsipedia-docs/target/mdoc/fp/types.md",sourceDirName:"fp",slug:"/fp/types",permalink:"/focsipedia/docs/fp/types",draft:!1,unlisted:!1,editUrl:"https://github.com/bhoward/focsipedia/tree/master/focsipedia-docs/target/mdoc/fp/types.md",tags:[],version:"current",frontMatter:{id:"types",title:"Types in Functional Programming"},sidebar:"mySidebar",previous:{title:"Introduction to Functional Programming",permalink:"/focsipedia/docs/fp/intro"},next:{title:"Map and Reduce on Lists",permalink:"/focsipedia/docs/fp/map-reduce"}},c={},o=[{value:"Functions",id:"functions",level:2},{value:"Type Inference",id:"type-inference",level:2},{value:"Tuples",id:"tuples",level:2},{value:"Type Aliases and Parameterized Types",id:"type-aliases-and-parameterized-types",level:2},{value:"Constructors and Variants",id:"constructors-and-variants",level:2},{value:"Enumerations",id:"enumerations",level:3},{value:"Algebraic Data Types",id:"algebraic-data-types",level:3},{value:"Pattern Matching",id:"pattern-matching",level:3},{value:"Recursive Types",id:"recursive-types",level:3},{value:"Exercises",id:"exercises",level:2}];function h(e){const n={a:"a",admonition:"admonition",annotation:"annotation",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",mtext:"mtext",ol:"ol",p:"p",pre:"pre",section:"section",semantics:"semantics",span:"span",strong:"strong",sup:"sup",...(0,t.R)(),...e.components},{Details:a}=n;return a||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"One of the hallmarks of modern functional programming is a strong and rich\nsystems of types. The type of an expression can be thought of as the set of all\nvalues that the expression might have; by specifying the type of a parameter to\na function, it constrains the values that may be provided as input. In this\nsense, the type of a function is then a form of contract: if the input satisfies\nsome condition (is a value in the parameter type), then the output is also\nguaranteed to satisfy a condition (be a value of the result type)."}),"\n",(0,s.jsx)(n.h2,{id:"functions",children:"Functions"}),"\n",(0,s.jsxs)(n.p,{children:["In Scala we write the type of functions from ",(0,s.jsx)(n.code,{children:"A"})," to ",(0,s.jsx)(n.code,{children:"B"})," as ",(0,s.jsx)(n.code,{children:"A => B"}),". Given a\nfunction ",(0,s.jsx)(n.code,{children:"f"})," of that type, if ",(0,s.jsx)(n.code,{children:"x"})," is a value (or more generally any expression)\nof type ",(0,s.jsx)(n.code,{children:"A"}),", then the ",(0,s.jsx)(n.strong,{children:"application"})," ",(0,s.jsx)(n.code,{children:"f(x)"})," will give us a result of type ",(0,s.jsx)(n.code,{children:"B"}),".\nThe value ",(0,s.jsx)(n.code,{children:"x"})," to which we apply the function is known as the ",(0,s.jsx)(n.strong,{children:"argument"}),".\nFor example, ",(0,s.jsx)(n.code,{children:"String.valueOf"})," is a function of type ",(0,s.jsx)(n.code,{children:"Int => String"}),"; when we\napply it to an integer, it returns the string of digits representing the argument:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'String.valueOf(42);\n// res0: String = "42"\n'})}),"\n",(0,s.jsx)(n.p,{children:"Since functions are first-class values, we may bind a function to another name:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'val f: Int => String = String.valueOf\n// f: Function1[Int, String] = repl.MdocSession$MdocApp$$Lambda/0x0000000803ba06e8@1aab85a\nf(42)\n// res1: String = "42"\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The type annotation after ",(0,s.jsx)(n.code,{children:"f"})," is required here, because there are several overloaded\nfunctions named ",(0,s.jsx)(n.code,{children:"String.valueOf"}),", each taking a different type of argument (",(0,s.jsx)(n.code,{children:"Int"}),",\n",(0,s.jsx)(n.code,{children:"Double"}),", ",(0,s.jsx)(n.code,{children:"Boolean"}),", \u2026), and we need to select the one for ",(0,s.jsx)(n.code,{children:"Int"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["To create a function value, we use the double arrow to show that we are taking\na parameter, for example ",(0,s.jsx)(n.code,{children:"p"}),", and using it to compute a result:\n",(0,s.jsx)(n.code,{children:"p => expression"}),".\nThe parameter may optionally be followed by a type: ",(0,s.jsx)(n.code,{children:"(p: T) => expression"}),'; we will\nsee that in many cases Scala can infer this type, but sometimes it is needed to resolve\nambiguity.\nThe parameter may be any variable name\u2014it\nwill represent the value of the argument just within the\nresult expression. That is, if the variable name had been used outside the function,\nit will be temporarily "shadowed" by the new binding; when the function has returned\nits result, the local binding to the argument goes away.']}),"\n",(0,s.jsx)(n.p,{children:"Consider the following example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"val x = 5\n// x: Int = 5\nval f = (x: Int) => x + 12\n// f: Function1[Int, Int] = repl.MdocSession$MdocApp2$$Lambda/0x0000000803ba1438@62eb6fe0\nf(x * x) + x\n// res3: Int = 42\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The value bound to the first ",(0,s.jsx)(n.code,{children:"x"})," is the integer 5.\nWhen ",(0,s.jsx)(n.code,{children:"f"})," is applied to its argument,\nwhich is ",(0,s.jsx)(n.code,{children:"x * x"}),", or 25, we will temporarily bind 25 to a new, local variable\nnamed ",(0,s.jsx)(n.code,{children:"x"})," and evaluate the body of the function: ",(0,s.jsx)(n.code,{children:"x + 12"}),", which gives 37.\nAfter this, the temporary binding of 25 to ",(0,s.jsx)(n.code,{children:"x"})," is forgotten.\nContinuing to evaluate the expression ",(0,s.jsx)(n.code,{children:"f(x * x) + x"}),", we now have ",(0,s.jsx)(n.code,{children:"37 + x"}),";\nsince ",(0,s.jsx)(n.code,{children:"x"})," here refers to the original binding, this is ",(0,s.jsx)(n.code,{children:"37 + 5"}),", so it produces\nthe final answer 42."]}),"\n",(0,s.jsx)(n.h2,{id:"type-inference",children:"Type Inference"}),"\n",(0,s.jsxs)(n.p,{children:["Scala does not require that we specify the types of variables most of the\ntime, because it can usually infer what types they should have from the context\nand how they are used. Looking at the example above, since 5 is an int, we know\nthat ",(0,s.jsx)(n.code,{children:"x"})," must have type ",(0,s.jsx)(n.code,{children:"int"}),". In the second line, we must declare the type ",(0,s.jsx)(n.code,{children:"Int"})," for\nthe parameter ",(0,s.jsx)(n.code,{children:"x"}),", because we do not know the expected type of the function ",(0,s.jsx)(n.code,{children:"f"}),".\nThe result of the function body will be an ",(0,s.jsx)(n.code,{children:"Int"}),", so we now know\nthe type of ",(0,s.jsx)(n.code,{children:"f"})," is ",(0,s.jsx)(n.code,{children:"Int => Int"}),". Finally, the application of ",(0,s.jsx)(n.code,{children:"f"})," in the third line\nchecks out, because it is applied to an integer argument (",(0,s.jsx)(n.code,{children:"x * x"}),"), and its result\nis used in a further integer addition. We could be explicit about the types and\nadd a ",(0,s.jsx)(n.strong,{children:"type annotation"})," to each of the bindings:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"val x: Int = 5\n// x: Int = 5\nval f: Int => Int = (x: Int) => x + 12\n// f: Function1[Int, Int] = repl.MdocSession$MdocApp4$$Lambda/0x0000000803ba2218@36791a8d\nval y: Int = f(x * x) + x\n// y: Int = 42\n"})}),"\n",(0,s.jsx)(n.p,{children:"However, the convention in Scala is that, apart from function signatures, type\nannotations are not generally used except as documentation and as a check that\nthe compiler is doing what we think it is."}),"\n",(0,s.jsx)(n.admonition,{title:"Additional Reading",type:"tip",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"/focsipedia/docs/fp/curry",children:"Currying"})," is an interesting operation on functions, although we will not\nbe needing it in this course."]})}),"\n",(0,s.jsx)(n.h2,{id:"tuples",children:"Tuples"}),"\n",(0,s.jsxs)(n.p,{children:["Perhaps the most basic form of data structure is the ",(0,s.jsx)(n.strong,{children:"tuple"}),". We have already\nseen this in the context of\n",(0,s.jsx)(n.a,{href:"/focsipedia/docs/sets/functions#pairs",children:"sets and cartesian products"}),": an ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsx)(n.mrow,{children:(0,s.jsx)(n.mi,{children:"n"})}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"n"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"n"})]})})]}),"-tuple is simply\nan ordered listing of ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsx)(n.mrow,{children:(0,s.jsx)(n.mi,{children:"n"})}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"n"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"n"})]})})]})," values, traditionally shown in parentheses separated\nby commas. The Scala syntax for a tuple type is likewise an ordered listing\nof each value's type, in parentheses and separated by commas. For example, the\ntuple ",(0,s.jsx)(n.code,{children:'(42, "hello", math.Pi)'})," has type ",(0,s.jsx)(n.code,{children:"(Int, String, Double)"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'val demo: (Int, String, Double) = (42, "hello", math.Pi);\n// demo: Tuple3[Int, String, Double] = (42, "hello", 3.141592653589793)\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In the case ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsxs)(n.mrow,{children:[(0,s.jsx)(n.mi,{children:"n"}),(0,s.jsx)(n.mo,{children:"="}),(0,s.jsx)(n.mn,{children:"2"})]}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"n=2"})]})})}),(0,s.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"n"}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,s.jsx)(n.span,{className:"mrel",children:"="}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,s.jsx)(n.span,{className:"mord",children:"2"})]})]})]}),", a tuple is just the familiar ",(0,s.jsx)(n.strong,{children:"pair"}),". For example, the type\nof two-dimensional points with integer coordinates is ",(0,s.jsx)(n.code,{children:"(Int, Int)"}),". Pairs come\nwith accessor methods named ",(0,s.jsx)(n.code,{children:"_1"})," and ",(0,s.jsx)(n.code,{children:"_2"})," to access the first and second\ncoordinates, respectively:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"val p = (5, 10)\n// p: Tuple2[Int, Int] = (5, 10)\nval x = p._1\n// x: Int = 5\nval y = p._2\n// y: Int = 10\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The standard library provides similar accessor functions for ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsx)(n.mrow,{children:(0,s.jsx)(n.mi,{children:"n"})}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"n"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"n"})]})})]}),"-tuples up to ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsxs)(n.mrow,{children:[(0,s.jsx)(n.mi,{children:"n"}),(0,s.jsx)(n.mo,{children:"="}),(0,s.jsx)(n.mn,{children:"22"})]}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"n=22"})]})})}),(0,s.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"n"}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,s.jsx)(n.span,{className:"mrel",children:"="}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,s.jsx)(n.span,{className:"mord",children:"22"})]})]})]}),".",(0,s.jsx)(n.sup,{children:(0,s.jsx)(n.a,{href:"#user-content-fn-1",id:"user-content-fnref-1","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})})]}),"\n",(0,s.jsxs)(n.p,{children:["However, it is frequently more convenient to retrieve\nthe components of a tuple through an extension of the binding operation, ",(0,s.jsx)(n.code,{children:"val"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'val demo = (42, "hello", math.Pi) /* construct a tuple */\n// demo: Tuple3[Int, String, Double] = (42, "hello", 3.141592653589793)\nval (a, b, c) = demo             /* "destruct" a tuple */\n// a: Int = 42\n// b: String = "hello"\n// c: Double = 3.141592653589793\n'})}),"\n",(0,s.jsxs)(n.p,{children:["If we only want to extract some of the components, the other positions may be\nfilled with a place-holder, the so-called ",(0,s.jsx)(n.strong,{children:"wildcard"})," identifier, ",(0,s.jsx)(n.code,{children:"_"}),"\n(underscore):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'val demo = (42, "hello", math.Pi)\n// demo: Tuple3[Int, String, Double] = (42, "hello", 3.141592653589793)\nval (_, greeting, _) = demo\n// greeting: String = "hello"\n'})}),"\n",(0,s.jsxs)(n.p,{children:["An ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsx)(n.mrow,{children:(0,s.jsx)(n.mi,{children:"n"})}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"n"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"n"})]})})]}),"-tuple when ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsxs)(n.mrow,{children:[(0,s.jsx)(n.mi,{children:"n"}),(0,s.jsx)(n.mo,{children:"="}),(0,s.jsx)(n.mn,{children:"1"})]}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"n=1"})]})})}),(0,s.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"n"}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,s.jsx)(n.span,{className:"mrel",children:"="}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,s.jsx)(n.span,{className:"mord",children:"1"})]})]})]})," is just an ordinary value (which may be enclosed in\nparentheses as usual, for grouping purposes). However, the case when\n",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsxs)(n.mrow,{children:[(0,s.jsx)(n.mi,{children:"n"}),(0,s.jsx)(n.mo,{children:"="}),(0,s.jsx)(n.mn,{children:"0"})]}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"n=0"})]})})}),(0,s.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"n"}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,s.jsx)(n.span,{className:"mrel",children:"="}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,s.jsx)(n.span,{className:"mord",children:"0"})]})]})]})," is more interesting: the only value is the empty tuple, ",(0,s.jsx)(n.code,{children:"()"}),", and its type\nis named ",(0,s.jsx)(n.code,{children:"Unit"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"val a: Unit = ()\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Since there is only one value of type ",(0,s.jsx)(n.code,{children:"Unit"}),", it carries no information. We\nwill use it when we need to specify a type but its value does not matter. For\nexample, look at the type of the ",(0,s.jsx)(n.code,{children:"println"})," function in Scala (it is heavily\noverloaded, so we are using a type annotation here to select one implementation):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"val f: Int => Unit = println\n// f: Function1[Int, Unit] = repl.MdocSession$MdocApp8$$Lambda/0x0000000803ba6898@3959eacc\n"})}),"\n",(0,s.jsxs)(n.p,{children:["It returns a value of type ",(0,s.jsx)(n.code,{children:"Unit"})," because there is nothing to be\nreturned. In fact, this is a strong hint that this function does its work via\nside-effects (albeit the relatively benign side-effect of sending some\ncharacters to the console)."]}),"\n",(0,s.jsx)(n.h2,{id:"type-aliases-and-parameterized-types",children:"Type Aliases and Parameterized Types"}),"\n",(0,s.jsxs)(n.p,{children:["Given the importance of types, and potentially complicated type expressions, in\nScala, it should not be a surprise that they can be named and manipulated\nmuch like ordinary values with variables and functions.",(0,s.jsx)(n.sup,{children:(0,s.jsx)(n.a,{href:"#user-content-fn-2",id:"user-content-fnref-2","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"2"})}),"\nWe give a name to a type with the ",(0,s.jsx)(n.code,{children:"type"})," statement:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"type IntPoint = (Int, Int)\ntype MathOp = Double => Double => Double\nval p: IntPoint = (5, 10)\n// p: Tuple2[Int, Int] = (5, 10)\nval plus: MathOp = x => y => x + y\n// plus: Function1[Double, Function1[Double, Double]] = repl.MdocSession$MdocApp8$$Lambda/0x0000000803ba70b0@1e29d42d\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If we have a family of types where one or more parts can be substituted with an\narbitrary type, then we can introduce a ",(0,s.jsx)(n.strong,{children:"parameterized type alias"})," by adding\ntype parameters."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'type Point[A] = (A, A)\ntype BinaryOp[Op, Res] = Op => Op => Res\ntype Printer[T] = T => Unit\nval p1: Point[Int] = (5, 10)\n// p1: Tuple2[Int, Int] = (5, 10)\nval p2: Point[Double] = (5.0, 10.0)\n// p2: Tuple2[Double, Double] = (5.0, 10.0)\nval int_plus: BinaryOp[Int, Int] = x => y => x + y\n// int_plus: Function1[Int, Function1[Int, Int]] = repl.MdocSession$MdocApp8$$Lambda/0x0000000803ba7ac0@28286e92\nval string_eq: BinaryOp[String, Boolean] = s => t => s == t\n// string_eq: Function1[String, Function1[String, Boolean]] = repl.MdocSession$MdocApp8$$Lambda/0x0000000803ba8218@618ecd5b\nval print_point: Printer[Point[Int]] = (p) => {\n  printf("(%d, %d)", p._1, p._2)\n}\n// print_point: Function1[Point[Int], Unit] = repl.MdocSession$MdocApp8$$Lambda/0x0000000803ba87f8@503ecca3\nprint_point(p1)\n// (5, 10)\n'})}),"\n",(0,s.jsx)(n.h2,{id:"constructors-and-variants",children:"Constructors and Variants"}),"\n",(0,s.jsxs)(n.p,{children:["A tuple is a rather generic way of packaging up data. When you are building a larger\nprogram, it would not be very meaningful to see a value like ",(0,s.jsx)(n.code,{children:'("Brian", 93)'})," out of\ncontext. Just as programmers are encouraged to use symbolic names for constants (for\nexample, ",(0,s.jsx)(n.code,{children:"LINE_WIDTH"})," instead of 80), we can attach names to particular uses of tuples\nto make them more readable and maintainable."]}),"\n",(0,s.jsxs)(n.p,{children:["The object-oriented solution to this is to create an ",(0,s.jsx)(n.strong,{children:"object"})," (or ",(0,s.jsx)(n.strong,{children:"class"})," of objects)\nwith named ",(0,s.jsx)(n.strong,{children:"fields"}),".\nIn Java, this might look as follows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"public class Entry {\n  private final String name;\n  private final int grade;\n\n  public Entry(String name, int grade) {\n    this.name = name;\n    this.grade = grade;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public int getGrade() {\n    return grade;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"We can then use it as follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'Entry entry = new Entry("Brian", 93);\nSystem.out.println(entry.getName() + "\'s grade is " + entry.getGrade());\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In Java 16 (released in March 2021), the concept of a ",(0,s.jsx)(n.strong,{children:"record"})," was added to Java\nspecifically for this purpose: classes of objects with immutable named fields.\nThe above class can be replaced by this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"public record Entry(String name, int grade) {}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["It is used the same way, except the automatically-created getters are ",(0,s.jsx)(n.code,{children:"name()"}),"\nand ",(0,s.jsx)(n.code,{children:"grade()"})," instead of ",(0,s.jsx)(n.code,{children:"getName()"})," and ",(0,s.jsx)(n.code,{children:"getGrade()"}),".\nIn Java 21 (released in September 2023), the ",(0,s.jsx)(n.code,{children:"switch/case"})," statement was extended\nto allow matching values on ",(0,s.jsx)(n.strong,{children:"record patterns"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'switch (entry) {\n  case Entry(var name, var grade):\n    System.out.println(name + "\'s grade is " + grade);\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["While it is nice that Java is finally getting support for this feature (and it is still\nin the process of being incorporated into other parts of the language, such as variable\ninitialization and assignment), it has been\nan integral part of most functional languages since the earliest days (the design of\nStandard ML had it in 1983, modeled on an earlier language called HOPE).\nIn Scala, these records are called ",(0,s.jsx)(n.strong,{children:"case classes"}),", and this is what the above example\nlooks like:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'case class Entry(name: String, grade: Int)\n\nval entry = Entry("Brian", 93)\n// entry: Entry = Entry(name = "Brian", grade = 93)\nentry match\n  case Entry(name, grade) => println(name + "\'s grade is " + grade)\n// Brian\'s grade is 93\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Suppose we have a gradebook data structure, containing a bunch of these\n",(0,s.jsx)(n.code,{children:"Entry"}),' records bundled with a "grading item" (representing a single assignment\nor exam, with a title and maximum number of points).\nNow we could write a function ',(0,s.jsx)(n.code,{children:"formatGrade"})," that takes an ",(0,s.jsx)(n.code,{children:"Item"})," and an ",(0,s.jsx)(n.code,{children:"Entry"}),"\nand generates a string describing one line of the gradebook:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'case class Item(title: String, max: Int)\n\ndef formatGrade(item: Item, entry: Entry): String = {\n  val Item(title, max) = item\n  val Entry(name, grade) = entry\n  name + ", " + title + ": " + grade + "/" + max\n}\n\nformatGrade(Item("Midterm", 100), Entry("Brian", 93))\n// res11: String = "Brian, Midterm: 93/100"\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The advantage here is that, even though both a grading item and a gradebook entry\nare described by a pair of a ",(0,s.jsx)(n.code,{children:"String"})," and an ",(0,s.jsx)(n.code,{children:"Int"}),", we can easily keep them\nseparate in the code because of the class names and associated field names.\nNaming is good!"]}),"\n",(0,s.jsx)(n.p,{children:"So far we have seen types where all of the data have the same form: the same number\nof components, each with the same set of types, across all values of the type. However,\nmost interesting data will come in several forms, and our programs will need to make\nappropriate decisions based on the form of each piece of data."}),"\n",(0,s.jsx)(n.h3,{id:"enumerations",children:"Enumerations"}),"\n",(0,s.jsxs)(n.p,{children:["The simplest case of having several ",(0,s.jsx)(n.strong,{children:"variants"})," of a data type is an ",(0,s.jsx)(n.strong,{children:"enumeration"}),".\nAn enumerated type is specified as a list of constant cases:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"enum Suit:\n  case Club\n  case Diamond\n  case Heart\n  case Spade\nimport Suit.*\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"import Suit.*"})," statement allows us to use ",(0,s.jsx)(n.code,{children:"Club"})," instead of ",(0,s.jsx)(n.code,{children:"Suit.Club"}),", and so on."]}),"\n",(0,s.jsxs)(n.p,{children:["Unlike tuples or simple tuple-like constructors, we cannot just\nexpect to match an enumerated value with a ",(0,s.jsx)(n.code,{children:"val"})," binding.\nInstead, we need a construct\nthat gives us a selection among ",(0,s.jsx)(n.em,{children:"several"})," bindings, one for each variant.\nIn Scala this construct is the ",(0,s.jsx)(n.code,{children:"match"})," expression, which is similar to the ",(0,s.jsx)(n.code,{children:"switch"}),"\nstatement in many languages:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'val suit1 = Club\n// suit1: Suit = Club\nsuit1 match\n  case Club => "It\'s a club"\n  case Diamond => "It\'s a diamond"\n  case Heart => "It\'s a heart"\n  case Spade => "It\'s a spade"\n// res12: String = "It\'s a club"\n'})}),"\n",(0,s.jsx)(n.p,{children:"Scala will guarantee that the only possible values of an expression of an enumerated\ntype are the listed cases, and it will also check whether all of the cases are covered\nin a match."}),"\n",(0,s.jsx)(n.h3,{id:"algebraic-data-types",children:"Algebraic Data Types"}),"\n",(0,s.jsxs)(n.p,{children:["By combining variants with tuple-like constructors, we get what are known as ",(0,s.jsx)(n.strong,{children:"algebraic\ndata types"}),'. The idea is that the values of a type are formed by one of several\nconstructors, each of which takes some number of component values. If we think of a\ntuple as the "product" of its component types, and a variant as a "sum" of several\nchoices, then an algebraic type is just our old familiar sum-of-products construction\nfrom propositional logic!']}),"\n",(0,s.jsx)(n.p,{children:"For example, suppose we want a type that describes some shapes. A shape will be either\na rectangle, with a given width and height, or a circle, with a given radius. The\nvariant type may be defined as"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"enum Shape:\n  case Rectangle(width: Double, height: Double)\n  case Circle(radius: Double)\nimport Shape.*\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Algebraically, this is the set ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsxs)(n.mrow,{children:[(0,s.jsx)(n.mtext,{children:"double"}),(0,s.jsx)(n.mo,{children:"\xd7"}),(0,s.jsx)(n.mtext,{children:"double"}),(0,s.jsx)(n.mo,{children:"+"}),(0,s.jsx)(n.mtext,{children:"double"})]}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\text{double}\\times\\text{double} + \\text{double}"})]})})}),(0,s.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.7778em",verticalAlign:"-0.0833em"}}),(0,s.jsx)(n.span,{className:"mord text",children:(0,s.jsx)(n.span,{className:"mord",children:"double"})}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,s.jsx)(n.span,{className:"mbin",children:"\xd7"}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.7778em",verticalAlign:"-0.0833em"}}),(0,s.jsx)(n.span,{className:"mord text",children:(0,s.jsx)(n.span,{className:"mord",children:"double"})}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,s.jsx)(n.span,{className:"mbin",children:"+"}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.6944em"}}),(0,s.jsx)(n.span,{className:"mord text",children:(0,s.jsx)(n.span,{className:"mord",children:"double"})})]})]})]}),", where\nthe ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsx)(n.mrow,{children:(0,s.jsx)(n.mo,{children:"+"})}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"+"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.6667em",verticalAlign:"-0.0833em"}}),(0,s.jsx)(n.span,{className:"mord",children:"+"})]})})]})," operation is forming a ",(0,s.jsx)(n.strong,{children:"disjoint sum"})," of two sets\u2014similar to a union, but\nattaching some sort of tag to the element of each set so that there are no duplicates.",(0,s.jsx)(n.sup,{children:(0,s.jsx)(n.a,{href:"#user-content-fn-3",id:"user-content-fnref-3","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"3"})})]}),"\n",(0,s.jsx)(n.p,{children:"We may define a function to compute the area of a shape by doing a case analysis:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"def area(shape: Shape): Double = {\n  shape match\n    case Rectangle(width, height) => width * height\n    case Circle(radius) => math.Pi * radius * radius\n}\narea(Rectangle(5.0, 10.0))\n// res13: Double = 50.0\narea(Circle(10.0))\n// res14: Double = 314.1592653589793\n"})}),"\n",(0,s.jsx)(n.p,{children:"If you are familiar with interfaces and subclasses in an object-oriented language such\nas Java, it is instructive to compare this with a typical object-oriented approach (which\nis also supported in Scala):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"trait Shape:\n  def area: Double\n\nclass Rectangle(val width: Double, val height: Double) extends Shape:\n  def area: Double = width * height\n\nclass Circle(val radius: Double) extends Shape:\n  def area: Double = math.Pi * radius * radius\n\nRectangle(5.0, 10.0).area\n// res16: Double = 50.0\nCircle(10.0).area\n// res17: Double = 314.1592653589793\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Each class implementing ",(0,s.jsx)(n.code,{children:"Shape"})," is one variant, and the trait (interface)\nrequires it to provide an ",(0,s.jsx)(n.code,{children:"area"})," method with the correct signature. When we\nexecute code such as ",(0,s.jsx)(n.code,{children:"sh.area"}),", where ",(0,s.jsx)(n.code,{children:"sh"})," is a variable of type ",(0,s.jsx)(n.code,{children:"Shape"}),",\nthe underlying Java virtual machine code essentially does a case analysis\nof the object currently in ",(0,s.jsx)(n.code,{children:"sh"})," to determine which ",(0,s.jsx)(n.code,{children:"area"})," method to run."]}),"\n",(0,s.jsxs)(n.p,{children:["One difference between the functional and object-oriented approaches is that\nthe functional version makes it easy to add new operations (such as a\n",(0,s.jsx)(n.code,{children:"perimeter"})," function), but it is harder to change the list of variants (for example, to\nadd triangular shapes) because we have to add a case to all of the\nexisting operations. Conversely, the object-oriented version makes it easy to\nadd new variants (just define another class implementing ",(0,s.jsx)(n.code,{children:"Shape"}),"), but if we\nwant to add a new operation to the interface (such as ",(0,s.jsx)(n.code,{children:"perimeter"}),") we need\nto implement that method in all of the existing subclasses. This tradeoff\nis part of the reason for the existence of hybrid object-functional languages such as\nScala."]}),"\n",(0,s.jsx)(n.h3,{id:"pattern-matching",children:"Pattern Matching"}),"\n",(0,s.jsxs)(n.p,{children:["The pattern-matching case analysis in a match expression can be very powerful,\nsince patterns may contain other patterns. We may match on not only variants,\nconstructors, and tuples, but also on individual primitive values (such as\nintegers or strings). As long as the patterns cover all of the cases, they\nare allowed to overlap (that is, more than one pattern might match a given\nvalue); if so, then the first matching case is selected. At any point in a\npattern we may use the special ",(0,s.jsx)(n.strong,{children:"wildcard"})," pattern, underscore (",(0,s.jsx)(n.code,{children:"_"}),'), which\nwill match any value (but not bind it to anything). Match expressions will\noften have a final case matching the wildcard pattern as a "default" case.']}),"\n",(0,s.jsx)(n.p,{children:"For example, here are some functions on playing cards.\nFirst we will define the variants for the suit and rank, as well as a variant\nfor a playing card, which is either an ordinary card with a rank and a suit, or a joker:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"enum Suit:\n  case Club\n  case Diamond\n  case Heart\n  case Spade\nimport Suit.*\n\nenum Rank:\n  case Number(value: Int)\n  case Jack\n  case Queen\n  case King\n  case Ace\nimport Rank.*\n\nenum Card:\n  case Ordinary(rank: Rank, suit: Suit)\n  case Joker\nimport Card.*\n\nval card1 = Ordinary(Number(2), Club)\n// card1: Card = Ordinary(rank = Number(value = 2), suit = Club)\nval card2 = Ordinary(Jack, Spade)\n// card2: Card = Ordinary(rank = Jack, suit = Spade)\nval card3 = Ordinary(Ace, Heart)\n// card3: Card = Ordinary(rank = Ace, suit = Heart)\nval card4 = Joker;\n// card4: Card = Joker\n"})}),"\n",(0,s.jsx)(n.p,{children:"Here is a function that determines whether a card is a face card:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"def isFace(c: Card): Boolean = {\n  c match\n    case Ordinary(Jack, _) => true\n    case Ordinary(Queen, _) => true\n    case Ordinary(King, _) => true\n    case _ => false\n}\nisFace(card2)\n// res18: Boolean = true\nisFace(card3)\n// res19: Boolean = false\n"})}),"\n",(0,s.jsx)(n.p,{children:'Here is a function that tells us if a card is "wild", if we are playing a friendly\ngame where jokers and black twos are wild:'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"def isWild(c: Card): Boolean = {\n  c match\n    case Ordinary(Number(2), Club) => true\n    case Ordinary(Number(2), Spade) => true\n    case Joker => true\n    case _ => false\n}\nisWild(card1)\n// res20: Boolean = true\nisWild(card2)\n// res21: Boolean = false\nisWild(card3)\n// res22: Boolean = false\nisWild(card4)\n// res23: Boolean = true\n"})}),"\n",(0,s.jsxs)(n.p,{children:['Finally, here is a function that will take two cards plus a string, either\n"high" or "low". It will return the card with the higher rank; if they have the\nsame rank, it will just return the first card. If the string argument is "high",\nthen aces will rank higher than kings, otherwise they will rank lower than twos\n(this is somewhat artificial, but I want to show an example with a string\npattern). Jokers are always the highest. The code takes advantage of the\n',(0,s.jsx)(n.code,{children:".ordinal"})," property automatically defined on an enumeration, where earlier variants are\nless than (",(0,s.jsx)(n.code,{children:"<"}),") later ones:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'def higher(c1: Card, c2: Card, rule: String): Card = {\n  (c1, c2, rule) match\n    /* First handle the Jokers */\n    case (Joker, _, _) => c1\n    case (_, Joker, _) => c2\n    /* Handle all of the Ace cases now */\n    case (Ordinary(Ace, _), _, "high") => c1\n    case (_, Ordinary(Ace, _), "high") => c2 \n    case (_, Ordinary(Ace, _), "low") => c1\n    case (Ordinary(Ace, _), _, "low") => c2\n    /* Handle the number card cases */\n    case (Ordinary(Number(n1), _), Ordinary(Number(n2), _), _) =>\n      if n1 >= n1 then c1 else c2\n    case (Ordinary(Number(_), _), Ordinary(_, _), _) => c2\n    case (Ordinary(_, _), Ordinary(Number(_), _), _) => c1\n    /* Handle the face cards by comparison */\n    case (Ordinary(rank1, _), Ordinary(rank2, _), _) =>\n      if (rank1.ordinal >= rank2.ordinal) then c1 else c2\n}\nhigher(card1, card2, "high") /* should be the Jack */\n// res24: Card = Ordinary(rank = Jack, suit = Spade)\nhigher(card1, card3, "high") /* should be the Ace */\n// res25: Card = Ordinary(rank = Ace, suit = Heart)\nhigher(card1, card3, "low") /* should be the Two */\n// res26: Card = Ordinary(rank = Number(value = 2), suit = Club)\nhigher(card3, card4, "high") /* should be the Joker */\n// res27: Card = Joker\n'})}),"\n",(0,s.jsx)(n.h3,{id:"recursive-types",children:"Recursive Types"}),"\n",(0,s.jsxs)(n.p,{children:["When we define a type with the ",(0,s.jsx)(n.code,{children:"enum"})," statement, the cases are allowed to\nrefer to the new type when assigning the types of components. When specifying such\na ",(0,s.jsx)(n.strong,{children:"recursive type"})," there generally needs to be a variant that does not refer to\nthe new type, to serve as a base case (otherwise it is difficult to get off the\nground when building values of the type). Here are two characteristic examples\nthat we will be exploring more later:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"enum MyList:\n  case Empty\n  case Node(head: Int, tail: MyList)\nenum MyTree[A, B]:\n  case Leaf(value: A)\n  case Node(left: MyTree[A, B], value: B, right: MyTree[A, B])\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The type ",(0,s.jsx)(n.code,{children:"MyList"})," represents linked lists of integers. Each value is either\nan empty list or a list node containing an integer and a value for the rest of\nthe list. For example, the list ",(0,s.jsx)(n.code,{children:"[1, 2, 3]"})," would be represented by the following\nvalue:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"val list123 = MyList.Node(1, MyList.Node(2, MyList.Node(3, MyList.Empty)))\n// list123: MyList = Node(\n//   head = 1,\n//   tail = Node(head = 2, tail = Node(head = 3, tail = Empty))\n// )\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The natural way to write a function over such a list is by pattern matching, with\nthe additional wrinkle that we may recursively use the function to process the\nrest of the list (since it is a smaller list, we can use\n",(0,s.jsx)(n.a,{href:"/focsipedia/docs/logic/recursion#structural-induction",children:"structural induction"})," to\nprove properties of such a function). Here is a function to add up the numbers\nin a list:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"def sumList(nums: MyList): Int = {\n  import MyList.*\n\n  nums match\n    case Empty => 0\n    case Node(n, rest) => n + sumList(rest)\n}\nsumList(list123);\n// res28: Int = 6\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Scala has a list type built in to the language, with a large number of supporting functions in the standard library.\nThe type ",(0,s.jsx)(n.code,{children:"List[A]"})," is a list of elements of type ",(0,s.jsx)(n.code,{children:"A"}),";\nthe empty list is written ",(0,s.jsx)(n.code,{children:"Nil"}),", and the list node with value ",(0,s.jsx)(n.code,{children:"x"})," at the head of the list and ",(0,s.jsx)(n.code,{children:"rest"})," for the tail is written ",(0,s.jsx)(n.code,{children:"x :: rest"}),".\nThe ",(0,s.jsx)(n.code,{children:"::"})," is called the ",(0,s.jsx)(n.strong,{children:"cons"})," operator, and you can either write a list as ",(0,s.jsx)(n.code,{children:"1 :: 2 :: 3 :: Nil"}),", or you can use the constructor form ",(0,s.jsx)(n.code,{children:"List(1, 2, 3)"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The type ",(0,s.jsx)(n.code,{children:"MyTree[A, B]"})," is a parameterized type. It represents binary trees that\nare either leaves containing a value of type ",(0,s.jsx)(n.code,{children:"A"}),", or tree nodes that contain two\nsubtrees and a value of type ",(0,s.jsx)(n.code,{children:"B"}),". For example, here is a tree with integers in the\nleaves and string labels on the interior nodes; it is meant to represent the\narithmetic expression ",(0,s.jsx)(n.code,{children:"1 + 2 * 3"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'val tree123 = MyTree.Node(MyTree.Leaf(1), "+", MyTree.Node(MyTree.Leaf(2), "*", MyTree.Leaf(3)))\n// tree123: MyTree[Int, String] = Node(\n//   left = Leaf(value = 1),\n//   value = "+",\n//   right = Node(left = Leaf(value = 2), value = "*", right = Leaf(value = 3))\n// )\n'})}),"\n",(0,s.jsx)(n.p,{children:"Here is a function defined by pattern matching over trees that evaluates such an\nexpression:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'def eval(t: MyTree[Int, String]): Int = {\n  import MyTree.*\n\n  t match\n    case Leaf(n) => n\n    case Node(left, "+", right) => eval(left) + eval(right)\n    case Node(left, "*", right) => eval(left) * eval(right)\n}\neval(tree123)\n// res29: Int = 7\n'})}),"\n",(0,s.jsx)(n.p,{children:"We get a warning (not shown by mdoc) that the pattern match is not exhaustive, because we\ndon't provide cases for all of the possible operator strings. We will look at\nbetter solutions for this eventually."}),"\n",(0,s.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Write Scala functions that compute the inclusive and exclusive OR\noperations. That is, write Boolean functions ",(0,s.jsx)(n.code,{children:"or(x, y)"})," and ",(0,s.jsx)(n.code,{children:"xor(x, y)"})," that\nwill return ",(0,s.jsx)(n.code,{children:"true"})," if one of ",(0,s.jsx)(n.code,{children:"x"})," or ",(0,s.jsx)(n.code,{children:"y"})," is ",(0,s.jsx)(n.code,{children:"true"}),"; in the inclusive case,\n",(0,s.jsx)(n.code,{children:"or(true, true)"})," is also ",(0,s.jsx)(n.code,{children:"true"}),", while for the exclusive case,\n",(0,s.jsx)(n.code,{children:"xor(true, true)"})," is ",(0,s.jsx)(n.code,{children:"false"}),". Use pattern matching for one, and ",(0,s.jsx)(n.code,{children:"if"}),"\nexpressions for the other (but do not use the built-in logical operators such\nas ",(0,s.jsx)(n.code,{children:"||"}),")."]}),"\n",(0,s.jsxs)(a,{children:[(0,s.jsx)("summary",{children:"Answer"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:" def or(x: Boolean, y: Boolean): Boolean = {\n   (x, y) match\n     case (true, _) => true\n     case (_, true) => true\n     case (_, _) => false\n } \n\n def xor(x: Boolean, y: Boolean): Boolean = {\n   if x then\n     if y then false else true\n   else y\n }\n"})})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Add a ",(0,s.jsx)(n.code,{children:"Triangle"})," variant to the ",(0,s.jsx)(n.code,{children:"Shape"})," type above, to represent a right triangle. The constructor should\ntake two doubles: the base and the height. Extend the ",(0,s.jsx)(n.code,{children:"area"})," function to\nhandle triangles, and then define a ",(0,s.jsx)(n.code,{children:"perimeter"})," function for shapes."]}),"\n",(0,s.jsxs)(a,{children:[(0,s.jsx)("summary",{children:"Answer"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"enum Shape:\n  case Rectangle(width: Double, height: Double)\n  case Circle(radius: Double)\n  case Triangle(base: Double, height: Double)\nimport Shape.*\n\ndef area(shape: Shape): Double = {\n  shape match\n    case Rectangle(width, height) => width * height\n    case Circle(radius) => math.Pi * radius * radius\n    case Triangle(base, height) => base * height / 2\n}\n\ndef perimeter(shape: Shape): Double = {\n  shape match\n    case Rectangle(width, height) => 2 * (width + height)\n    case Circle(radius) => 2 * math.Pi * radius\n    case Triangle(base, height) => base + height + math.hypot(base, height)\n}\n"})})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Define a function that takes a ",(0,s.jsx)(n.code,{children:"MyTree[Int, String]"})," value and counts the number\nof leaves. That is, the function call\n",(0,s.jsx)(n.code,{children:'numLeaves(MyTree.Node(MyTree.Leaf(27), "+", MyTree.Node(MyTree.Leaf(3), "*", MyTree.Leaf(5))))'}),"\nshould return 3. ",(0,s.jsx)(n.em,{children:"Hint:"})," Define it using a pattern match."]}),"\n",(0,s.jsxs)(a,{children:[(0,s.jsx)("summary",{children:"Answer"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"def numLeaves(t: MyTree[Int, String]): Int = {\n  import MyTree.*\n\n  t match\n    case Leaf(_) => 1\n    case Node(left, _, right) => numLeaves(left) + numLeaves(right)\n}\n"})})]}),"\n"]}),"\n"]}),"\n","\n",(0,s.jsxs)(n.section,{"data-footnotes":!0,className:"footnotes",children:[(0,s.jsx)(n.h2,{className:"sr-only",id:"footnote-label",children:"Footnotes"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{id:"user-content-fn-1",children:["\n",(0,s.jsxs)(n.p,{children:["Why 22? Well, they had to stop somewhere. Also, if you are writing code using\ntuples with more than 22 elements, you might want to reconsider your design. ",(0,s.jsx)(n.a,{href:"#user-content-fnref-1","data-footnote-backref":"","aria-label":"Back to reference 1",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{id:"user-content-fn-2",children:["\n",(0,s.jsxs)(n.p,{children:["Scala does not go quite all the way with making types be first-class values. There is currently\nactive work on creating industrial-strength languages with so-called ",(0,s.jsx)(n.strong,{children:"dependent\ntypes"}),", where types are values and values can be used in types. Good examples are\nAgda (",(0,s.jsx)(n.a,{href:"https://github.com/agda/agda",children:"https://github.com/agda/agda"}),"), Idris (",(0,s.jsx)(n.a,{href:"https://www.idris-lang.org/",children:"https://www.idris-lang.org/"}),"), and Lean\n(",(0,s.jsx)(n.a,{href:"https://leanprover.github.io/",children:"https://leanprover.github.io/"}),"). ",(0,s.jsx)(n.a,{href:"#user-content-fnref-2","data-footnote-backref":"","aria-label":"Back to reference 2",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{id:"user-content-fn-3",children:["\n",(0,s.jsxs)(n.p,{children:["For example, we could define ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsxs)(n.mrow,{children:[(0,s.jsx)(n.mi,{children:"A"}),(0,s.jsx)(n.mo,{children:"+"}),(0,s.jsx)(n.mi,{children:"B"}),(0,s.jsx)(n.mo,{children:"="}),(0,s.jsx)(n.mo,{stretchy:"false",children:"("}),(0,s.jsx)(n.mo,{stretchy:"false",children:"{"}),(0,s.jsx)(n.mn,{children:"0"}),(0,s.jsx)(n.mo,{stretchy:"false",children:"}"}),(0,s.jsx)(n.mo,{children:"\xd7"}),(0,s.jsx)(n.mi,{children:"A"}),(0,s.jsx)(n.mo,{stretchy:"false",children:")"}),(0,s.jsx)(n.mo,{children:"\u222a"}),(0,s.jsx)(n.mo,{stretchy:"false",children:"("}),(0,s.jsx)(n.mo,{stretchy:"false",children:"{"}),(0,s.jsx)(n.mn,{children:"1"}),(0,s.jsx)(n.mo,{stretchy:"false",children:"}"}),(0,s.jsx)(n.mo,{children:"\xd7"}),(0,s.jsx)(n.mi,{children:"B"}),(0,s.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"A+B=(\\{0\\}\\times A)\\cup(\\{1\\}\\times B)"})]})})}),(0,s.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.7667em",verticalAlign:"-0.0833em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"A"}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,s.jsx)(n.span,{className:"mbin",children:"+"}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.6833em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.05017em"},children:"B"}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,s.jsx)(n.span,{className:"mrel",children:"="}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.jsx)(n.span,{className:"mopen",children:"({"}),(0,s.jsx)(n.span,{className:"mord",children:"0"}),(0,s.jsx)(n.span,{className:"mclose",children:"}"}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,s.jsx)(n.span,{className:"mbin",children:"\xd7"}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"A"}),(0,s.jsx)(n.span,{className:"mclose",children:")"}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,s.jsx)(n.span,{className:"mbin",children:"\u222a"}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.jsx)(n.span,{className:"mopen",children:"({"}),(0,s.jsx)(n.span,{className:"mord",children:"1"}),(0,s.jsx)(n.span,{className:"mclose",children:"}"}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,s.jsx)(n.span,{className:"mbin",children:"\xd7"}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.05017em"},children:"B"}),(0,s.jsx)(n.span,{className:"mclose",children:")"})]})]})]}),". Then each element\nin the disjoint sum would be a pair whose first component is a tag of 0 if the element\ncame from ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsx)(n.mrow,{children:(0,s.jsx)(n.mi,{children:"A"})}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"A"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.6833em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"A"})]})})]})," and 1 if it came from ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsx)(n.mrow,{children:(0,s.jsx)(n.mi,{children:"B"})}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"B"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.6833em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.05017em"},children:"B"})]})})]}),". Any element in common between ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsx)(n.mrow,{children:(0,s.jsx)(n.mi,{children:"A"})}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"A"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.6833em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"A"})]})})]})," and ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsx)(n.mrow,{children:(0,s.jsx)(n.mi,{children:"B"})}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"B"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.6833em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.05017em"},children:"B"})]})})]})," will\nstill be distinguishable by its tag. ",(0,s.jsx)(n.a,{href:"#user-content-fnref-3","data-footnote-backref":"","aria-label":"Back to reference 3",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>r,x:()=>l});var s=a(6540);const t={},i=s.createContext(t);function r(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);