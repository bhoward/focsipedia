(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{190:function(e,a,t){"use strict";t.r(a),t.d(a,"frontMatter",(function(){return r})),t.d(a,"metadata",(function(){return c})),t.d(a,"rightToc",(function(){return p})),t.d(a,"default",(function(){return i}));var n=t(1),s=t(6),m=(t(0),t(199)),r={id:"graphs",title:"Graphs"},c={id:"ds/graphs",title:"Graphs",description:"## Graph Terminology",source:"@site/docs/ds/graphs.md",permalink:"/focsipedia/docs/ds/graphs",editUrl:"https://github.com/bhoward/focsipedia/edit/master/docs/ds/graphs.md",sidebar:"someSidebar",previous:{title:"Binary Search Trees and Heaps",permalink:"/focsipedia/docs/ds/bst"},next:{title:"ReasonML",permalink:"/focsipedia/docs/reason"}},p=[{value:"Graph Terminology",id:"graph-terminology",children:[]},{value:"Graph Representations",id:"graph-representations",children:[]}],b={rightToc:p};function i(e){var a=e.components,t=Object(s.a)(e,["components"]);return Object(m.b)("wrapper",Object(n.a)({},b,t,{components:a,mdxType:"MDXLayout"}),Object(m.b)("h2",{id:"graph-terminology"},"Graph Terminology"),Object(m.b)("p",null,"A ",Object(m.b)("strong",{parentName:"p"},"graph")," is a general data structure for showing connections among a set of objects.\nThe objects are called ",Object(m.b)("strong",{parentName:"p"},"nodes")," or ",Object(m.b)("strong",{parentName:"p"},"vertices"),", and we will usually label them with a unique number or string.\nThe connections are called ",Object(m.b)("strong",{parentName:"p"},"edges"),"; an edge connects two nodes.\nDepending on the application, there may be additional conditions or properties of edges:"),Object(m.b)("ul",null,Object(m.b)("li",{parentName:"ul"},"In an ",Object(m.b)("strong",{parentName:"li"},"undirected")," graph, an edge linking ",Object(m.b)("span",Object(n.a)({parentName:"li"},{className:"math math-inline"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(m.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(m.b)("semantics",{parentName:"math"},Object(m.b)("mrow",{parentName:"semantics"},Object(m.b)("mi",{parentName:"mrow"},"x")),Object(m.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"x")))),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}})),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault"}),"x")))))," to ",Object(m.b)("span",Object(n.a)({parentName:"li"},{className:"math math-inline"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(m.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(m.b)("semantics",{parentName:"math"},Object(m.b)("mrow",{parentName:"semantics"},Object(m.b)("mi",{parentName:"mrow"},"y")),Object(m.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"y")))),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.625em",verticalAlign:"-0.19444em"}})),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault",style:{marginRight:"0.03588em"}}),"y")))))," is also a link from ",Object(m.b)("span",Object(n.a)({parentName:"li"},{className:"math math-inline"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(m.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(m.b)("semantics",{parentName:"math"},Object(m.b)("mrow",{parentName:"semantics"},Object(m.b)("mi",{parentName:"mrow"},"y")),Object(m.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"y")))),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.625em",verticalAlign:"-0.19444em"}})),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault",style:{marginRight:"0.03588em"}}),"y")))))," to ",Object(m.b)("span",Object(n.a)({parentName:"li"},{className:"math math-inline"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(m.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(m.b)("semantics",{parentName:"math"},Object(m.b)("mrow",{parentName:"semantics"},Object(m.b)("mi",{parentName:"mrow"},"x")),Object(m.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"x")))),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}})),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault"}),"x"))))),"."),Object(m.b)("li",{parentName:"ul"},"In a ",Object(m.b)("strong",{parentName:"li"},"directed")," graph, we distinguish an edge from ",Object(m.b)("span",Object(n.a)({parentName:"li"},{className:"math math-inline"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(m.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(m.b)("semantics",{parentName:"math"},Object(m.b)("mrow",{parentName:"semantics"},Object(m.b)("mi",{parentName:"mrow"},"x")),Object(m.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"x")))),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}})),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault"}),"x")))))," to ",Object(m.b)("span",Object(n.a)({parentName:"li"},{className:"math math-inline"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(m.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(m.b)("semantics",{parentName:"math"},Object(m.b)("mrow",{parentName:"semantics"},Object(m.b)("mi",{parentName:"mrow"},"y")),Object(m.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"y")))),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.625em",verticalAlign:"-0.19444em"}})),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault",style:{marginRight:"0.03588em"}}),"y")))))," (we refer to ",Object(m.b)("span",Object(n.a)({parentName:"li"},{className:"math math-inline"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(m.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(m.b)("semantics",{parentName:"math"},Object(m.b)("mrow",{parentName:"semantics"},Object(m.b)("mi",{parentName:"mrow"},"x")),Object(m.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"x")))),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}})),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault"}),"x")))))," as the ",Object(m.b)("strong",{parentName:"li"},"source")," and ",Object(m.b)("span",Object(n.a)({parentName:"li"},{className:"math math-inline"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(m.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(m.b)("semantics",{parentName:"math"},Object(m.b)("mrow",{parentName:"semantics"},Object(m.b)("mi",{parentName:"mrow"},"y")),Object(m.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"y")))),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.625em",verticalAlign:"-0.19444em"}})),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault",style:{marginRight:"0.03588em"}}),"y")))))," as the ",Object(m.b)("strong",{parentName:"li"},"target"),") from an edge going the other way, from ",Object(m.b)("span",Object(n.a)({parentName:"li"},{className:"math math-inline"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(m.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(m.b)("semantics",{parentName:"math"},Object(m.b)("mrow",{parentName:"semantics"},Object(m.b)("mi",{parentName:"mrow"},"y")),Object(m.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"y")))),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.625em",verticalAlign:"-0.19444em"}})),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault",style:{marginRight:"0.03588em"}}),"y")))))," to ",Object(m.b)("span",Object(n.a)({parentName:"li"},{className:"math math-inline"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(m.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(m.b)("semantics",{parentName:"math"},Object(m.b)("mrow",{parentName:"semantics"},Object(m.b)("mi",{parentName:"mrow"},"x")),Object(m.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"x")))),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}})),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault"}),"x"))))),"."),Object(m.b)("li",{parentName:"ul"},"In a ",Object(m.b)("strong",{parentName:"li"},"simple")," graph, there must be at most one edge connecting any pair of nodes, and there are no ",Object(m.b)("strong",{parentName:"li"},"loops")," (edges from a node to itself)."),Object(m.b)("li",{parentName:"ul"},"To emphasize that multiple edges are allowed between nodes we may refer to a ",Object(m.b)("strong",{parentName:"li"},"multigraph"),"; to emphasize that loops are allowed we may refer to a ",Object(m.b)("strong",{parentName:"li"},"loop graph"),". A multigraph with loops is sometimes called a ",Object(m.b)("strong",{parentName:"li"},"pseudograph"),", although we will generally just refer to all of these variants as graphs and only make distinctions where needed."),Object(m.b)("li",{parentName:"ul"},"An edge may be ",Object(m.b)("strong",{parentName:"li"},"labeled")," with a number or string; we do not generally require edge labels to be unique."),Object(m.b)("li",{parentName:"ul"},"If there is an edge from ",Object(m.b)("span",Object(n.a)({parentName:"li"},{className:"math math-inline"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(m.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(m.b)("semantics",{parentName:"math"},Object(m.b)("mrow",{parentName:"semantics"},Object(m.b)("mi",{parentName:"mrow"},"x")),Object(m.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"x")))),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}})),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault"}),"x")))))," to ",Object(m.b)("span",Object(n.a)({parentName:"li"},{className:"math math-inline"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(m.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(m.b)("semantics",{parentName:"math"},Object(m.b)("mrow",{parentName:"semantics"},Object(m.b)("mi",{parentName:"mrow"},"y")),Object(m.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"y")))),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.625em",verticalAlign:"-0.19444em"}})),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault",style:{marginRight:"0.03588em"}}),"y"))))),", then we say that ",Object(m.b)("span",Object(n.a)({parentName:"li"},{className:"math math-inline"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(m.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(m.b)("semantics",{parentName:"math"},Object(m.b)("mrow",{parentName:"semantics"},Object(m.b)("mi",{parentName:"mrow"},"y")),Object(m.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"y")))),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.625em",verticalAlign:"-0.19444em"}})),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault",style:{marginRight:"0.03588em"}}),"y")))))," is ",Object(m.b)("strong",{parentName:"li"},"adjacent")," to ",Object(m.b)("span",Object(n.a)({parentName:"li"},{className:"math math-inline"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(m.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(m.b)("semantics",{parentName:"math"},Object(m.b)("mrow",{parentName:"semantics"},Object(m.b)("mi",{parentName:"mrow"},"x")),Object(m.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"x")))),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}})),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault"}),"x"))))),".")),Object(m.b)("h2",{id:"graph-representations"},"Graph Representations"),Object(m.b)("p",null,"One representation of an unlabeled graph is simply as a set of ordered pairs of nodes.\nThis corresponds to the usual notion of a ",Object(m.b)("strong",{parentName:"p"},"relation"),' as a set of pairs (sometimes called, perhaps confusingly, the "graph" of the relation).'),Object(m.b)("p",null,"Another representation is as a function (often given in the form of a table) from nodes to a set of neighbors (",Object(m.b)("em",{parentName:"p"},"i.e."),", the adjacent nodes).\nThe set of neighbors of each node is often presented as a list, which leads to the term ",Object(m.b)("strong",{parentName:"p"},"adjacency list")," for this presentation."),Object(m.b)("p",null,"A third representation is as an ",Object(m.b)("strong",{parentName:"p"},"adjacency matrix"),".\nIf the nodes are numbered 1 through ",Object(m.b)("span",Object(n.a)({parentName:"p"},{className:"math math-inline"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(m.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(m.b)("semantics",{parentName:"math"},Object(m.b)("mrow",{parentName:"semantics"},Object(m.b)("mi",{parentName:"mrow"},"N")),Object(m.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"N")))),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}})),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault",style:{marginRight:"0.10903em"}}),"N"))))),", then the adjacency matrix is the two-dimensional array where the entry in row ",Object(m.b)("span",Object(n.a)({parentName:"p"},{className:"math math-inline"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(m.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(m.b)("semantics",{parentName:"math"},Object(m.b)("mrow",{parentName:"semantics"},Object(m.b)("mi",{parentName:"mrow"},"i")),Object(m.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"i")))),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.65952em",verticalAlign:"0em"}})),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault"}),"i"))))),", column ",Object(m.b)("span",Object(n.a)({parentName:"p"},{className:"math math-inline"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(m.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(m.b)("semantics",{parentName:"math"},Object(m.b)("mrow",{parentName:"semantics"},Object(m.b)("mi",{parentName:"mrow"},"j")),Object(m.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"j")))),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.85396em",verticalAlign:"-0.19444em"}})),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault",style:{marginRight:"0.05724em"}}),"j")))))," will be 1 (or 'true') if there is an edge from ",Object(m.b)("span",Object(n.a)({parentName:"p"},{className:"math math-inline"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(m.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(m.b)("semantics",{parentName:"math"},Object(m.b)("mrow",{parentName:"semantics"},Object(m.b)("mi",{parentName:"mrow"},"i")),Object(m.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"i")))),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.65952em",verticalAlign:"0em"}})),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault"}),"i")))))," to ",Object(m.b)("span",Object(n.a)({parentName:"p"},{className:"math math-inline"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(m.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(m.b)("semantics",{parentName:"math"},Object(m.b)("mrow",{parentName:"semantics"},Object(m.b)("mi",{parentName:"mrow"},"j")),Object(m.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"j")))),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.85396em",verticalAlign:"-0.19444em"}})),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault",style:{marginRight:"0.05724em"}}),"j")))))," and 0 ('false') if not.\nThis representation is often extended to labeled graphs where the labels are ",Object(m.b)("strong",{parentName:"p"},"weights"),": the entry for ",Object(m.b)("span",Object(n.a)({parentName:"p"},{className:"math math-inline"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(m.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(m.b)("semantics",{parentName:"math"},Object(m.b)("mrow",{parentName:"semantics"},Object(m.b)("mo",Object(n.a)({parentName:"mrow"},{stretchy:"false"}),"("),Object(m.b)("mi",{parentName:"mrow"},"i"),Object(m.b)("mo",Object(n.a)({parentName:"mrow"},{separator:"true"}),","),Object(m.b)("mi",{parentName:"mrow"},"j"),Object(m.b)("mo",Object(n.a)({parentName:"mrow"},{stretchy:"false"}),")")),Object(m.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"(i,j)")))),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}})),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"mopen"}),"("),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault"}),"i"),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"mpunct"}),","),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.16666666666666666em"}})),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault",style:{marginRight:"0.05724em"}}),"j"),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"mclose"}),")")))))," gives the weight (or distance, or cost, ","\u2026",") of the edge between ",Object(m.b)("span",Object(n.a)({parentName:"p"},{className:"math math-inline"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(m.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(m.b)("semantics",{parentName:"math"},Object(m.b)("mrow",{parentName:"semantics"},Object(m.b)("mi",{parentName:"mrow"},"i")),Object(m.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"i")))),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.65952em",verticalAlign:"0em"}})),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault"}),"i")))))," and ",Object(m.b)("span",Object(n.a)({parentName:"p"},{className:"math math-inline"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(m.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(m.b)("semantics",{parentName:"math"},Object(m.b)("mrow",{parentName:"semantics"},Object(m.b)("mi",{parentName:"mrow"},"j")),Object(m.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"j")))),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.85396em",verticalAlign:"-0.19444em"}})),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault",style:{marginRight:"0.05724em"}}),"j"))))),".\nDepending on the application, it may be preferable to use an infinite weight to represent absent edges, rather than 0 (since a weight of 0 might be interpreted as saying there is no cost to go from ",Object(m.b)("span",Object(n.a)({parentName:"p"},{className:"math math-inline"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(m.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(m.b)("semantics",{parentName:"math"},Object(m.b)("mrow",{parentName:"semantics"},Object(m.b)("mi",{parentName:"mrow"},"i")),Object(m.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"i")))),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.65952em",verticalAlign:"0em"}})),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault"}),"i")))))," to ",Object(m.b)("span",Object(n.a)({parentName:"p"},{className:"math math-inline"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(m.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(m.b)("semantics",{parentName:"math"},Object(m.b)("mrow",{parentName:"semantics"},Object(m.b)("mi",{parentName:"mrow"},"j")),Object(m.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"j")))),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.85396em",verticalAlign:"-0.19444em"}})),Object(m.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault",style:{marginRight:"0.05724em"}}),"j"))))),")."),Object(m.b)("p",null,"Here is some ReasonML code defining types for these representations, plus some conversion functions. In each case, the type is parameterized by a node type ",Object(m.b)("inlineCode",{parentName:"p"},"'n"),", and the representation type is a pair where the first element is the list of nodes (because there is no generic way to get this list for an arbitrary type ",Object(m.b)("inlineCode",{parentName:"p"},"'n"),", and if ",Object(m.b)("inlineCode",{parentName:"p"},"'n")," is ",Object(m.b)("inlineCode",{parentName:"p"},"int")," or ",Object(m.b)("inlineCode",{parentName:"p"},"string")," we only want to use a subset of the possible values anyway). The code uses a number of standard functions on lists such as ",Object(m.b)("inlineCode",{parentName:"p"},"List.map")," and ",Object(m.b)("inlineCode",{parentName:"p"},"List.filter"),"; for details, see the ",Object(m.b)("a",Object(n.a)({parentName:"p"},{href:"https://reasonml.github.io/api/List.html"}),"library documentation"),"."),Object(m.b)("pre",null,Object(m.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),'type graphPairs(\'n) = (list(\'n), list((\'n, \'n)));\ntype graphAdjList(\'n) = (list(\'n), \'n => list(\'n));\ntype graphAdjMatrix(\'n) = (list(\'n), (\'n, \'n) => bool);\n\nlet adjlist_of_pairs = ((nodes, pairs)) => {\n  (nodes,\n    node => List.map(p => snd(p), List.filter(p => fst(p) == node, pairs))\n  )\n};\n\nlet adjmatrix_of_pairs = ((nodes, pairs)) => {\n  (nodes,\n    p => List.exists(q => p == q, pairs)\n  )\n};\n\nlet pairs_of_adjlist = ((nodes, alist)) => {\n  (nodes,\n    List.flatten(List.map(node => List.map(adj => (node, adj), alist(node)), nodes))\n  )\n};\n\nlet adjmatrix_of_adjlist = ((nodes, alist)) => {\n  (nodes,\n    p => List.exists(node => snd(p) == node, alist(fst(p)))\n  )\n};\n\nlet pairs_of_adjmatrix = ((nodes, amat)) => {\n  (nodes,\n    List.flatten(List.map(i => List.flatten(List.map(j => if (amat((i, j))) [(i, j)] else [], nodes)), nodes))\n  )\n};\n\nlet adjlist_of_adjmatrix = ((nodes, amat)) => {\n  (nodes,\n    i => List.filter(j => amat((i, j)), nodes)\n  )\n};\n\nlet rec print_list = (items, string_of_item) => {\n  switch (items) {\n  | [] => print_newline()\n  | [last] => print_string(string_of_item(last) ++ "\\n")\n  | [head, ...tail] => {\n      print_string(string_of_item(head) ++ ", ");\n      print_list(tail, string_of_item)\n    }\n  }\n};\n\nlet string_of_pair = (p, string_of_item) => {\n  "(" ++ string_of_item(fst(p)) ++ "," ++ string_of_item(snd(p)) ++ ")"\n};\n\nlet showPairs = ((nodes, pairs), string_of_node) => {\n  print_list(pairs, p => string_of_pair(p, string_of_node))\n};\n\nlet showAdjList = ((nodes, alist), string_of_node) => {\n  List.iter(node => {\n      print_string(string_of_node(node) ++ ": ");\n      print_list(alist(node), string_of_node)\n    }, nodes)\n};\n\nlet showAdjMatrix = ((nodes, amat), string_of_node) => {\n  List.iter(i => {\n      print_string(string_of_node(i) ++ ":");\n      List.iter(j => {\n          if (amat((i, j))) {\n            print_string(" 1")\n          } else {\n            print_string(" 0")\n          }\n        }, nodes);\n      print_newline()\n    }, nodes)\n};\n\nprint_string("Example 1\\n");\nlet nodes1 = [1, 2, 3, 4];\nlet demoPairs1 = (nodes1, [(1, 1), (1, 2), (1, 3), (1, 4), (2, 2), (2, 4), (3, 3), (4, 4)]);\nlet demoAdjList1 = adjlist_of_pairs(demoPairs1);\nlet demoAdjMatrix1 =adjmatrix_of_pairs(demoPairs1);\n\nprint_string("Pairs\\n");\nshowPairs(demoPairs1, string_of_int);\nprint_string("Adjacency List:\\n");\nshowAdjList(demoAdjList1, string_of_int);\nprint_string("Adjacency Matrix:\\n");\nshowAdjMatrix(demoAdjMatrix1, string_of_int);\n\nprint_string("\\nExample 2\\n");\ntype t2 = A | B | C | D;\nlet nodes2 = [A, B, C, D];\nlet string_of_t2 = x => {\n  switch (x) {\n  | A => "A"\n  | B => "B"\n  | C => "C"\n  | D => "D"\n  }\n};\nlet demoAdjList2 = (nodes2, node => {\n  switch (node) {\n  | A => [B, D]\n  | B => [A, C]\n  | C => [B]\n  | D => [A]\n  }\n});\nlet demoPairs2 = pairs_of_adjlist(demoAdjList2);\nlet demoAdjMatrix2 = adjmatrix_of_adjlist(demoAdjList2);\n\nprint_string("Pairs\\n");\nshowPairs(demoPairs2, string_of_t2);\nprint_string("Adjacency List:\\n");\nshowAdjList(demoAdjList2, string_of_t2);\nprint_string("Adjacency Matrix:\\n");\nshowAdjMatrix(demoAdjMatrix2, string_of_t2);\n\nprint_string("\\nExample 3\\n");\nlet nodes3 = ["red", "green", "yellow"];\nlet demoAdjMatrix3 = (nodes3, ((i, j)) => {\n  switch ((i, j)) {\n  | ("red", "green") => true\n  | ("green", "yellow") => true\n  | ("yellow", "red") => true\n  | _ => false\n  }\n});\nlet demoPairs3 = pairs_of_adjmatrix(demoAdjMatrix3);\nlet demoAdjList3 = adjlist_of_adjmatrix(demoAdjMatrix3);\n\nprint_string("Pairs\\n");\nshowPairs(demoPairs3, s => s);\nprint_string("Adjacency List:\\n");\nshowAdjList(demoAdjList3, s => s);\nprint_string("Adjacency Matrix:\\n");\nshowAdjMatrix(demoAdjMatrix3, s => s);\n')),Object(m.b)("p",null,"Here is a collection of functions to render a graph (represented as pairs) with DPoodle:"),Object(m.b)("pre",null,Object(m.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),'type graphLayout(\'n) = (list((\'n, (float, float))), list((\'n, \'n)));\n\nlet layoutCircle = ((nodes, pairs), radius)=> {\n  let a = 360. /. float_of_int(List.length(nodes));\n  let locs = List.mapi((i, node) => (node, polar(radius, a *. float_of_int(i))), nodes);\n  (locs, pairs)\n};\n\nlet renderLayout = ((locs, pairs), string_of_node) => {\n  let nodeRadius = 10.;\n  let arrowLength = 5.;\n  let arrowAngle = radians(30.);\n  let loopOut = radians(240.);\n  let loopIn = radians(300.);\n  let nodes = List.map(((node, p)) => {\n      translateP(p,\n        stroke(Color("none"), fill(Color("black"), text(string_of_node(node))))\n        +++ stroke(Color("black"), fill(Color("white"), circle(nodeRadius))))\n    }, locs);\n  let edges = List.map(((n1, n2)) => {\n      if (n1 == n2) {\n        let p = List.assoc(n1, locs);\n        let (x, y) = p;\n        let p1 = (x +. nodeRadius *. cos(loopOut), y +. nodeRadius *. sin(loopOut));\n        let p2 = (x +. nodeRadius *. cos(loopIn), y +. nodeRadius *. sin(loopIn));\n        let c1 = (x +. 3. *. nodeRadius *. cos(loopOut), y +. 3. *. nodeRadius *. sin(loopOut));\n        let c2 = (x +. 3. *. nodeRadius *. cos(loopIn), y +. 3. *. nodeRadius *. sin(loopIn));\n        let (x2, y2) = p2;\n        let p3 = (x2 +. arrowLength *. cos(loopIn +. arrowAngle), y2 +. arrowLength *. sin(loopIn +. arrowAngle));\n        let p4 = (x2 +. arrowLength *. cos(loopIn -. arrowAngle), y2 +. arrowLength *. sin(loopIn -. arrowAngle));\n        stroke(Color("black"), openPath([moveP(p1), curveP(c1, c2, p2), moveP(p2), lineP(p3), moveP(p2), lineP(p4)]))\n      } else {\n        let p1 = List.assoc(n1, locs);\n        let p2 = List.assoc(n2, locs);\n        let (x1, y1) = p1;\n        let (x2, y2) = p2;\n        let dx = x2 -. x1;\n        let dy = y2 -. y1;\n        let a = atan2(dy, dx);\n        let p3 = (x2 -. nodeRadius *. cos(a), y2 -. nodeRadius *. sin(a));\n        let (x3, y3) = p3;\n        let p4 = (x3 -. arrowLength *. cos(a +. arrowAngle), y3 -. arrowLength *. sin(a +. arrowAngle));\n        let p5 = (x3 -. arrowLength *. cos(a -. arrowAngle), y3 -. arrowLength *. sin(a -. arrowAngle));\n        stroke(Color("black"), openPath([moveP(p1), lineP(p2), moveP(p3), lineP(p4), moveP(p3), lineP(p5)]))\n      }\n    }, pairs);\n  let nodeImage = List.fold_left((+++), empty, nodes);\n  let edgeImage = List.fold_left((+++), empty, edges);\n  nodeImage +++ edgeImage\n};\n\ndraw(renderLayout(layoutCircle(demoPairs1, 50.), string_of_int));\ndraw(renderLayout(layoutCircle(demoPairs2, 50.), string_of_t2));\ndraw(renderLayout(layoutCircle(demoPairs3, 50.), s => s));\n/* TODO add custom style functions to nodes and edges */\n')))}i.isMDXComponent=!0},199:function(e,a,t){"use strict";t.d(a,"a",(function(){return o})),t.d(a,"b",(function(){return O}));var n=t(0),s=t.n(n);function m(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function r(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function c(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?r(Object(t),!0).forEach((function(a){m(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function p(e,a){if(null==e)return{};var t,n,s=function(e,a){if(null==e)return{};var t,n,s={},m=Object.keys(e);for(n=0;n<m.length;n++)t=m[n],a.indexOf(t)>=0||(s[t]=e[t]);return s}(e,a);if(Object.getOwnPropertySymbols){var m=Object.getOwnPropertySymbols(e);for(n=0;n<m.length;n++)t=m[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var b=s.a.createContext({}),i=function(e){var a=s.a.useContext(b),t=a;return e&&(t="function"==typeof e?e(a):c({},a,{},e)),t},o=function(e){var a=i(e.components);return s.a.createElement(b.Provider,{value:a},e.children)},l={inlineCode:"code",wrapper:function(e){var a=e.children;return s.a.createElement(s.a.Fragment,{},a)}},j=Object(n.forwardRef)((function(e,a){var t=e.components,n=e.mdxType,m=e.originalType,r=e.parentName,b=p(e,["components","mdxType","originalType","parentName"]),o=i(t),j=n,O=o["".concat(r,".").concat(j)]||o[j]||l[j]||m;return t?s.a.createElement(O,c({ref:a},b,{components:t})):s.a.createElement(O,c({ref:a},b))}));function O(e,a){var t=arguments,n=a&&a.mdxType;if("string"==typeof e||n){var m=t.length,r=new Array(m);r[0]=j;var c={};for(var p in a)hasOwnProperty.call(a,p)&&(c[p]=a[p]);c.originalType=e,c.mdxType="string"==typeof e?e:n,r[1]=c;for(var b=2;b<m;b++)r[b]=t[b];return s.a.createElement.apply(null,r)}return s.a.createElement.apply(null,t)}j.displayName="MDXCreateElement"}}]);