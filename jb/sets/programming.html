

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Programming with Sets &#8212; FoCSipedia</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" integrity="sha384-KA6wR/X5RY4zFAHpv/CnoG2UW1uogYfdnP67Uv7eULvTveboZJg0qUpmJZb5VqzN" crossorigin="anonymous">
    <link href="../_static/css/index.css" rel="stylesheet">
    <link rel="stylesheet" href="../_static/sphinx-book-theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/jupyter-sphinx.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/sphinx-book-theme.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/mystnb.js"></script>
    <script src="../_static/sphinx-book-theme.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Functions" href="functions.html" />
    <link rel="prev" title="Boolean Algebra of Sets" href="algebra.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="docsearch:language" content="en">



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../index.html">
  
  <img src="../_static/SmartFoxLogo.jpeg" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">FoCSipedia</h1>
  
</a>
</div>

<form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>

<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <ul class="current nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../attribution.html">
   Attribution
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../topics.html">
   Topics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../overview.html">
   Overview of Topics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../logic/index.html">
   Logic
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="reference internal" href="index.html">
   Sets
  </a>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="concepts.html">
     Set Concepts
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="algebra.html">
     Boolean Algebra of Sets
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Programming with Sets
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="functions.html">
     Functions
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fp/index.html">
   Functional Programming
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../ds/index.html">
   Data Structures
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../lang/index.html">
   Formal Languages
  </a>
 </li>
</ul>

</nav>

 <!-- To handle the deprecated key -->

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        <div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    
    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/sets/programming.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
    
</div>
        <!-- Source interaction buttons -->


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> On this page
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#operations-on-binary-numbers">
   Operations on Binary Numbers
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#bit-masks">
   Bit masks
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#binary-numbers-in-reasonml">
   Binary numbers in ReasonML
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#exercises">
   Exercises
  </a>
 </li>
</ul>

        </nav>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="programming-with-sets">
<h1>Programming with Sets<a class="headerlink" href="#programming-with-sets" title="Permalink to this headline">¶</a></h1>
<p>(Content adapted from Critchlow &amp; Eck)</p>
<p>On a computer, all data are represented, ultimately, as strings
of zeros and ones. At times, computers need to work with
sets. How can sets be represented as strings of zeros and ones?</p>
<p>A set is determined by its elements. Given a set <span class="math notranslate nohighlight">\(A\)</span> and an
entity <span class="math notranslate nohighlight">\(x\)</span>, the fundamental question is, does <span class="math notranslate nohighlight">\(x\)</span> belong to <span class="math notranslate nohighlight">\(A\)</span>
or not? If we know the answer to this question for each possible
<span class="math notranslate nohighlight">\(x\)</span>, then we know the set. For a given <span class="math notranslate nohighlight">\(x\)</span>, the answer to the
question, “Is <span class="math notranslate nohighlight">\(x\)</span> a member of <span class="math notranslate nohighlight">\(A\)</span>,” is either <em>yes</em> or
<em>no</em>. The answer can be encoded by letting 1 stand for
yes and 0 stand for no. The answer, then, is a single
<strong>bit</strong>, that is, a value that can be either zero or one.
To represent the set <span class="math notranslate nohighlight">\(A\)</span> as a string of zeros and ones,
we could use one bit for each possible member of <span class="math notranslate nohighlight">\(A\)</span>.
If a possible member <span class="math notranslate nohighlight">\(x\)</span> is in the set, then the corresponding
bit has the value one. If <span class="math notranslate nohighlight">\(x\)</span> is not in the set, then the
corresponding bit has the value zero.</p>
<p>Now, in cases where the number of possible elements of the set
is very large or infinite, it is not practical to represent the
set in this way. It would require too many bits, perhaps an infinite
number. In such cases, some other representation for the set
can be used. However, suppose we are only interested in subsets
of some specified small set. Since this set plays the role of
a universal set, let’s call it <span class="math notranslate nohighlight">\(U\)</span>. To represent a subset of
<span class="math notranslate nohighlight">\(U\)</span>, we just need one bit for each member of <span class="math notranslate nohighlight">\(U\)</span>. If the number of members
of <span class="math notranslate nohighlight">\(U\)</span> is <span class="math notranslate nohighlight">\(n\)</span>, then a subset of <span class="math notranslate nohighlight">\(U\)</span> is represented by a string
of <span class="math notranslate nohighlight">\(n\)</span> zeros and ones. Furthermore, every string of <span class="math notranslate nohighlight">\(n\)</span> zeros
and ones determines a subset of <span class="math notranslate nohighlight">\(U\)</span>, namely that subset
that contains exactly the elements of <span class="math notranslate nohighlight">\(U\)</span> that correspond to
ones in the string. A string of <span class="math notranslate nohighlight">\(n\)</span> zeros and ones is
called an <span class="math notranslate nohighlight">\(n\)</span>-bit <strong>binary number</strong>. So, we see that if
<span class="math notranslate nohighlight">\(U\)</span> is a set with <span class="math notranslate nohighlight">\(n\)</span> elements, then the subsets of <span class="math notranslate nohighlight">\(U\)</span> correspond
to <span class="math notranslate nohighlight">\(n\)</span>-bit binary numbers.</p>
<p>To make things more definite, let <span class="math notranslate nohighlight">\(U\)</span> be the set <span class="math notranslate nohighlight">\(\{0,1,2,\dots,31\}\)</span>.
This set consists of the 32 integers between 0 and 31, inclusive.
Then each subset of <span class="math notranslate nohighlight">\(U\)</span> can be represented by a 32-bit binary
number. We use 32 bits because most computer languages can work
directly with 32-bit numbers. For example, the programming
languages Java, C, and C++ have a data type named <em>int</em>.
A value of type <em>int</em> is a 32-bit binary number.[^Actually, in
some versions of C and C++, a value of type <em>int</em> is a 16-bit
number, while in others it is a 64-bit number. A 16-bit
number can be used to represent a subset of
the set <span class="math notranslate nohighlight">\(\{0,1,2,\dots,15\}\)</span>. The principle, of course, is the same.]
Before we get a definite correspondence between subsets of
<span class="math notranslate nohighlight">\(U\)</span> and 32-bit numbers, we have to decide which bit in the number
will correspond to each member of <span class="math notranslate nohighlight">\(U\)</span>. Following tradition,
we assume that the bits are numbered from right to left. That
is, the rightmost bit corresponds to the element 0 in <span class="math notranslate nohighlight">\(U\)</span>,
the second bit from the right corresponds to 1, the third bit
from the right to 2, and so on. For example, the 32-bit number</p>
<div class="math notranslate nohighlight">
\[1000000000000000000001001110110\]</div>
<p>corresponds to the subset <span class="math notranslate nohighlight">\(\{1,2,4,5,6,9,31\}\)</span>. Since the leftmost
bit of the number is 1, the number 31 is in the set; since the
next bit is 0, the number 30 is not in the set; and so on.</p>
<p>From now on,
I will write binary numbers with a subscript of 2 to avoid confusion
with ordinary numbers. Furthermore, I will often leave out leading
zeros. For example, 1101$_2$ is the binary number that would
be written out in full as</p>
<div class="math notranslate nohighlight">
\[00000000000000000000000000001101\]</div>
<p>and which corresponds to the set <span class="math notranslate nohighlight">\(\{0,2,3\}\)</span>. On the other hand
1101 represents the ordinary number one thousand one hundred and one.</p>
<p>Even with this notation, it can be very annoying to write out long
binary numbers—and almost impossible to read them. So binary numbers
are almost never written out as sequences of zeros and ones in computer
programs. An alternative is to use <strong>hexadecimal
numbers</strong>. Hexadecimal numbers are written using the sixteen
symbols 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, and F.
These symbols are knows as the hexadecimal digits. Each hexadecimal
digit corresponds to a 4-bit binary number, as shown in
this table:</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="text-align:center head"><p><strong>Hex</strong>.</p></th>
<th class="text-align:center head"><p><strong>Binary</strong></p></th>
<th class="text-align:center head"><p><strong>Hex</strong>.</p></th>
<th class="text-align:center head"><p><strong>Binary</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-align:center"><p>0</p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(0000_2\)</span></p></td>
<td class="text-align:center"><p>8</p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(1000_2\)</span></p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p>1</p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(0001_2\)</span></p></td>
<td class="text-align:center"><p>9</p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(1001_2\)</span></p></td>
</tr>
<tr class="row-even"><td class="text-align:center"><p>2</p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(0010_2\)</span></p></td>
<td class="text-align:center"><p>A</p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(1010_2\)</span></p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p>3</p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(0011_2\)</span></p></td>
<td class="text-align:center"><p>B</p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(1011_2\)</span></p></td>
</tr>
<tr class="row-even"><td class="text-align:center"><p>4</p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(0100_2\)</span></p></td>
<td class="text-align:center"><p>C</p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(1100_2\)</span></p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p>5</p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(0101_2\)</span></p></td>
<td class="text-align:center"><p>D</p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(1101_2\)</span></p></td>
</tr>
<tr class="row-even"><td class="text-align:center"><p>6</p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(0110_2\)</span></p></td>
<td class="text-align:center"><p>E</p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(1110_2\)</span></p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p>7</p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(0111_2\)</span></p></td>
<td class="text-align:center"><p>F</p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(1111_2\)</span></p></td>
</tr>
</tbody>
</table>
<p>To represent a longer binary number, several
hexadecimal digits can be strung together. For example,
the hexadecimal number C7 represents the binary number
11000111$_2$. In Java and many related languages, a hexadecimal
number is written with the prefix “0x”. Thus, the hexadecimal
number C7 would appear in the program as 0xC7. I will follow
the same convention here. Any 32-bit binary number can be written
using eight hexadecimal digits (or fewer if leading zeros are omitted).
Thus, subsets of <span class="math notranslate nohighlight">\(\{0,1,2,\dots,31\}\)</span> correspond to
8-digit hexadecimal numbers. For example,
the subset <span class="math notranslate nohighlight">\(\{1,2,4,5,6,9,31\}\)</span> corresponds to
0x80000276, which represents the binary number
1000000000000000000001001110110$_2$. Similarly,
0xFF corresponds to <span class="math notranslate nohighlight">\(\{0,1,2,3,4,5,6,7\}\)</span> and
0x1101 corresponds to the binary number 0001000100000001$_2$
and to the set <span class="math notranslate nohighlight">\(\{0,8,12\}\)</span>.</p>
<p>Now, if you have worked with binary numbers or with hexadecimal
numbers, you know that they have another, more common interpretation.
They represent ordinary integers. Just as 342 represents the
integer <span class="math notranslate nohighlight">\(3\cdot 10^2 + 4\cdot 10^1 +2\cdot 10^0\)</span>, the
binary number 1101$_2$ represents the integer
<span class="math notranslate nohighlight">\(1\cdot 2^3 +1\cdot 2^2 +0\cdot 2^1 +1\cdot 2^0\)</span>, or 13.
When used in this way, binary numbers are known as
<strong>base-2 numbers</strong>, just as ordinary numbers
are base-10 numbers. Hexadecimal numbers can be interpreted
as base-16 numbers. For example, 0x3C7 represents the
integer <span class="math notranslate nohighlight">\(3\cdot 16^2 + 12\cdot 16^1 + 7\cdot 16^0\)</span>, or 874.
So, does 1101$_2$ really represent the integer 13, or does it
represent the set <span class="math notranslate nohighlight">\(\{0,2,3\}\,\)</span>? The answer is that to a person,
1101$_2$ can represent either. Both are valid interpretations,
and the only real question is which interpretation is useful in
a given circumstance. On the other hand, to the computer,
1101$_2$ doesn’t represent <em>anything</em>. It’s just a string
of bits, and the computer manipulates the bits according to its
program, without regard to their interpretation.</p>
<p>Of course, we still have to answer the question of whether it
is ever useful to interpret strings of bits in a computer as
representing sets.</p>
<div class="section" id="operations-on-binary-numbers">
<h2>Operations on Binary Numbers<a class="headerlink" href="#operations-on-binary-numbers" title="Permalink to this headline">¶</a></h2>
<p>If all we could do with sets were to “represent” them, it wouldn’t
be very useful. We need to be able to compute with sets. That
is, we need to be able to perform set operations such as
union and complement.</p>
<p>Many programming languages provide operators that perform set
operations. In Java and related languages, the operators
that perform union, intersection, and complement are written
as <span class="math notranslate nohighlight">\(\,|\,\)</span>, <span class="math notranslate nohighlight">\(\&amp;\)</span>, and <span class="math notranslate nohighlight">\(\sim\)</span>. For example,
if <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> are 32-bit integers representing two subsets,
<span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span>, of <span class="math notranslate nohighlight">\(\{0,1,2,\dots,31\}\)</span>, then
<span class="math notranslate nohighlight">\(x\,|\,y\)</span> is a 32-bit integer that represents the set <span class="math notranslate nohighlight">\(X\cup Y\)</span>.
Similarly, <span class="math notranslate nohighlight">\(x\,\&amp;\,y\)</span> represents the set <span class="math notranslate nohighlight">\(X\cap Y\)</span>, and
<span class="math notranslate nohighlight">\(\sim x\)</span> represents the complement,
<span class="math notranslate nohighlight">\(\overline{X}\)</span>.</p>
<p>The operators <span class="math notranslate nohighlight">\(\,|\,\)</span>, &amp;, and <span class="math notranslate nohighlight">\(\sim\)</span>
are called <strong>bitwise logical operators</strong>
because of the way they operate on the individual bits of the numbers
to which they are applied. The languages descended from C have one more bitwise logical
operator: <span class="math notranslate nohighlight">\(a\,^\wedge\,b\)</span> takes the exclusive-OR at each
corresponding bit position of <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span>. Recall that the
exclusive-OR, also written <span class="math notranslate nohighlight">\(p\oplus q\)</span>, is the variation
of OR that is true when either <span class="math notranslate nohighlight">\(p\)</span> or <span class="math notranslate nohighlight">\(q\)</span> is true, but not both.
If 0 and 1 are interpreted as the
logical values <em>false</em> and <em>true</em>, then the
bitwise logical operators perform the logical operations
<span class="math notranslate nohighlight">\(\lor\)</span>, <span class="math notranslate nohighlight">\(\land\)</span>, <span class="math notranslate nohighlight">\(\lnot\)</span>, and <span class="math notranslate nohighlight">\(\oplus\)</span> on individual bits. To see why this
is true, let’s look at the computations that these operators
have to perform.</p>
<p>Let <span class="math notranslate nohighlight">\(k\)</span> be one of the members of <span class="math notranslate nohighlight">\(\{0,1,2,\dots,31\}\)</span>. In the
binary numbers <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span>, <span class="math notranslate nohighlight">\(x\,|\,y\)</span>, <span class="math notranslate nohighlight">\(x\,\&amp;\,y\)</span>, and <span class="math notranslate nohighlight">\(\sim x\)</span>,
the number <span class="math notranslate nohighlight">\(k\)</span> corresponds to the bit in position <span class="math notranslate nohighlight">\(k\)</span>. That is,
<span class="math notranslate nohighlight">\(k\)</span> is in the set represented by a binary number if and only if the
bit in position <span class="math notranslate nohighlight">\(k\)</span> in that binary number is 1.
Considered as sets, <span class="math notranslate nohighlight">\(x\,\&amp;\,y\)</span> is the intersection of <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>,
so <span class="math notranslate nohighlight">\(k\)</span> is a member of the set represented by <span class="math notranslate nohighlight">\(x\,\&amp;\,y\)</span> if and only if
<span class="math notranslate nohighlight">\(k\)</span> is a member of both of the sets represented by <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>.
That is, bit <span class="math notranslate nohighlight">\(k\)</span> is 1 in the binary number <span class="math notranslate nohighlight">\(x\,\&amp;\,y\)</span> if and only if bit
<span class="math notranslate nohighlight">\(k\)</span> is 1 in <span class="math notranslate nohighlight">\(x\)</span> and bit <span class="math notranslate nohighlight">\(k\)</span> is 1 in <span class="math notranslate nohighlight">\(y\)</span>. When we interpret
1 as <em>true</em> and 0 as <em>false</em>, we see that
bit <span class="math notranslate nohighlight">\(k\)</span> of <span class="math notranslate nohighlight">\(x\,\&amp;\,y\)</span> is computed by applying the logical “and”
operator, <span class="math notranslate nohighlight">\(\land\)</span>, to bit <span class="math notranslate nohighlight">\(k\)</span> of <span class="math notranslate nohighlight">\(x\)</span> and bit <span class="math notranslate nohighlight">\(k\)</span> of <span class="math notranslate nohighlight">\(y\)</span>.
Similarly, bit <span class="math notranslate nohighlight">\(k\)</span> of <span class="math notranslate nohighlight">\(x\,|\,y\)</span> is computed by applying the
logical “or” operator, <span class="math notranslate nohighlight">\(\lor\)</span>, to bit <span class="math notranslate nohighlight">\(k\)</span> of <span class="math notranslate nohighlight">\(x\)</span> and bit <span class="math notranslate nohighlight">\(k\)</span> of <span class="math notranslate nohighlight">\(y\)</span>.
And bit <span class="math notranslate nohighlight">\(k\)</span> of <span class="math notranslate nohighlight">\(\sim x\)</span> is computed by applying the
logical “not” operator, <span class="math notranslate nohighlight">\(\lnot\)</span>, to bit <span class="math notranslate nohighlight">\(k\)</span> of <span class="math notranslate nohighlight">\(x\)</span>. In each
case, the logical operator is applied to each bit position
separately. (Of course, this discussion is just a translation
to the language of bits of the definitions of the set
operations in terms of logical operators:
<span class="math notranslate nohighlight">\(A\cap B=\{x\mid x\in A \land x\in B\}\)</span>,
<span class="math notranslate nohighlight">\(A\cup B=\{x\mid x\in A \lor x\in B\}\)</span>, and
<span class="math notranslate nohighlight">\(\overline{A}=\{x\in U\mid \lnot(x\in A)\}\)</span>.)</p>
<p>For example, consider the binary numbers 1011010$_2$ and
10111$_2$, which represent the sets <span class="math notranslate nohighlight">\(\{1,3,4,6\}\)</span> and
<span class="math notranslate nohighlight">\(\{0,1,2,4\}\)</span>. Then 1011010$_2$ <span class="math notranslate nohighlight">\(\&amp;\)</span> 10111$_2$ is
10010$_2$. This binary number represents the set <span class="math notranslate nohighlight">\(\{1,4\}\)</span>,
which is the intersection <span class="math notranslate nohighlight">\(\{1,3,4,6\}\cap\{0,1,2,4\}\)</span>.
It’s easier to see what’s going on if we write out the
computation in columns, the way you probably first learned to
do addition:</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="text-align:right head"><p></p></th>
<th class="text-align:right head"><p></p></th>
<th class="text-align:right head"><p></p></th>
<th class="head"><p></p></th>
<th class="head"><p></p></th>
<th class="head"><p></p></th>
<th class="head"><p></p></th>
<th class="head"><p></p></th>
<th class="head"><p></p></th>
<th class="head"><p></p></th>
<th class="text-align:left head"><p></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-align:right"><p></p></td>
<td class="text-align:right"><p>1 0 1 1 0 1 0</p></td>
<td class="text-align:right"><p><span class="math notranslate nohighlight">\(\{\)</span></p></td>
<td><p>6,</p></td>
<td><p></p></td>
<td><p>4,</p></td>
<td><p>3,</p></td>
<td><p></p></td>
<td><p>1</p></td>
<td><p></p></td>
<td class="text-align:left"><p><span class="math notranslate nohighlight">\(\}\)</span></p></td>
</tr>
<tr class="row-odd"><td class="text-align:right"><p><span class="math notranslate nohighlight">\(\&amp;\)</span></p></td>
<td class="text-align:right"><p>1 0 1 1 1</p></td>
<td class="text-align:right"><p><span class="math notranslate nohighlight">\(\{\)</span></p></td>
<td><p></p></td>
<td><p></p></td>
<td><p>4,</p></td>
<td><p></p></td>
<td><p>2,</p></td>
<td><p>1,</p></td>
<td><p>0</p></td>
<td class="text-align:left"><p><span class="math notranslate nohighlight">\(\}\)</span></p></td>
</tr>
<tr class="row-even"><td class="text-align:right"><p><span class="math notranslate nohighlight">\(=\)</span></p></td>
<td class="text-align:right"><p>1 0 0 1 0</p></td>
<td class="text-align:right"><p><span class="math notranslate nohighlight">\(\{\)</span></p></td>
<td><p></p></td>
<td><p></p></td>
<td><p>4,</p></td>
<td><p></p></td>
<td><p></p></td>
<td><p>1</p></td>
<td><p></p></td>
<td class="text-align:left"><p><span class="math notranslate nohighlight">\(\}\)</span></p></td>
</tr>
</tbody>
</table>
<p>Note that in each column in the binary numbers, the bit in the
bottom row is computed as the logical “and” of the two bits
that lie above it in the column. I’ve written out the sets that
correspond to the binary numbers to show how the bits in the
numbers correspond to the presence or absence of elements in the sets.
Similarly, we can see how the union of two sets is computed as
a bitwise “or” of the corresponding binary numbers.</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="text-align:right head"><p></p></th>
<th class="text-align:right head"><p></p></th>
<th class="text-align:right head"><p></p></th>
<th class="head"><p></p></th>
<th class="head"><p></p></th>
<th class="head"><p></p></th>
<th class="head"><p></p></th>
<th class="head"><p></p></th>
<th class="head"><p></p></th>
<th class="head"><p></p></th>
<th class="text-align:left head"><p></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-align:right"><p></p></td>
<td class="text-align:right"><p>1 0 1 1 0 1 0</p></td>
<td class="text-align:right"><p><span class="math notranslate nohighlight">\(\{\)</span></p></td>
<td><p>6,</p></td>
<td><p></p></td>
<td><p>4,</p></td>
<td><p>3,</p></td>
<td><p></p></td>
<td><p>1</p></td>
<td><p></p></td>
<td class="text-align:left"><p><span class="math notranslate nohighlight">\(\}\)</span></p></td>
</tr>
<tr class="row-odd"><td class="text-align:right"><p><span class="math notranslate nohighlight">\(\mid\)</span></p></td>
<td class="text-align:right"><p>1 0 1 1 1</p></td>
<td class="text-align:right"><p><span class="math notranslate nohighlight">\(\{\)</span></p></td>
<td><p></p></td>
<td><p></p></td>
<td><p>4,</p></td>
<td><p></p></td>
<td><p>2,</p></td>
<td><p>1,</p></td>
<td><p>0</p></td>
<td class="text-align:left"><p><span class="math notranslate nohighlight">\(\}\)</span></p></td>
</tr>
<tr class="row-even"><td class="text-align:right"><p><span class="math notranslate nohighlight">\(=\)</span></p></td>
<td class="text-align:right"><p>1 0 1 1 1 1 1</p></td>
<td class="text-align:right"><p><span class="math notranslate nohighlight">\(\{\)</span></p></td>
<td><p>6,</p></td>
<td><p></p></td>
<td><p>4,</p></td>
<td><p>3,</p></td>
<td><p>2,</p></td>
<td><p>1,</p></td>
<td><p>0</p></td>
<td class="text-align:left"><p><span class="math notranslate nohighlight">\(\}\)</span></p></td>
</tr>
</tbody>
</table>
<p>The complement of a set is computed using a bitwise “not” operation.
Since we are working with 32-bit binary numbers, the complement is
taken with respect to the universal set <span class="math notranslate nohighlight">\(\{0,1,2,\dots,31\}\)</span>.
So, for example,</p>
<div class="math notranslate nohighlight">
\[\sim 1011010_2 = 11111111111111111111111110100101_2\]</div>
<p>Of course, we can apply the operators <span class="math notranslate nohighlight">\(\&amp;\)</span>, <span class="math notranslate nohighlight">\(\,|\,\)</span>, and <span class="math notranslate nohighlight">\(\sim\)</span>
to numbers written in hexadecimal form, or even in ordinary, base-10
form. When doing such calculations by hand, it is probably best
to first translate the numbers into binary form. For example,</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="text-align:right head"><p></p></th>
<th class="text-align:left head"><p></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-align:right"><p>0xAB7 &amp; 0x168E</p></td>
<td class="text-align:left"><p><span class="math notranslate nohighlight">\(= 1010\,1011\,0111_2\,\&amp;\,1\,0110\,1000\,1110_2\)</span></p></td>
</tr>
<tr class="row-odd"><td class="text-align:right"><p></p></td>
<td class="text-align:left"><p><span class="math notranslate nohighlight">\(= 0\,0010\,1000\,0110_2\)</span></p></td>
</tr>
<tr class="row-even"><td class="text-align:right"><p></p></td>
<td class="text-align:left"><p><span class="math notranslate nohighlight">\(=\)</span> 0x286</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="bit-masks">
<h2>Bit masks<a class="headerlink" href="#bit-masks" title="Permalink to this headline">¶</a></h2>
<p>When computing with sets, it is sometimes necessary to work
with individual elements. Typical operations include adding
an element to a set, removing an element from a set, and
testing whether an element is in a set. However, instead of
working with an element itself, it’s convenient to work with
the set that contains that element as its only member. For example,
testing whether <span class="math notranslate nohighlight">\(5\in A\)</span> is the same as testing whether
<span class="math notranslate nohighlight">\(\{5\}\cap A\not=\emptyset\)</span>. The set <span class="math notranslate nohighlight">\(\{5\}\)</span> is represented by
the binary number 100000$_2$ or by the hexadecimal number 0x20.
Suppose that the set <span class="math notranslate nohighlight">\(A\)</span> is represented by the number <span class="math notranslate nohighlight">\(x\)</span>.
Then, testing whether <span class="math notranslate nohighlight">\(5\in A\)</span> is equivalent to testing
whether 0x20 <span class="math notranslate nohighlight">\(\&amp;\)</span> <span class="math notranslate nohighlight">\(x\not=0\)</span>. Similarly, the set
<span class="math notranslate nohighlight">\(A\cup\{5\}\)</span>, which is obtained by adding 5 to <span class="math notranslate nohighlight">\(A\)</span>, can
be computed as <span class="math notranslate nohighlight">\(x\)</span> <span class="math notranslate nohighlight">\(|\)</span> 0x20. The set <span class="math notranslate nohighlight">\(A\smallsetminus \{5\}\)</span>,
which is the set obtained by removing 5 from <span class="math notranslate nohighlight">\(A\)</span> if it occurs in <span class="math notranslate nohighlight">\(A\)</span>,
is represented by $x,&amp;,\sim$0x20.</p>
<p>The sets <span class="math notranslate nohighlight">\(\{0\}\)</span>, <span class="math notranslate nohighlight">\(\{1\}\)</span>, <span class="math notranslate nohighlight">\(\{2\}\)</span>, <span class="math notranslate nohighlight">\(\{3\}\)</span>, <span class="math notranslate nohighlight">\(\{4\}\)</span>, <span class="math notranslate nohighlight">\(\{5\}\)</span>, <span class="math notranslate nohighlight">\(\{6\}\)</span>, \dots, <span class="math notranslate nohighlight">\(\{31\}\)</span> are
represented by the hexadecimal numbers 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, \dots, 0x80000000.
In typical computer applications, some of these numbers are given names,
and these names are thought of as names for the possible elements of a set
(although, properly speaking, they are names for sets containing those elements).
Suppose, for example, that <span class="math notranslate nohighlight">\(a\)</span>, <span class="math notranslate nohighlight">\(b\)</span>, <span class="math notranslate nohighlight">\(c\)</span>, and <span class="math notranslate nohighlight">\(d\)</span> are names for four of the
numbers from the above list. Then <span class="math notranslate nohighlight">\(a\,|\,c\)</span> is the set that contains
the two elements corresponding to the numbers <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(c\)</span>. If <span class="math notranslate nohighlight">\(x\)</span> is a
set, then <span class="math notranslate nohighlight">\(x\,\&amp;\,\sim d\)</span> is the set obtained by removing
<span class="math notranslate nohighlight">\(d\)</span> from <span class="math notranslate nohighlight">\(x\)</span>. And we can test whether <span class="math notranslate nohighlight">\(b\)</span> is in <span class="math notranslate nohighlight">\(x\)</span> by testing if
<span class="math notranslate nohighlight">\(x\,\&amp;\,b\not=0\)</span>.</p>
<p>Here is an actual example, which is used in the Macintosh operating system.
Characters can be printed or displayed on the screen in various sizes and
styles. A <strong>font</strong> is a collection of pictures of characters in a particular
size and style. On the Macintosh, a basic font can be modified by
specifying any of the following style attributes: <em>bold</em>,
<em>italic</em>, <em>underline</em>, <em>outline</em>, <em>shadow</em>,
<em>condense</em>, and <em>extend</em>. The style of a font is a subset
of this set of attributes. A style set can be specified by
or-ing together individual attributes. For example, an underlined, bold, italic
font has style set <em>underline</em> <span class="math notranslate nohighlight">\(|\)</span> <em>bold</em> <span class="math notranslate nohighlight">\(|\)</span> <em>italic</em>.
For a plain font, with none of the style attributes set, the style set
is the empty set, which is represented by the number zero.</p>
<p>The Java programming language uses a similar scheme to specify style
attributes for fonts, but currently there are only two basic
attributes, <code class="docutils literal notranslate"><span class="pre">Font.BOLD</span></code> and <code class="docutils literal notranslate"><span class="pre">Font.ITALIC</span></code>. A more
interesting example in Java is provided by event types. An event in
Java represents some kind of user action, such as pressing a key on the
keyboard. Events are associated with “components” such as windows,
push buttons, and scroll bars. Components can be set to ignore
a given type of event. We then say that that event type is disabled
for that component. If a component is set to process events of
a given type, then that event type is said to be enabled. Each
component keeps track of the set of event types that are currently
enabled. It will ignore any event whose type is not in that set.
Each event type has an associated constant with a name such
as <code class="docutils literal notranslate"><span class="pre">AWTEvent.MOUSE_EVENT_MASK</span></code>. These constants represent
the possible elements of a set of event types. A set of event types can be
specified by or-ing together a number of such constants. If
<span class="math notranslate nohighlight">\(c\)</span> is a component and <span class="math notranslate nohighlight">\(x\)</span> is a number representing a set of event
types, then the command “<span class="math notranslate nohighlight">\(c\)</span>.<em>enableEvents</em>(<span class="math notranslate nohighlight">\(x\)</span>)” enables the
events in the set <span class="math notranslate nohighlight">\(x\)</span> for the component <span class="math notranslate nohighlight">\(c\)</span>. If <span class="math notranslate nohighlight">\(y\)</span> represents
the set of event types that were already enabled for <span class="math notranslate nohighlight">\(c\)</span>, then the effect
of this command is to replace <span class="math notranslate nohighlight">\(y\)</span> with the union, <span class="math notranslate nohighlight">\(y\,|\,x\)</span>. Another
command, “<span class="math notranslate nohighlight">\(c\)</span>.<em>disableEvents</em>(<span class="math notranslate nohighlight">\(x\)</span>)”, will disable the
event types in <span class="math notranslate nohighlight">\(x\)</span> for the component <span class="math notranslate nohighlight">\(c\)</span>. It does this by replacing
the current set, <span class="math notranslate nohighlight">\(y\)</span>, with <span class="math notranslate nohighlight">\(y\,\&amp;\,\sim x\)</span>.</p>
<p>The bitwise operators are also useful when performing low-level bit manipulation,
such as when writing code that interfaces with hardware devices. A binary number
may be interpreted as a <strong>bit mask</strong>, where each 1 bit selects its bit
position. For example, the mask 01010000$_2$ selects the 64’s place and the
16’s place. One way to produce such a mask is to use another bit operator: the
<strong>shift</strong> (<code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>). The expression <span class="math notranslate nohighlight">\(x\,\texttt{&lt;&lt;}\,k\)</span> results in <span class="math notranslate nohighlight">\(x\)</span> being
shifted <span class="math notranslate nohighlight">\(k\)</span> bits to the left, with bits of 0 pushed in from the right
(effectively multiplying by <span class="math notranslate nohighlight">\(2^k\)</span>). Since <span class="math notranslate nohighlight">\(64=2^6\)</span> and <span class="math notranslate nohighlight">\(16=2^4\)</span>, the above mask
may be produced by <span class="math notranslate nohighlight">\(1\,\texttt{&lt;&lt;}\,6\;|\;1\,\texttt{&lt;&lt;}\,4\)</span>.</p>
<p>Using a mask <span class="math notranslate nohighlight">\(m\)</span>, the following simple operations are possible on a binary number <span class="math notranslate nohighlight">\(x\)</span>:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(x\,|\,m\)</span> turns on (sets to 1) all of the selected bits of <span class="math notranslate nohighlight">\(x\)</span>,
leaving the rest unchanged;</p></li>
<li><p><span class="math notranslate nohighlight">\(x\,\&amp;\,\sim m\)</span> turns off all of the selected bits of <span class="math notranslate nohighlight">\(x\)</span>;</p></li>
<li><p><span class="math notranslate nohighlight">\(x\,\&amp;\,m\)</span> turns off all of the <em>non</em>-selected bits of <span class="math notranslate nohighlight">\(x\)</span>;</p></li>
<li><p><span class="math notranslate nohighlight">\(x\,^\wedge\,m\)</span> “toggles” (flips between 0 and 1) all of the selected bits of <span class="math notranslate nohighlight">\(x\)</span>;</p></li>
<li><p><span class="math notranslate nohighlight">\(\sim x\)</span> toggles all of the bits of <span class="math notranslate nohighlight">\(x\)</span>.</p></li>
</ul>
<p>The following table shows samples of these operations:</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{array}{rl}
x:                         &amp; 01101011_2\\
m:                         &amp; 01010000_2\\ \hline
x\,|\,m:                   &amp; 01111011_2\\
x\,\&amp;\,\sim m: &amp; 00101011_2\\
x\,\&amp;\,m:                  &amp; 01000000_2\\
x\,^\wedge\,m:              &amp; 00111011_2\\
\sim x:        &amp; 10010100_2
\end{array} \end{split}\]</div>
</div>
<div class="section" id="binary-numbers-in-reasonml">
<h2>Binary numbers in ReasonML<a class="headerlink" href="#binary-numbers-in-reasonml" title="Permalink to this headline">¶</a></h2>
<p>You can try out various operations on binary numbers in the ReasonML code block below.
Here is a table of the corresponding number syntax and operations:</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="text-align:left head"><p>C++ and Java</p></th>
<th class="text-align:left head"><p>ReasonML</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-align:left"><p>0x2A</p></td>
<td class="text-align:left"><p>0x2A</p></td>
</tr>
<tr class="row-odd"><td class="text-align:left"><p>0b101010</p></td>
<td class="text-align:left"><p>0b101010</p></td>
</tr>
<tr class="row-even"><td class="text-align:left"><p>x &amp; y</p></td>
<td class="text-align:left"><p>x land y</p></td>
</tr>
<tr class="row-odd"><td class="text-align:left"><p>x <span class="math notranslate nohighlight">\(\mid\)</span> y</p></td>
<td class="text-align:left"><p>x lor y</p></td>
</tr>
<tr class="row-even"><td class="text-align:left"><p>x ^ y</p></td>
<td class="text-align:left"><p>x lxor y</p></td>
</tr>
<tr class="row-odd"><td class="text-align:left"><p>~ x</p></td>
<td class="text-align:left"><p>lnot(x)</p></td>
</tr>
<tr class="row-even"><td class="text-align:left"><p>x &lt;&lt; n</p></td>
<td class="text-align:left"><p>x lsl n</p></td>
</tr>
<tr class="row-odd"><td class="text-align:left"><p>x &gt;&gt; n</p></td>
<td class="text-align:left"><p>x lsr n</p></td>
</tr>
</tbody>
</table>
<p>There is no simple way to print out a number in binary in ReasonML, but you can use
<code class="docutils literal notranslate"><span class="pre">Printf.sprintf(&quot;0x%x&quot;,</span> <span class="pre">n)</span></code> to convert <code class="docutils literal notranslate"><span class="pre">n</span></code> to a hexadecimal string.</p>
<div class="highlight-reason notranslate"><div class="highlight"><pre><span></span><span class="mh">0x2A</span>
</pre></div>
</div>
<p>Evaluate the code by pressing the button or hitting Ctrl-Enter.</p>
</div>
<div class="section" id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h2>
<ol class="simple">
<li><p>Suppose that the numbers <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> represent the
sets <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span>. Show that the set <span class="math notranslate nohighlight">\(A\smallsetminus B\)</span> is
represented by <span class="math notranslate nohighlight">\(x \,\&amp;\, (\sim y)\)</span>.</p></li>
<li><p>Write each of the following binary numbers in hexadecimal:</p>
<ul class="simple">
<li><p>10110110$_2$</p></li>
<li><p>10$_2$</p></li>
<li><p>111100001111$_2$</p></li>
<li><p>101001$_2$</p></li>
</ul>
</li>
<li><p>Write each of the following hexadecimal numbers in binary:</p>
<ul class="simple">
<li><p>0x123</p></li>
<li><p>0xFADE</p></li>
<li><p>0x137F</p></li>
<li><p>0xFF11</p></li>
</ul>
</li>
<li><p>Give the value of each of the following expressions
as a hexadecimal number:</p>
<ul class="simple">
<li><p>0x73 <span class="math notranslate nohighlight">\(|\)</span> 0x56A</p></li>
<li><p><span class="math notranslate nohighlight">\(\sim\)</span> 0x3FF0A2FF</p></li>
<li><p>(0x44 <span class="math notranslate nohighlight">\(|\)</span> 0x95) <span class="math notranslate nohighlight">\(\&amp;\)</span> 0xE7</p></li>
<li><p>0x5C35A7 <span class="math notranslate nohighlight">\(\&amp;\)</span> 0xFF00</p></li>
<li><p>0x5C35A7 <span class="math notranslate nohighlight">\(\&amp;\)</span> <span class="math notranslate nohighlight">\(\sim\)</span> 0xFF00</p></li>
<li><p><span class="math notranslate nohighlight">\(\sim\)</span>(0x1234 <span class="math notranslate nohighlight">\(\&amp;\)</span> 0x4321)</p></li>
</ul>
</li>
<li><p>Find a calculator (or a calculator program on a computer)
that can work with hexadecimal numbers. Write a short report
explaining how to work with hexadecimal numbers on that calculator.
You should explain, in particular, how the calculator can be used to
do the previous problem.</p></li>
<li><p>This question assumes that you know how to add binary numbers.
Suppose <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> are binary numbers. Under what circumstances
will the binary numbers <span class="math notranslate nohighlight">\(x+y\)</span> and <span class="math notranslate nohighlight">\(x\,|\,y\)</span> be the same?</p></li>
<li><p>In addition to hexadecimal numbers, the programming languages
Java, C, and C++ support <strong>octal numbers</strong>. Look up
and report on octal numbers in Java, C, or C++. Explain what octal
numbers are, how they are written, and how they are used.</p></li>
<li><p>In the UNIX (or Linux) operating system, every file has an associated
set of permissions, which determine who can use the file and how
it can be used. The set of permissions for a given file is represented
by a nine-bit binary number. This number is sometimes written as an
octal number. Research and report on the UNIX system of permissions.
What set of permissions is represented by the octal number 752?
by the octal number 622? Explain what is done by the UNIX commands
“chmod g+rw filename” and “chmod o-w filename” in terms of sets.
(Hint: Look at the <em>man</em> page for
the <em>chmod</em> command. To see the page, use the UNIX command
“man chmod”. If you don’t know what this means, you probably don’t
know enough about UNIX to do this exercise.)</p></li>
<li><p>Java, C, and C++ each have a boolean data type that has the values
<em>true</em> and <em>false</em>. The usual logical and, or, and not operators
on boolean values are represented by the operators <span class="math notranslate nohighlight">\(\&amp;\&amp;\)</span>, <span class="math notranslate nohighlight">\(|\,|\)</span>, and !.
C and C++ allow integer values to be used in places where boolean values
are expected. In this case, the integer zero represents the boolean
value <em>false</em> while any non-zero integer represents the boolean
value <em>true</em>. This means that if <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> are integers,
then both <span class="math notranslate nohighlight">\(x\,\&amp;\,y\)</span> and <span class="math notranslate nohighlight">\(x\,\&amp;\&amp;\,y\)</span> are valid expressions, and both can
be considered to represent boolean values. Do the expressions
<span class="math notranslate nohighlight">\(x\,\&amp;\,y\)</span> and <span class="math notranslate nohighlight">\(x\,\&amp;\&amp;\,y\)</span> always represent the same boolean value,
for any integers <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>? Do the expressions <span class="math notranslate nohighlight">\(x\,|\,y\)</span> and <span class="math notranslate nohighlight">\(x\,|\,|\,y\)</span>
always represent the same boolean values? Explain your answers.</p></li>
<li><p>Suppose that you, as a programmer, want to write a subroutine
that will open a window on the computer’s screen. The window can have
any of the following options: a close box, a zoom box, a resize box,
a minimize box, a vertical scroll bar, a horizontal scroll bar.
Design a scheme whereby the options for the window can be specified
by a single parameter to the subroutine. The parameter should represent
a set of options. How would you use your subroutine to open
a window that has a close box and both scroll bars and no other options?
Inside your subroutine, how would you determine which options have been
specified for the window?</p></li>
<li><p>Consider the following sequence of operations on two integer variables,
<span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> (again, this should work the same in all C-like languages):</p></li>
</ol>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">^</span> <span class="n">y</span><span class="p">;</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">^</span> <span class="n">x</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">^</span> <span class="n">y</span><span class="p">;</span>
</pre></div>
</div>
<p>What is the net effect of this sequence on the values stored in <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>?</p>
<ol class="simple">
<li><p>Bitwise operations are also useful when working with character data.
In the ASCII character encoding (which is also the first 128 characters of Unicode),
the digits ‘0’ through ‘9’ have codes 48 through 57; the uppercase latin alphabet,
‘A’ through ‘Z’, have 65 through 90, and the corresponding lowercase letters have
codes 97 through 122.</p></li>
</ol>
<ul class="simple">
<li><p>Convert the endpoints of each of these code ranges to binary.</p></li>
<li><p>Give an expression using only integer constants and bitwise operations that will convert the character code <span class="math notranslate nohighlight">\(c\)</span> for an ASCII digit into its corresponding integer value. Do not worry about what it will do to non-digits.</p></li>
<li><p>Give a similar expression that will convert an integer <span class="math notranslate nohighlight">\(n\)</span> in the range 0 to 9 into the corresponding ASCII digit code. Do not worry about error cases.</p></li>
<li><p>Give expressions that will take a letter whose ASCII code is <span class="math notranslate nohighlight">\(c\)</span> and</p>
<ol class="simple">
<li><p>convert it to uppercase,</p></li>
<li><p>convert it to lowercase, and</p></li>
<li><p>toggle it between upper- and lowercase. Do not worry about error cases.</p></li>
</ol>
</li>
</ul>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./sets"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="algebra.html" title="previous page">Boolean Algebra of Sets</a>
    <a class='right-next' id="next-link" href="functions.html" title="next page">Functions</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Brian T. Howard, based in part on material by Carol Critchlow and David Eck<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    <script src="../_static/js/index.js"></script>
    
  </body>
</html>