

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Finite-State Automata and Regular Languages &#8212; FoCSipedia</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" integrity="sha384-KA6wR/X5RY4zFAHpv/CnoG2UW1uogYfdnP67Uv7eULvTveboZJg0qUpmJZb5VqzN" crossorigin="anonymous">
    <link href="../_static/css/index.css" rel="stylesheet">
    <link rel="stylesheet" href="../_static/sphinx-book-theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/jupyter-sphinx.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/sphinx-book-theme.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/mystnb.js"></script>
    <script src="../_static/sphinx-book-theme.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Context-Free Grammars" href="cfg.html" />
    <link rel="prev" title="Nondeterministic Finite-State Automata" href="nfa.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="docsearch:language" content="en">



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../index.html">
  
  <img src="../_static/SmartFoxLogo.jpeg" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">FoCSipedia</h1>
  
</a>
</div>

<form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>

<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <ul class="current nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../attribution.html">
   Attribution
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../topics.html">
   Topics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../overview.html">
   Overview of Topics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../logic/index.html">
   Logic
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sets/index.html">
   Sets
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fp/index.html">
   Functional Programming
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../ds/index.html">
   Data Structures
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="reference internal" href="index.html">
   Formal Languages
  </a>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="languages.html">
     Languages
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="regexp.html">
     Regular Expressions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="regexpapp.html">
     Applications of Regular Expressions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="fsa.html">
     Finite-State Automata
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="nfa.html">
     Nondeterministic Finite-State Automata
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Finite-State Automata and Regular Languages
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="cfg.html">
     Context-Free Grammars
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="bnf.html">
     Backus-Naur Form
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="parsing.html">
     Parsing and Parse Trees
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="pda.html">
     Pushdown Automata
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="tm.html">
     General Grammars and Turing Machines
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="computability.html">
     Computability
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="halting.html">
     The Halting Problem
    </a>
   </li>
  </ul>
 </li>
</ul>

</nav>

 <!-- To handle the deprecated key -->

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        <div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    
    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/lang/fsareg.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
    
</div>
        <!-- Source interaction buttons -->


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> On this page
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#regular-expression-to-nfa">
   Regular Expression to NFA
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#nfa-to-regular-expression">
   NFA to Regular Expression
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#closure-properties-for-regular-languages">
   Closure Properties for Regular Languages
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#exercises">
   Exercises
  </a>
 </li>
</ul>

        </nav>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="finite-state-automata-and-regular-languages">
<h1>Finite-State Automata and Regular Languages<a class="headerlink" href="#finite-state-automata-and-regular-languages" title="Permalink to this headline">¶</a></h1>
<p>(Content adapted from Critchlow &amp; Eck)</p>
<p>We know now that our two models for mechanical language recognition actually
recognize the same class of languages. The question still remains: do they
recognize the same class of languages as the class generated mechanically by regular
expressions? The answer turns out to be “yes”. There are two parts to proving
this: first that every language generated can be recognized, and second that
every language recognized can be generated.</p>
<div class="section" id="regular-expression-to-nfa">
<h2>Regular Expression to NFA<a class="headerlink" href="#regular-expression-to-nfa" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p><strong>Theorem:</strong>
Every language generated by a regular expression can be recognized by an NFA.</p>
<p><strong>Proof:</strong> The proof of this theorem is a nice example of a proof by induction on
the structure of regular expressions. The definition of regular expression is
inductive: <span class="math notranslate nohighlight">\(\Phi\)</span>, <span class="math notranslate nohighlight">\(\varepsilon\)</span>, and <span class="math notranslate nohighlight">\(a\)</span> are the simplest regular expressions,
and then more complicated regular expressions can be built from these. We will
show that there are NFAs that accept the languages generated by the simplest
regular expressions, and then show how those machines can be put together to
form machines that accept languages generated by more complicated regular
expressions.</p>
<p>Consider the regular expression <span class="math notranslate nohighlight">\(\Phi\)</span>. <span class="math notranslate nohighlight">\(L(\Phi) = \{\}\)</span>. Here is a machine
that accepts <span class="math notranslate nohighlight">\(\{\}\)</span>:</p>
<p>&lt;img src={useBaseUrl(‘img/fsa12.png’)}
alt=”NFA for empty language” className=”centered-figure” /&gt;</p>
<p>Consider the regular expression <span class="math notranslate nohighlight">\(\varepsilon\)</span>. <span class="math notranslate nohighlight">\(L(\varepsilon) = \{\varepsilon\}\)</span>.
Here is a machine that accepts <span class="math notranslate nohighlight">\(\{\varepsilon\}\)</span>:</p>
</div></blockquote>
<p>&lt;img src={useBaseUrl(‘img/fsa13.png’)}
alt=”NFA for empty string” className=”centered-figure” /&gt;</p>
<blockquote>
<div><p>Consider the regular expression <span class="math notranslate nohighlight">\(a\)</span>. <span class="math notranslate nohighlight">\(L(a) = \{a\}\)</span>. Here is a
machine that accepts <span class="math notranslate nohighlight">\(\{a\}\)</span>:</p>
<p>&lt;img src={useBaseUrl(‘img/fsa14.png’)}
alt=”NFA for a” className=”centered-figure” /&gt;</p>
<p>Now suppose that you have NFAs that accept the languages generated by the
regular expressions <span class="math notranslate nohighlight">\(r_1\)</span> and <span class="math notranslate nohighlight">\(r_2\)</span>. Building a machine that accepts <span class="math notranslate nohighlight">\(L(r_1 |
r_2)\)</span> is fairly straightforward: take an NFA <span class="math notranslate nohighlight">\(M_1\)</span> that accepts <span class="math notranslate nohighlight">\(L(r_1)\)</span> and an
NFA <span class="math notranslate nohighlight">\(M_2\)</span> that accepts <span class="math notranslate nohighlight">\(L(r_2)\)</span>. Introduce a new state <span class="math notranslate nohighlight">\(q_{new}\)</span>, connect
it to the start states of <span class="math notranslate nohighlight">\(M_1\)</span> and <span class="math notranslate nohighlight">\(M_2\)</span> via <span class="math notranslate nohighlight">\(\varepsilon\)</span>-transitions, and
designate it as the start state of the new machine. No other transitions are
added. The final states of <span class="math notranslate nohighlight">\(M_1\)</span> together with the final states of <span class="math notranslate nohighlight">\(M_2\)</span> are
designated as the final states of the new machine. It should be fairly clear
that this new machine accepts exactly those strings accepted by <span class="math notranslate nohighlight">\(M_1\)</span> together
with those strings accepted by <span class="math notranslate nohighlight">\(M_2\)</span>: any string <span class="math notranslate nohighlight">\(w\)</span> that was accepted by <span class="math notranslate nohighlight">\(M_1\)</span>
will be accepted by the new NFA by starting with an <span class="math notranslate nohighlight">\(\varepsilon\)</span>-transition to the
old start state of <span class="math notranslate nohighlight">\(M_1\)</span> and then following the accepting path through <span class="math notranslate nohighlight">\(M_1\)</span>;
similarly, any string accepted by <span class="math notranslate nohighlight">\(M_2\)</span> will be accepted by the new machine;
these are the only strings that will be accepted by the new machine, as on any
input <span class="math notranslate nohighlight">\(w\)</span> all the new machine can do is make an <span class="math notranslate nohighlight">\(\varepsilon\)</span>-move to <span class="math notranslate nohighlight">\(M_1\)</span>’s (or
<span class="math notranslate nohighlight">\(M_2\)</span>’s) start state, and from there <span class="math notranslate nohighlight">\(w\)</span> will only be accepted by the new
machine if it is accepted by <span class="math notranslate nohighlight">\(M_1\)</span> (or <span class="math notranslate nohighlight">\(M_2\)</span>). Thus, the new machine accepts
<span class="math notranslate nohighlight">\(L(M_1) \cup L(M_2)\)</span>, which is <span class="math notranslate nohighlight">\(L(r_1) \cup L(r_2)\)</span>, which is exactly the
definition of <span class="math notranslate nohighlight">\(L(r_1 | r_2)\)</span>.</p>
<p>&lt;img src={useBaseUrl(‘img/fsa15.png’)}
alt=”NFA for r1 | r2” className=”centered-figure” /&gt;</p>
</div></blockquote>
<p>(A pause before we continue: note that for the simplest regular expressions,
the machines that we created to accept the languages generated by the regular
expressions were in fact DFAs. In our last case above, however, we needed
<span class="math notranslate nohighlight">\(\varepsilon\)</span>-transitions to build the new machine, and so if we were trying to
prove that every regular language could be accepted by a DFA, our proof would
be in trouble. THIS DOES NOT MEAN that the statement “every regular language
can be accepted by a DFA” is false, just that we can’t prove it using this kind
of argument, and would have to find an alternative proof.)</p>
<blockquote>
<div><p>Suppose you have machines <span class="math notranslate nohighlight">\(M_1\)</span> and <span class="math notranslate nohighlight">\(M_2\)</span> that accept <span class="math notranslate nohighlight">\(L(r_1)\)</span> and <span class="math notranslate nohighlight">\(L(r_2)\)</span>
respectively. To build a machine that accepts <span class="math notranslate nohighlight">\(L(r_1)L(r_2)\)</span> proceed as
follows. Make the start state <span class="math notranslate nohighlight">\(q_{01}\)</span> of <span class="math notranslate nohighlight">\(M_1\)</span> be the start state of the new
machine. Make the final states of <span class="math notranslate nohighlight">\(M_2\)</span> be the final states of the new machine.
Add <span class="math notranslate nohighlight">\(\varepsilon\)</span>-transitions from the final states of <span class="math notranslate nohighlight">\(M_1\)</span> to the start state
<span class="math notranslate nohighlight">\(q_{02}\)</span> of
<span class="math notranslate nohighlight">\(M_2\)</span>.</p>
<p>&lt;img src={useBaseUrl(‘img/fsa16.png’)}
alt=”NFA for r1 | r2” className=”centered-figure” /&gt;</p>
<p>It should be fairly clear that this new machine accepts exactly those strings of
the form <span class="math notranslate nohighlight">\(xy\)</span> where <span class="math notranslate nohighlight">\(x\in L(r_1)\)</span> and <span class="math notranslate nohighlight">\(y \in L(r_2)\)</span>: first of all, any string
of this form will be accepted because <span class="math notranslate nohighlight">\(x\in L(r_1)\)</span> implies there is a path that
consumes <span class="math notranslate nohighlight">\(x\)</span> from
<span class="math notranslate nohighlight">\(q_{01}\)</span> to a final state of <span class="math notranslate nohighlight">\(M_1\)</span>; a <span class="math notranslate nohighlight">\(\varepsilon\)</span>-transition moves to <span class="math notranslate nohighlight">\(q_{02}\)</span>;
then <span class="math notranslate nohighlight">\(y \in L(r_2)\)</span> implies there is a path that consumes <span class="math notranslate nohighlight">\(y\)</span> from <span class="math notranslate nohighlight">\(q_{02}\)</span> to a
final state of <span class="math notranslate nohighlight">\(M_2\)</span>; and the final states of <span class="math notranslate nohighlight">\(M_2\)</span> are the final states of the
new machine, so <span class="math notranslate nohighlight">\(xy\)</span> will be accepted. Conversely, suppose <span class="math notranslate nohighlight">\(z\)</span> is accepted by
the new machine. Since the only final states of the new machine are in the old
<span class="math notranslate nohighlight">\(M_2\)</span>, and the only way to get into <span class="math notranslate nohighlight">\(M_2\)</span> is to take a <span class="math notranslate nohighlight">\(\varepsilon\)</span>-transition from
a final state of <span class="math notranslate nohighlight">\(M_1\)</span>, this means that <span class="math notranslate nohighlight">\(z=xy\)</span> where <span class="math notranslate nohighlight">\(x\)</span> takes the machine from
its start state to a final state of <span class="math notranslate nohighlight">\(M_1\)</span>, a <span class="math notranslate nohighlight">\(\varepsilon\)</span>-transition occurs, and
then <span class="math notranslate nohighlight">\(y\)</span> takes the machine from <span class="math notranslate nohighlight">\(q_{02}\)</span> to a final state of <span class="math notranslate nohighlight">\(M_2\)</span>. Clearly,
<span class="math notranslate nohighlight">\(x\in L(r_1)\)</span> and <span class="math notranslate nohighlight">\(y \in L(r_2)\)</span>.</p>
<p>We leave the construction of an NFA that accepts <span class="math notranslate nohighlight">\(L(r^*)\)</span> from an NFA that
accepts <span class="math notranslate nohighlight">\(L(r)\)</span> as an exercise.</p>
</div></blockquote>
<p>The algorithm in this proof is commonly known as <strong>Thompson’s Construction</strong>, credited
to Ken Thompson who, along with Dennis Ritchie, also designed and implemented Unix and
the C programming language.[^Thompson is actually credited with creating B, while
Ritchie created its successor C.] Several of the utilities that Thompson developed for
Unix, such as <code class="docutils literal notranslate"><span class="pre">ed</span></code> and <code class="docutils literal notranslate"><span class="pre">grep</span></code>, make use of regular expressions for searching and replacing
text.</p>
</div>
<div class="section" id="nfa-to-regular-expression">
<h2>NFA to Regular Expression<a class="headerlink" href="#nfa-to-regular-expression" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p><strong>Theorem:</strong>
Every language that is accepted by a DFA or an NFA is generated by a regular
expression.</p>
</div></blockquote>
<p>Proving this result is actually fairly involved and not very illuminating.
Before presenting a proof, we will give an illustrative example of how one
might actually go about extracting a regular expression from an NFA or a DFA.
You can go on to read the proof if you are interested.</p>
<hr class="docutils" />
<p><strong>Example:</strong>
Consider
the DFA shown below:</p>
<p>&lt;img src={useBaseUrl(‘img/fsa17.png’)}
alt=”Example DFA” className=”centered-figure” /&gt;</p>
<p>Note that there is a loop from state <span class="math notranslate nohighlight">\(q_2\)</span> back to state <span class="math notranslate nohighlight">\(q_2\)</span>: any number of
<span class="math notranslate nohighlight">\(a\)</span>’s will keep the machine in state <span class="math notranslate nohighlight">\(q_2\)</span>, and so we label the transition with
the regular expression <span class="math notranslate nohighlight">\(a^*\)</span>. We do the same thing to the transition labeled
<span class="math notranslate nohighlight">\(b\)</span> from <span class="math notranslate nohighlight">\(q_0\)</span>. (Note that the result is no longer a DFA, but that doesn’t
concern us, we’re just interested in developing a regular expression.)</p>
<p>&lt;img src={useBaseUrl(‘img/fsa18.png’)}
alt=”Example DFA being converted to Regular Expression” className=”centered-figure” /&gt;</p>
<p>Next we note that there is in fact a loop from <span class="math notranslate nohighlight">\(q_1\)</span> to <span class="math notranslate nohighlight">\(q_1\)</span> via <span class="math notranslate nohighlight">\(q_0\)</span>. A
regular expression that matches the strings that would move around the loop is
<span class="math notranslate nohighlight">\(ab^*a\)</span>. So we add a transition labeled <span class="math notranslate nohighlight">\(ab^*a\)</span> from <span class="math notranslate nohighlight">\(q_1\)</span> to
<span class="math notranslate nohighlight">\(q_1\)</span>, and remove the now-irrelevant <span class="math notranslate nohighlight">\(a\)</span>-transition from <span class="math notranslate nohighlight">\(q_1\)</span> to <span class="math notranslate nohighlight">\(q_0\)</span>. (It is
irrelevant because it is not part of any other loop from <span class="math notranslate nohighlight">\(q_1\)</span> to
<span class="math notranslate nohighlight">\(q_1\)</span>.)</p>
<p>&lt;img src={useBaseUrl(‘img/fsa19.png’)}
alt=”Example DFA being converted to Regular Expression” className=”centered-figure” /&gt;</p>
<p>Next we note that there is also a loop from <span class="math notranslate nohighlight">\(q_1\)</span> to <span class="math notranslate nohighlight">\(q_1\)</span> via <span class="math notranslate nohighlight">\(q_2\)</span>. A
regular expression that matches the strings that would move around the loop is
<span class="math notranslate nohighlight">\(ba^*b\)</span>. Since the transitions in the loop are the only transitions to or from
<span class="math notranslate nohighlight">\(q_2\)</span>, we simply remove <span class="math notranslate nohighlight">\(q_2\)</span> and replace it with a transition from <span class="math notranslate nohighlight">\(q_1\)</span> to
<span class="math notranslate nohighlight">\(q_1\)</span>.</p>
<p>&lt;img src={useBaseUrl(‘img/fsa20.png’)}
alt=”Example DFA being converted to Regular Expression” className=”centered-figure” /&gt;</p>
<p>It is now clear from the diagram that strings of the form <span class="math notranslate nohighlight">\(b^*a\)</span> get you to
state <span class="math notranslate nohighlight">\(q_1\)</span>, and any number of repetitions of strings that match <span class="math notranslate nohighlight">\(ab^*a\)</span> or
<span class="math notranslate nohighlight">\(ba^*b\)</span> will keep you there. So the machine accepts <span class="math notranslate nohighlight">\(L(b^*a(ab^*a | ba^*b)^*)\)</span>.</p>
<hr class="docutils" />
<blockquote>
<div><p><strong>Proof:</strong>
We prove that the language accepted by a DFA is regular. The proof for NFAs
follows from the equivalence between DFAs and NFAs.</p>
</div></blockquote>
<p>Suppose that <span class="math notranslate nohighlight">\(M\)</span> is a DFA, where <span class="math notranslate nohighlight">\(M=(Q,\Sigma,q_0,\delta,F)\)</span>. Let <span class="math notranslate nohighlight">\(n\)</span> be the
number of states in <span class="math notranslate nohighlight">\(M\)</span>, and write <span class="math notranslate nohighlight">\(Q=\{q_0,q_1,\dots,q_{n-1}\}\)</span>. We want
to consider computations in which <span class="math notranslate nohighlight">\(M\)</span> starts in some state <span class="math notranslate nohighlight">\(q_i\)</span>, reads a string
<span class="math notranslate nohighlight">\(w\)</span>, and ends in state <span class="math notranslate nohighlight">\(q_k\)</span>. In such a computation, <span class="math notranslate nohighlight">\(M\)</span> might go through a
series of intermediates states between <span class="math notranslate nohighlight">\(q_i\)</span> and <span class="math notranslate nohighlight">\(q_k\)</span>:
<span class="math notranslate nohighlight">\($q_i\longrightarrow p_1\longrightarrow p_2 \cdots\longrightarrow p_r\longrightarrow q_k\)</span>$
We are interested in computations in which all of the intermediate states—<span class="math notranslate nohighlight">\(p_1,p_2,\dots,p_r\)</span>—are
in the set <span class="math notranslate nohighlight">\(\{q_0,q_1,\dots,q_{j-1}\}\)</span>, for some number <span class="math notranslate nohighlight">\(j\)</span>.
We define <span class="math notranslate nohighlight">\(R_{i,j,k}\)</span> to be the set of all strings <span class="math notranslate nohighlight">\(w\)</span> in <span class="math notranslate nohighlight">\(\Sigma^*\)</span> that are consumed
by such a computation. That is, <span class="math notranslate nohighlight">\(w\in R_{i,j,k}\)</span> if and only if when <span class="math notranslate nohighlight">\(M\)</span> starts in state
<span class="math notranslate nohighlight">\(q_i\)</span> and reads <span class="math notranslate nohighlight">\(w\)</span>, it ends in state <span class="math notranslate nohighlight">\(q_k\)</span>, and all the intermediate states between
<span class="math notranslate nohighlight">\(q_i\)</span> and <span class="math notranslate nohighlight">\(q_k\)</span> are in the set <span class="math notranslate nohighlight">\(\{q_0,q_1,\dots,q_{j-1}\}\)</span>.
<span class="math notranslate nohighlight">\(R_{i,j,k}\)</span> is a language over <span class="math notranslate nohighlight">\(\Sigma\)</span>. We show that <span class="math notranslate nohighlight">\(R_{i,j,k}\)</span> for
<span class="math notranslate nohighlight">\(0\le i &lt; n\)</span>, <span class="math notranslate nohighlight">\(0\le j \le n\)</span>, <span class="math notranslate nohighlight">\(0\le k &lt; n\)</span>.</p>
<p>Consider the language <span class="math notranslate nohighlight">\(R_{i,0,k}\)</span>. For <span class="math notranslate nohighlight">\(w\in R_{i,0,k}\)</span>, the set of allowable intermediate
states is empty. Since there can be no intermediate states,
it follows that there can be at most one step in the computation that
starts in state <span class="math notranslate nohighlight">\(q_i\)</span>, reads <span class="math notranslate nohighlight">\(w\)</span>, and ends in state <span class="math notranslate nohighlight">\(q_k\)</span>. So, <span class="math notranslate nohighlight">\(|w|\)</span> can be at most one.
This means that <span class="math notranslate nohighlight">\(R_{i,0,k}\)</span> is finite, and hence is regular. (In fact,
<span class="math notranslate nohighlight">\(R_{i,0,k}=\{a\in\Sigma\,|\, \delta(q_i,a)=q_k\}\)</span>, for <span class="math notranslate nohighlight">\(i\ne k\)</span>, and
<span class="math notranslate nohighlight">\(R_{i,0,i}=\{\varepsilon\}\cup\{a\in\Sigma\,|\, \delta(q_i,a)=q_i\}\)</span>. Note that in many
cases, <span class="math notranslate nohighlight">\(R_{i,0,k}\)</span> will be the empty set.)</p>
<p>We now proceed by induction on <span class="math notranslate nohighlight">\(j\)</span> to show that <span class="math notranslate nohighlight">\(R_{i,j,k}\)</span> is regular for all <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(k\)</span>.
We have proved the base case, <span class="math notranslate nohighlight">\(j=0\)</span>. Suppose that <span class="math notranslate nohighlight">\(0\le j&lt; n\)</span> we already know that <span class="math notranslate nohighlight">\(R_{i,j,k}\)</span>
is regular for all <span class="math notranslate nohighlight">\(i\)</span> and all <span class="math notranslate nohighlight">\(k\)</span>. We need to show that <span class="math notranslate nohighlight">\(R_{i,j+1,k}\)</span> is regular for all <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(k\)</span>.
In fact,
<span class="math notranslate nohighlight">\($R_{i,j+1,k}=R_{i,j,k}\cup \left( R_{i,j,j}R_{j,j,j}^*R_{j,j,k}\right)\)</span>$
which is regular because <span class="math notranslate nohighlight">\(R_{i,j,k}\)</span> is regular for all <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(k\)</span>, and because the union, concatenation,
and Kleene star of regular languages are regular.</p>
<p>To see that the above equation holds, consider a string <span class="math notranslate nohighlight">\(w\in\Sigma^*\)</span>.
Now, <span class="math notranslate nohighlight">\(w\in R_{i,j+1,k}\)</span> if and only if when <span class="math notranslate nohighlight">\(M\)</span> starts in state <span class="math notranslate nohighlight">\(q_i\)</span> and reads <span class="math notranslate nohighlight">\(w\)</span>,
it ends in state <span class="math notranslate nohighlight">\(q_k\)</span>, with all intermediate states in the computation in the set
<span class="math notranslate nohighlight">\(\{q_0,q_1,\dots,q_j\}\)</span>. Consider such a computation. There are two
cases: Either <span class="math notranslate nohighlight">\(q_j\)</span> occurs as an intermediate state in the computation, or it does not.
If it does \textbf{not} occur, then all the intermediate states are in the set
<span class="math notranslate nohighlight">\(\{q_0,q_1,\dots,q_{j-1}\}\)</span>, which means that in fact <span class="math notranslate nohighlight">\(w\in R_{i,j,k}\)</span>.
If <span class="math notranslate nohighlight">\(q_j\)</span> \textbf{does} occur as an intermediate state in the computation, then we can break the
computation into phases, by dividing it at each point where <span class="math notranslate nohighlight">\(q_j\)</span> occurs
as an intermediate state. This breaks <span class="math notranslate nohighlight">\(w\)</span> into a concatenation <span class="math notranslate nohighlight">\(w=xy_1y_2\cdots y_rz\)</span>.
The string <span class="math notranslate nohighlight">\(x\)</span> is consumed in the first phase of the computation, during which <span class="math notranslate nohighlight">\(M\)</span>
goes from state <span class="math notranslate nohighlight">\(q_i\)</span> to the first occurrence of <span class="math notranslate nohighlight">\(q_j\)</span>; since the intermediate states
in this computation are in the set <span class="math notranslate nohighlight">\(\{q_0,q_1,\dots,q_{j-1}\}\)</span>, <span class="math notranslate nohighlight">\(x\in R_{i,j,j}\)</span>.
The string <span class="math notranslate nohighlight">\(z\)</span> is consumed by the last phase of the computation, in which <span class="math notranslate nohighlight">\(M\)</span>
goes from the final occurrence of <span class="math notranslate nohighlight">\(q_j\)</span> to <span class="math notranslate nohighlight">\(q_k\)</span>, so that <span class="math notranslate nohighlight">\(z\in R_{j,j,k}\)</span>.
And each string <span class="math notranslate nohighlight">\(y_t\)</span> is consumed in a phase of the computation in which <span class="math notranslate nohighlight">\(M\)</span> goes
from one occurrence of <span class="math notranslate nohighlight">\(q_j\)</span> to the next occurrence of <span class="math notranslate nohighlight">\(q_j\)</span>, so that <span class="math notranslate nohighlight">\(y_r\in R_{j,j,j}\)</span>.
This means that <span class="math notranslate nohighlight">\(w=xy_1y_2\cdots y_rz\in R_{i,j,j}R_{j,j,j}^*R_{j,j,k}\)</span>.</p>
<p>We now know, in particular, that <span class="math notranslate nohighlight">\(R_{0,n,k}\)</span> is a regular language for all <span class="math notranslate nohighlight">\(k\)</span>.
But <span class="math notranslate nohighlight">\(R_{0,n,k}\)</span> consists of all strings <span class="math notranslate nohighlight">\(w\in\Sigma^*\)</span> such that when <span class="math notranslate nohighlight">\(M\)</span> starts
in state <span class="math notranslate nohighlight">\(q_0\)</span> and reads <span class="math notranslate nohighlight">\(w\)</span>, it ends in state <span class="math notranslate nohighlight">\(q_k\)</span> (with <strong>no</strong> restriction
on the intermediate states in the computation, since every state of <span class="math notranslate nohighlight">\(M\)</span> is in
the set <span class="math notranslate nohighlight">\(\{q_0,q_1,\dots,q_{n-1}\}\)</span>).
To finish the proof that <span class="math notranslate nohighlight">\(L(M)\)</span> is regular, it is only necessary to note that
<span class="math notranslate nohighlight">\(L(M)=\bigcup_{q_k\in F} R_{0,n,k}\)</span>
which is regular since it is a union of regular languages.
This equation is true since
a string <span class="math notranslate nohighlight">\(w\)</span> is in <span class="math notranslate nohighlight">\(L(M)\)</span> if and only if when <span class="math notranslate nohighlight">\(M\)</span> starts in state <span class="math notranslate nohighlight">\(q_0\)</span> and reads <span class="math notranslate nohighlight">\(w\)</span>,
in ends in some accepting state <span class="math notranslate nohighlight">\(q_k\in F\)</span>. This is the same as saying
<span class="math notranslate nohighlight">\(w\in R_{0,n,k}\)</span> for some <span class="math notranslate nohighlight">\(k\)</span> with <span class="math notranslate nohighlight">\(q_k\in F\)</span>.</p>
</div>
<div class="section" id="closure-properties-for-regular-languages">
<h2>Closure Properties for Regular Languages<a class="headerlink" href="#closure-properties-for-regular-languages" title="Permalink to this headline">¶</a></h2>
<p>We have already seen that if two languages <span class="math notranslate nohighlight">\(L_1\)</span> and <span class="math notranslate nohighlight">\(L_2\)</span> are
regular, then so are <span class="math notranslate nohighlight">\(L_1 \cup L_2\)</span>, <span class="math notranslate nohighlight">\(L_1L_2\)</span>, and <span class="math notranslate nohighlight">\(L_1^*\)</span>
(and of course <span class="math notranslate nohighlight">\(L_2^*\)</span>). We have not yet seen, however, how the
common
set operations intersection and complementation affect regularity.
Is the complement of a regular language regular? How about the
intersection of two regular languages?</p>
<p>Both of these questions can be answered by thinking of regular
languages in terms of their acceptance by DFAs. Let’s consider
first the question of complementation. Suppose we have an arbitrary
regular language <span class="math notranslate nohighlight">\(L\)</span>. We know there is a DFA <span class="math notranslate nohighlight">\(M\)</span> that accepts <span class="math notranslate nohighlight">\(L\)</span>.
Pause a moment and try to think of a modification that you could make
to <span class="math notranslate nohighlight">\(M\)</span> that would produce a new machine <span class="math notranslate nohighlight">\(M'\)</span> that accepts <span class="math notranslate nohighlight">\(\overline{L}\)</span>….
Okay, the obvious thing to try is to make <span class="math notranslate nohighlight">\(M'\)</span> be a copy of <span class="math notranslate nohighlight">\(M\)</span>
with all final states of <span class="math notranslate nohighlight">\(M\)</span> becoming non-final states of <span class="math notranslate nohighlight">\(M'\)</span> and
<em>vice versa</em>. This is in fact exactly right: <span class="math notranslate nohighlight">\(M'\)</span> does in fact accept
<span class="math notranslate nohighlight">\(\overline{L}\)</span>. To verify this, consider an arbitrary string <span class="math notranslate nohighlight">\(w\)</span>. The
transition functions for the two machines <span class="math notranslate nohighlight">\(M\)</span> and <span class="math notranslate nohighlight">\(M'\)</span> are identical, so <span class="math notranslate nohighlight">\(\delta^*
(q_0, w)\)</span> is the same state in both <span class="math notranslate nohighlight">\(M\)</span> and <span class="math notranslate nohighlight">\(M'\)</span>; if that state is
accepting in <span class="math notranslate nohighlight">\(M\)</span> then it is non-accepting in <span class="math notranslate nohighlight">\(M'\)</span>, so if <span class="math notranslate nohighlight">\(w\)</span> is
accepted by <span class="math notranslate nohighlight">\(M\)</span> it is not accepted by <span class="math notranslate nohighlight">\(M'\)</span>; if the state is
non-accepting in <span class="math notranslate nohighlight">\(M\)</span> then it is accepting in <span class="math notranslate nohighlight">\(M'\)</span>, so if <span class="math notranslate nohighlight">\(w\)</span> is
not accepted by <span class="math notranslate nohighlight">\(M\)</span> then it is accepted by <span class="math notranslate nohighlight">\(M'\)</span>. Thus <span class="math notranslate nohighlight">\(M'\)</span> accepts
exactly those strings that <span class="math notranslate nohighlight">\(M\)</span> does not, and hence accepts <span class="math notranslate nohighlight">\(\overline{L}\)</span>.</p>
<p>It is worth pausing for a moment and looking at the above argument
a bit longer. Would the argument have worked if we had looked at an
arbitrary language <span class="math notranslate nohighlight">\(L\)</span> and an arbitrary <em>NFA</em> <span class="math notranslate nohighlight">\(M\)</span> that accepted <span class="math notranslate nohighlight">\(L\)</span>?
That is, if we had built a new machine <span class="math notranslate nohighlight">\(M'\)</span> in which the final and
non-final states had been switched, would the new NFA <span class="math notranslate nohighlight">\(M'\)</span> accept
the complement of the language accepted by <span class="math notranslate nohighlight">\(M\)</span>? The answer is
“not necessarily”. Remember that acceptance in an NFA is determined
based on whether or not at least one of the states reached by a
string is accepting. So any string <span class="math notranslate nohighlight">\(w\)</span> with the property that
<span class="math notranslate nohighlight">\(\partial^*(q_0, w)\)</span> contains both accepting and non-accepting states of <span class="math notranslate nohighlight">\(M\)</span>
would be accepted both by <span class="math notranslate nohighlight">\(M\)</span> and by <span class="math notranslate nohighlight">\(M'\)</span>.</p>
<p>Now let’s turn to the question of intersection. Given two regular
languages <span class="math notranslate nohighlight">\(L_1\)</span> and <span class="math notranslate nohighlight">\(L_2\)</span>, is <span class="math notranslate nohighlight">\(L_1 \cap L_2\)</span> regular? Again, it is
useful to think in terms of DFAs: given machines <span class="math notranslate nohighlight">\(M_1\)</span> and <span class="math notranslate nohighlight">\(M_2\)</span>
that accept <span class="math notranslate nohighlight">\(L_1\)</span> and <span class="math notranslate nohighlight">\(L_2\)</span>, can you use them to build a new
machine that accepts <span class="math notranslate nohighlight">\(L_1 \cap L_2\)</span>? The answer is yes, and the
idea behind the construction bears some resemblance to that behind
the NFA-to-DFA construction.
We want a new machine where transitions reflect the transitions
of both <span class="math notranslate nohighlight">\(M_1\)</span> and <span class="math notranslate nohighlight">\(M_2\)</span> simultaneously, and we want to accept a
string <span class="math notranslate nohighlight">\(w\)</span> only if those sequences of transitions lead to
final states in both <span class="math notranslate nohighlight">\(M_1\)</span> and <span class="math notranslate nohighlight">\(M_2\)</span>. So we associate the
states of our new machine <span class="math notranslate nohighlight">\(M\)</span> with pairs of states from <span class="math notranslate nohighlight">\(M_1\)</span>
and <span class="math notranslate nohighlight">\(M_2\)</span>. For each state <span class="math notranslate nohighlight">\((q_1,q_2)\)</span> in the new machine and input symbol <span class="math notranslate nohighlight">\(a\)</span>,
define <span class="math notranslate nohighlight">\(\delta((q_1,q_2),a)\)</span> to be the state
<span class="math notranslate nohighlight">\((\delta_1(q_1,a), \delta_2(q_2,a))\)</span>.
The start state <span class="math notranslate nohighlight">\(q_0\)</span> of <span class="math notranslate nohighlight">\(M\)</span> is
<span class="math notranslate nohighlight">\((q_{01}, q_{02})\)</span>, where <span class="math notranslate nohighlight">\(q_{0i}\)</span> is the start state
of <span class="math notranslate nohighlight">\(M_i\)</span>. The final states of <span class="math notranslate nohighlight">\(M\)</span> are the the states of the form <span class="math notranslate nohighlight">\((q_{f1},
q_{f2})\)</span> where <span class="math notranslate nohighlight">\(q_{f1}\)</span> is an accepting state of <span class="math notranslate nohighlight">\(M_1\)</span> and <span class="math notranslate nohighlight">\(q_{f2}\)</span> is an
accepting state of <span class="math notranslate nohighlight">\(M_2\)</span>. You should convince yourself that <span class="math notranslate nohighlight">\(M\)</span> accepts a
string <span class="math notranslate nohighlight">\(x\)</span> iff <span class="math notranslate nohighlight">\(x\)</span> is accepted by both <span class="math notranslate nohighlight">\(M_1\)</span> and <span class="math notranslate nohighlight">\(M_2\)</span>.</p>
<p>The results of the previous section and the preceding discussion are summarized
by the following theorem:</p>
<blockquote>
<div><p><strong>Theorem:</strong>
The intersection of two
regular languages is a regular language.</p>
</div></blockquote>
<p>The union of two
regular languages is a regular language.</p>
<p>The concatenation of two
regular languages is a regular language.</p>
<p>The complement of a regular language is a regular language.</p>
<p>The Kleene closure of a regular language is a regular language.</p>
</div>
<div class="section" id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h2>
<ol class="simple">
<li><p>Give a DFA that accepts the intersection of the languages accepted by
the machines shown below. (Suggestion: use the construction discussed just
before the previous theorem.)</p></li>
</ol>
<p>&lt;img src={useBaseUrl(‘img/fsa5ex.png’)}
alt=”Example DFAs” className=”centered-figure” /&gt;</p>
<ol class="simple">
<li><p>Complete Thompson’s Construction by showing how to modify a
machine that accepts <span class="math notranslate nohighlight">\(L(r)\)</span> into a machine that accepts <span class="math notranslate nohighlight">\(L(r^*)\)</span>.</p></li>
<li><p>Using Thompson’s Construction, build an NFA
that accepts <span class="math notranslate nohighlight">\(L((ab | a)^*(bb))\)</span>.</p></li>
<li><p>Prove that the reverse of a regular language is regular.</p></li>
<li><p>Show that for any DFA or NFA, there is an NFA with exactly one final
state that accepts the same language.</p></li>
<li><p>Suppose we change the model of NFAs to allow NFAs to have multiple
start states. Show that for any “NFA” with multiple start states, there is an
NFA with exactly one start state that accepts the same language.</p></li>
<li><p>Show that the closure of regular languages under both union and complement
is enough to show that they are also closed under intersection.</p></li>
</ol>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./lang"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="nfa.html" title="previous page">Nondeterministic Finite-State Automata</a>
    <a class='right-next' id="next-link" href="cfg.html" title="next page">Context-Free Grammars</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Brian T. Howard, based in part on material by Carol Critchlow and David Eck<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    <script src="../_static/js/index.js"></script>
    
  </body>
</html>