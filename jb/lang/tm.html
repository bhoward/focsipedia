

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>General Grammars and Turing Machines &#8212; FoCSipedia</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" integrity="sha384-KA6wR/X5RY4zFAHpv/CnoG2UW1uogYfdnP67Uv7eULvTveboZJg0qUpmJZb5VqzN" crossorigin="anonymous">
    <link href="../_static/css/index.css" rel="stylesheet">
    <link rel="stylesheet" href="../_static/sphinx-book-theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/jupyter-sphinx.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/sphinx-book-theme.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/mystnb.js"></script>
    <script src="../_static/sphinx-book-theme.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Computability" href="computability.html" />
    <link rel="prev" title="Pushdown Automata" href="pda.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="docsearch:language" content="en">



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../index.html">
  
  <img src="../_static/SmartFoxLogo.jpeg" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">FoCSipedia</h1>
  
</a>
</div>

<form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>

<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <ul class="current nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../attribution.html">
   Attribution
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../topics.html">
   Topics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../overview.html">
   Overview of Topics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../logic/index.html">
   Logic
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sets/index.html">
   Sets
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fp/index.html">
   Functional Programming
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../ds/index.html">
   Data Structures
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="reference internal" href="index.html">
   Formal Languages
  </a>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="languages.html">
     Languages
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="regexp.html">
     Regular Expressions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="regexpapp.html">
     Applications of Regular Expressions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="fsa.html">
     Finite-State Automata
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="nfa.html">
     Nondeterministic Finite-State Automata
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="fsareg.html">
     Finite-State Automata and Regular Languages
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="cfg.html">
     Context-Free Grammars
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="bnf.html">
     Backus-Naur Form
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="parsing.html">
     Parsing and Parse Trees
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="pda.html">
     Pushdown Automata
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     General Grammars and Turing Machines
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="computability.html">
     Computability
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="halting.html">
     The Halting Problem
    </a>
   </li>
  </ul>
 </li>
</ul>

</nav>

 <!-- To handle the deprecated key -->

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        <div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    
    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/lang/tm.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
    
</div>
        <!-- Source interaction buttons -->


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> On this page
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#general-grammars">
   General Grammars
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#turing-machines">
   Turing Machines
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#exercises">
   Exercises
  </a>
 </li>
</ul>

        </nav>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="general-grammars-and-turing-machines">
<h1>General Grammars and Turing Machines<a class="headerlink" href="#general-grammars-and-turing-machines" title="Permalink to this headline">Â¶</a></h1>
<p>(Content adapted from Critchlow &amp; Eck)</p>
<div class="section" id="general-grammars">
<h2>General Grammars<a class="headerlink" href="#general-grammars" title="Permalink to this headline">Â¶</a></h2>
<p>At the beginning of this chapter the general idea of a grammar as a set of
rewriting or production rules was introduced. For most of the chapter, however,
we have restricted our attention to context-free grammars, in which production
rules must be of the form <span class="math notranslate nohighlight">\(A\longrightarrow x\)</span> where <span class="math notranslate nohighlight">\(A\)</span> is a non-terminal symbol.
In this section, we will consider general grammars, that is, grammars in which
there is no such restriction on the form of production rules. For a general
grammar, a production rule has the form <span class="math notranslate nohighlight">\(u\longrightarrow x\)</span>, where <span class="math notranslate nohighlight">\(u\)</span> is string
that can contain both terminal and non-terminal symbols. For convenience, we
will assume that <span class="math notranslate nohighlight">\(u\)</span> contains at least one non-terminal symbol, although
even this restriction could be lifted without changing the class of languages
that can be generated by grammars. Note that a context-free grammar is, in fact,
an example of a general grammar, since production rules in a general grammar
are allowed to be of the form <span class="math notranslate nohighlight">\(A\longrightarrow x\)</span>. They just donât have to be of
this form. I will use the unmodified term <strong>grammar</strong> to
refer to general grammars.[^There is another special type of grammar that
is intermediate between context-free grammars and general grammars. In a
so-called <strong>context-sensitive grammar</strong>, every production rule is of the form
<span class="math notranslate nohighlight">\(u\longrightarrow x\)</span> where <span class="math notranslate nohighlight">\(|x|\ge|u|\)</span>. We will not cover context-sensitive grammars in
this text.] The definition of grammar is identical to the
definition of context-free grammar, except for the form of the production rules:</p>
<blockquote>
<div><p>A <strong>grammar</strong> is a 4-tuple <span class="math notranslate nohighlight">\((V,\Sigma,P,S)\)</span>,
where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(V\)</span> is a finite set of symbols. The elements of <span class="math notranslate nohighlight">\(V\)</span>
are the non-terminal symbols of the grammar.</p></li>
<li><p><span class="math notranslate nohighlight">\(\Sigma\)</span> is a finite set of symbols such that <span class="math notranslate nohighlight">\(V\cap\Sigma=\emptyset\)</span>.
The elements of <span class="math notranslate nohighlight">\(\Sigma\)</span> are the terminal symbols of the grammar.</p></li>
<li><p><span class="math notranslate nohighlight">\(P\)</span> is a set of production rules. Each rule is of the
form <span class="math notranslate nohighlight">\(u\longrightarrow x\)</span> where <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(x\)</span> are strings in <span class="math notranslate nohighlight">\((V\cup \Sigma)^*\)</span>
and <span class="math notranslate nohighlight">\(u\)</span> contains at least one symbol from <span class="math notranslate nohighlight">\(V\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(S\in V\)</span>. <span class="math notranslate nohighlight">\(S\)</span> is the start symbol of the grammar.</p></li>
</ul>
</div></blockquote>
<p>Suppose <span class="math notranslate nohighlight">\(G\)</span> is a grammar. Just as in the context-free case,
the language generated by <span class="math notranslate nohighlight">\(G\)</span> is denoted by <span class="math notranslate nohighlight">\(L(G)\)</span> and is defined
as <span class="math notranslate nohighlight">\(L(G)=\{x\in\Sigma^*\;|\; S \Longrightarrow_G^* x\}\)</span>. That is, a string
<span class="math notranslate nohighlight">\(x\)</span> is in <span class="math notranslate nohighlight">\(L(G)\)</span> if and only if <span class="math notranslate nohighlight">\(x\)</span> is a string of terminal symbols
and there is a derivation that produces <span class="math notranslate nohighlight">\(x\)</span> from the start symbol,
<span class="math notranslate nohighlight">\(S\)</span>, in one or more steps.</p>
<p>The natural question is whether there are languages that can be generated
by general grammars but that cannot be generated by context-free languages.
A simple example of a language that is not context-free is <span class="math notranslate nohighlight">\(\{a^nb^nc^n\;|\; n\in \N\}\)</span>.
This language can be generated by a general grammar that first generates a string
of the form <span class="math notranslate nohighlight">\(XABCABC\cdots ABC\)</span>, where there are <span class="math notranslate nohighlight">\(n\)</span> groups of <span class="math notranslate nohighlight">\(ABC\)</span> for some <span class="math notranslate nohighlight">\(n\geq 0\)</span>.
Then we use general grammar rules that allow <span class="math notranslate nohighlight">\(A\)</span>âs, <span class="math notranslate nohighlight">\(B\)</span>âs, and <span class="math notranslate nohighlight">\(C\)</span>âs to switch places,
until the string looks like <span class="math notranslate nohighlight">\(XAA\cdots ABB\cdots BCC\cdots C\)</span>. Finally, another set of
rules essentially traverse the string from left to right, changing the non-terminals <span class="math notranslate nohighlight">\(A\)</span>,
<span class="math notranslate nohighlight">\(B\)</span>, and <span class="math notranslate nohighlight">\(C\)</span> into the corresponding terminals <span class="math notranslate nohighlight">\(a\)</span>, <span class="math notranslate nohighlight">\(b\)</span>, and <span class="math notranslate nohighlight">\(c\)</span>.
Here is a grammar that does this:
<span class="math notranslate nohighlight">\($
\begin{aligned}
 S&amp;\longrightarrow SABC\\
 S&amp;\longrightarrow X\\
 BA&amp;\longrightarrow AB\\
 CA&amp;\longrightarrow AC\\
 CB&amp;\longrightarrow BC\\
 XA&amp;\longrightarrow aX\\
 X&amp;\longrightarrow Y\\
 YB&amp;\longrightarrow bY\\
 Y&amp;\longrightarrow Z\\
 ZC&amp;\longrightarrow cZ\\
 Z&amp;\longrightarrow \varepsilon
\end{aligned}
$\)</span>
Here, the first two rules produce one of the strings <span class="math notranslate nohighlight">\(X\)</span>, <span class="math notranslate nohighlight">\(XABC\)</span>, <span class="math notranslate nohighlight">\(XABCABC\)</span>,
<span class="math notranslate nohighlight">\(XABCABCABC\)</span>, and so on. The next three rules allow <span class="math notranslate nohighlight">\(A\)</span>âs to move to the
left and <span class="math notranslate nohighlight">\(C\)</span>âs to move to the right, producing a string of the form <span class="math notranslate nohighlight">\(XA^nB^nC^n\)</span>,
for some <span class="math notranslate nohighlight">\(n\in\N\)</span>. The rule <span class="math notranslate nohighlight">\(XA\longrightarrow aX\)</span> allows the
<span class="math notranslate nohighlight">\(X\)</span> to move through the <span class="math notranslate nohighlight">\(A\)</span>âs from left to right, converting <span class="math notranslate nohighlight">\(A\)</span>âs
to <span class="math notranslate nohighlight">\(a\)</span>âs as it goes. After converting the <span class="math notranslate nohighlight">\(A\)</span>âs, the <span class="math notranslate nohighlight">\(X\)</span> can be
transformed into a <span class="math notranslate nohighlight">\(Y\)</span>. The <span class="math notranslate nohighlight">\(Y\)</span> will then move through the <span class="math notranslate nohighlight">\(B\)</span>âs, converting
them to <span class="math notranslate nohighlight">\(b\)</span>âs. Then, the <span class="math notranslate nohighlight">\(Y\)</span> is transformed into a <span class="math notranslate nohighlight">\(Z\)</span>, which is responsible
for converting <span class="math notranslate nohighlight">\(C\)</span>âs to <span class="math notranslate nohighlight">\(c\)</span>âs. Finally, an application of the
rule <span class="math notranslate nohighlight">\(Z\longrightarrow\varepsilon\)</span> removes the <span class="math notranslate nohighlight">\(Z\)</span>, leaving the string <span class="math notranslate nohighlight">\(a^nb^nc^n\)</span>.</p>
<p>Note that if the rule <span class="math notranslate nohighlight">\(X\longrightarrow Y\)</span> is applied before all the <span class="math notranslate nohighlight">\(A\)</span>âs have
been converted to <span class="math notranslate nohighlight">\(a\)</span>âs, then there is no way for the remaining <span class="math notranslate nohighlight">\(A\)</span>âs
to be converted to <span class="math notranslate nohighlight">\(a\)</span>âs or otherwise removed from the string. This means
that the derivation has entered a dead end, which can never produce a string
that consists of terminal symbols only. The only derivations that can produce
strings in the language generated by the grammar are derivations in which the
<span class="math notranslate nohighlight">\(X\)</span> moves past all the <span class="math notranslate nohighlight">\(A\)</span>âs, converting them all to <span class="math notranslate nohighlight">\(a\)</span>âs. At this
point in the derivation, the string is of the form <span class="math notranslate nohighlight">\(a^nXu\)</span> where <span class="math notranslate nohighlight">\(u\)</span> is a string
consisting entirely of <span class="math notranslate nohighlight">\(B\)</span>âs and <span class="math notranslate nohighlight">\(C\)</span>âs. Now the
rule <span class="math notranslate nohighlight">\(X\longrightarrow Y\)</span> can be applied, producing the string <span class="math notranslate nohighlight">\(a^nYu\)</span>. Then, if a string
of terminal symbols is ever to be produced, the <span class="math notranslate nohighlight">\(Y\)</span> must move past all the <span class="math notranslate nohighlight">\(B\)</span>âs,
producing the string <span class="math notranslate nohighlight">\(a^nb^nYC^n\)</span>. You can see that the use of three separate
non-terminals, <span class="math notranslate nohighlight">\(X\)</span>, <span class="math notranslate nohighlight">\(Y\)</span>, and <span class="math notranslate nohighlight">\(Z\)</span>, is essential for forcing the symbols in
<span class="math notranslate nohighlight">\(a^nb^nc^n\)</span> into the correct order.</p>
</div>
<div class="section" id="turing-machines">
<h2>Turing Machines<a class="headerlink" href="#turing-machines" title="Permalink to this headline">Â¶</a></h2>
<p>We saw hints in the previous section that
âcomputationâ is a more general concept than we might have thought.
General grammars, which at first encounter donât seem to have much
to do with algorithms or computing, turn out to be able to do things
that are similar to the tasks carried out by computer programs.
In this section, we will see that general grammars are precisely
equivalent to computer programs in terms of their computational
power, and that both are equivalent to a particularly simple model
of computation known as a <strong>Turing machine</strong>. We shall also see
that there are limits to what can be done by computing.</p>
<p>Historically, the theoretical study of computing began before computers
existed. One of the early models of computation was developed in the
1930s by the British mathematician, Alan Turing, who was interested in
studying the theoretical abilities and limitations of computation.
His model for computation is a very simple abstract computing machine
which has come to be known as a <strong>Turing machine</strong>. While Turing
machines are not applicable in the same way that regular expressions,
finite-state automata, and grammars are applicable, their use as a
fundamental model for computation means that every computer scientist
should be familiar with them, at least in a general way.</p>
<p>A Turing machine is really not much more complicated than a finite-state
automaton or a pushdown automaton.[^In fact, Turing machines can
be shown to be equivalent in their computational power
to pushdown automata with two independent stacks.]
Like a FSA, a Turing machine has a finite number of
possible states, and it changes from state to state as it computes.
However, a Turing machine also has an infinitely long <strong>tape</strong>
that it can use for input and output. The tape extends to infinity in
both directions. The tape is divided into <strong>cells</strong>, which
are in one-to-one correspondence with the
integers, <span class="math notranslate nohighlight">\(\Z\)</span>. Each cell can either be blank or it can hold a symbol from
a specified alphabet. The Turing machine can move back and forth
along this tape, reading and writing symbols and changing state.
It can read only one cell at a time, and possibly write a new
value in that cell. After doing this, it can change state and
it can move by one cell either to the left or to the right.
This is how the Turing machine computes. To use a Turing machine,
you would write some input on its tape, start the machine, and let
it compute until it halts. Whatever is written on the tape at that
time is the output of the computation.</p>
<p>Although the tape is infinite, only a finite number
of cells can be non-blank at any given time.
If you donât like the idea
of an infinite tape, you can think of a finite tape that can be
extended to an arbitrarily large size as the Turing machine computes:
If the Turing machine gets to either end of the tape, it will pause and
wait politely until you add a new section of tape. In other words,
itâs not important that the Turing machine have an infinite amount of
memory, only that it can use as much memory as it needs for a given
computation, up to any arbitrarily large size. In this way, a Turing
machine is like a computer that can ask you to buy it a new disk drive
whenever it needs more storage space to continue a computation.[^The
tape of a Turing machine can be used to store arbitrarily large amounts of
information in a straightforward way. Although we can imagine using
an arbitrary amount of memory with a computer, itâs not so easy. Computers
arenât set up to keep track of unlimited amounts of data. If you think
about how it might be done, you probably wonât come with anything better
than an infinite tape. (The problem is that computers use integer-valued
addresses to keep track of data locations. If a limit is put on
the number of bits in an address, then only a fixed, finite amount
of data can be addressed. If no limit is put on the number of bits
in an address, then we are right back to the problem of storing an
arbitrarily large piece of dataâjust to represent an address!)]</p>
<p>A given Turing machine has a fixed, finite set of states. One of
these states is designated as the <strong>start
state</strong>. This is the state in which the Turing machine begins a computation.
Another special state is the <strong>halt
state</strong>. The Turing machineâs computation ends when it enters its
halt state. It is possible that a computation might never end because
the machine never enters the halt state. This is analogous to an
infinite loop in a computer program.</p>
<p>At each step in its computation,
the Turing machine reads the contents of the tape cell where it is located.
Depending on its state and the symbol that it reads, the machine
writes a symbol (possibly the same symbol) to the cell, moves one cell
either to the left or to the right, and (possibly) changes its state.
The output symbol, direction of motion, and new state are determined
by the current state and the input symbol. Note that either the input
symbol, the output symbol, or both, can be blank.
A Turing machine has a fixed set of <strong>rules</strong>
that tell it how to compute. Each rule
specifies the output symbol, direction of motion, and new state for
some combination of current state and input symbol. The machine has
a rule for every possible combination of current state and input symbol,
except that there are no rules for what happens if the current state
is the halt state. Of course, once the machine enters the halt state,
its computation is complete and the machine simply stops.</p>
<p>I will use the character # to represent a blank in a way
that makes it visible. I will always use <span class="math notranslate nohighlight">\(h\)</span> to represent the halt
state. I will indicate the directions, left and right, with
<span class="math notranslate nohighlight">\(L\)</span> and <span class="math notranslate nohighlight">\(R\)</span>, so that <span class="math notranslate nohighlight">\(\{L,R\}\)</span> is the set of possible directions of
motion. With these conventions, we can give the formal definition of
a Turing machine as follows:</p>
<blockquote>
<div><p>A <strong>Turing machine</strong> is a 4-tuple <span class="math notranslate nohighlight">\((Q,\Lambda,q_0,\delta)\)</span>,
where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(Q\)</span> is a finite set of states, including the halt state, <span class="math notranslate nohighlight">\(h\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(\Lambda\)</span> is an alphabet which includes the blank symbol, #.</p></li>
<li><p><span class="math notranslate nohighlight">\(q_0\in Q\)</span> is the start state.</p></li>
<li><p><span class="math notranslate nohighlight">\(\delta\colon (Q\smallsetminus\{h\})\times\Lambda \to \Lambda\times 
\{L,R\}\times Q\)</span> is the transition function. The fact that
<span class="math notranslate nohighlight">\(\delta(q,\sigma)=(\tau,d,r)\)</span> means that when the Turing machine is
in state <span class="math notranslate nohighlight">\(q\)</span> and reads the symbol <span class="math notranslate nohighlight">\(\sigma\)</span>, it writes the symbol
<span class="math notranslate nohighlight">\(\tau\)</span>, moves one cell in the direction <span class="math notranslate nohighlight">\(d\)</span>, and enters state <span class="math notranslate nohighlight">\(r\)</span>.</p></li>
</ul>
</div></blockquote>
<p>Even though this is the formal definition, itâs easier to work with
a transition diagram representation of Turing machines. The transition
diagram for a Turing machine is similar to the transition diagram for
a DFA. However, there are no âacceptingâ states (only a halt state).
Furthermore, there must be a way to specify the output symbol and
the direction of motion for each step of the computation.
We do this by labeling arrows with notations of the
form <span class="math notranslate nohighlight">\((\sigma,\tau,L)\)</span> and <span class="math notranslate nohighlight">\((\sigma,\tau,R)\)</span>, where
<span class="math notranslate nohighlight">\(\sigma\)</span> and <span class="math notranslate nohighlight">\(\tau\)</span> are symbols in the Turing machineâs alphabet.
For example,</p>
<p>&lt;img src={useBaseUrl(âimg/turing1.pngâ)}
alt=âTuring Machine transitionâ className=âcentered-figureâ /&gt;</p>
<p>indicates that when the machine is in state <span class="math notranslate nohighlight">\(q_0\)</span> and
reads an <span class="math notranslate nohighlight">\(a\)</span>, it writes a <span class="math notranslate nohighlight">\(b\)</span>, moves left, and enters state <span class="math notranslate nohighlight">\(h\)</span>.</p>
<p>Here, for example, is a transition diagram for a simple Turing machine
that moves to the right, changing <span class="math notranslate nohighlight">\(a\)</span>âs to <span class="math notranslate nohighlight">\(b\)</span>âs and <em>vice
versa</em>, until it finds a <span class="math notranslate nohighlight">\(c\)</span>. It leaves blanks (#âs) unchanged.
When and if the machine encounters a <span class="math notranslate nohighlight">\(c\)</span>, it moves to the left
and halts:</p>
<p>&lt;img src={useBaseUrl(âimg/turing2.pngâ)}
alt=âTuring Machine exampleâ className=âcentered-figureâ /&gt;</p>
<p>To simplify the diagrams, I will leave out any transitions that are
not relevant to the computation that I want the machine to perform.
You can assume that the action for any omitted transition is
to write the same symbol that was read, move right, and halt.</p>
<p>For another example, shown below is a transition diagram for a Turing machine
that makes a copy of a string of <span class="math notranslate nohighlight">\(a\)</span>âs and <span class="math notranslate nohighlight">\(b\)</span>âs. To use this machine,
you would write a string of <span class="math notranslate nohighlight">\(a\)</span>âs and <span class="math notranslate nohighlight">\(b\)</span>âs on its tape, place
the machine on the first character of the string, and start the
machine in its start state, <span class="math notranslate nohighlight">\(q_0\)</span>. When the machine halts, there will be
two copies of the string on the tape, separated by a blank.
The machine will be positioned on the first character of the leftmost
copy of the string. Note that this machine uses <span class="math notranslate nohighlight">\(c\)</span>âs and
<span class="math notranslate nohighlight">\(d\)</span>âs in addition to <span class="math notranslate nohighlight">\(a\)</span>âs and <span class="math notranslate nohighlight">\(b\)</span>âs. While it is copying the
input string, it temporarily changes the <span class="math notranslate nohighlight">\(a\)</span>âs and <span class="math notranslate nohighlight">\(b\)</span>âs that it
has copied to <span class="math notranslate nohighlight">\(c\)</span>âs and <span class="math notranslate nohighlight">\(d\)</span>âs, respectively. In this way it can
keep track of which characters it has already copied. After the
string has been copied, the machine changes the <span class="math notranslate nohighlight">\(c\)</span>âs and <span class="math notranslate nohighlight">\(d\)</span>âs
back to <span class="math notranslate nohighlight">\(a\)</span>âs and <span class="math notranslate nohighlight">\(b\)</span>âs before halting.</p>
<p>&lt;img src={useBaseUrl(âimg/turing3.pngâ)}
alt=âTuring Machine exampleâ className=âcentered-figureâ /&gt;</p>
<p>In this machine, state <span class="math notranslate nohighlight">\(q_0\)</span> checks whether the next character
is an <span class="math notranslate nohighlight">\(a\)</span>, a <span class="math notranslate nohighlight">\(b\)</span>, or a # (indicating the end of the string).
States <span class="math notranslate nohighlight">\(q_1\)</span> and <span class="math notranslate nohighlight">\(q_2\)</span> add an <span class="math notranslate nohighlight">\(a\)</span> to the end of the new string,
and states <span class="math notranslate nohighlight">\(q_3\)</span> and <span class="math notranslate nohighlight">\(q_4\)</span> do the same thing with a <span class="math notranslate nohighlight">\(b\)</span>.
States <span class="math notranslate nohighlight">\(q_5\)</span> and <span class="math notranslate nohighlight">\(q_6\)</span> return the machine to the next character
in the input string. When the end of the input string is reached,
state <span class="math notranslate nohighlight">\(q_7\)</span> will move the machine back to the start of the input
string, changing <span class="math notranslate nohighlight">\(c\)</span>âs and <span class="math notranslate nohighlight">\(d\)</span>âs back to <span class="math notranslate nohighlight">\(a\)</span>âs and <span class="math notranslate nohighlight">\(b\)</span>âs as it goes.
Finally, when the machine hits the # that precedes the input string,
it moves to the right and halts. This leave it back at the first
character of the input string. It would be a good idea to work through
the execution of this machine for a few sample input strings.
You should also check that it works even for an input string of
length zero.</p>
<hr class="docutils" />
<p>Our primary interest in Turing machines is as language processors.
Suppose that <span class="math notranslate nohighlight">\(w\)</span> is a string over an alphabet <span class="math notranslate nohighlight">\(\Sigma\)</span>. We will assume
that <span class="math notranslate nohighlight">\(\Sigma\)</span> does not contain the blank symbol. We can use <span class="math notranslate nohighlight">\(w\)</span> as
input to a Turing machine <span class="math notranslate nohighlight">\(M=(Q,\Lambda,q_0,\delta)\)</span> provided that
<span class="math notranslate nohighlight">\(\Sigma\subseteq\Lambda\)</span>. To use <span class="math notranslate nohighlight">\(w\)</span> as input for <span class="math notranslate nohighlight">\(M\)</span>, we will write
<span class="math notranslate nohighlight">\(w\)</span> on <span class="math notranslate nohighlight">\(M\)</span>âs tape and assume that the remainder of the tape is blank.
We place the machine on the cell containing the first character
of the string, except that if <span class="math notranslate nohighlight">\(w=\varepsilon\)</span> then we simply place the
machine on a completely blank tape. Then we start the machine in its
initial state, <span class="math notranslate nohighlight">\(q_0\)</span>, and see what computation it performs.
We refer to this setup as ârunning <span class="math notranslate nohighlight">\(M\)</span> with input <span class="math notranslate nohighlight">\(w\)</span>.â</p>
<p>When <span class="math notranslate nohighlight">\(M\)</span> is run with input <span class="math notranslate nohighlight">\(w\)</span>, it is possible that it will just keep
running forever without halting. In that case, it doesnât make
sense to ask about the output of the computation. Suppose however
that <span class="math notranslate nohighlight">\(M\)</span> does halt on input <span class="math notranslate nohighlight">\(w\)</span>. Suppose, furthermore, that when
<span class="math notranslate nohighlight">\(M\)</span> halts, its tape is blank except for a string <span class="math notranslate nohighlight">\(x\)</span> of non-blank
symbols, and that the machine is located on the first character
of <span class="math notranslate nohighlight">\(x\)</span>. In this case, we will say that â<span class="math notranslate nohighlight">\(M\)</span> halts with output <span class="math notranslate nohighlight">\(x\)</span>.â
In addition, if <span class="math notranslate nohighlight">\(M\)</span> halts with an entirely blank tape, we say that
â<span class="math notranslate nohighlight">\(M\)</span> halts with output <span class="math notranslate nohighlight">\(\varepsilon\)</span>.â
Note that when we run <span class="math notranslate nohighlight">\(M\)</span> with input <span class="math notranslate nohighlight">\(w\)</span>, one of three things can happen:
(1) <span class="math notranslate nohighlight">\(M\)</span> might halt with some string as output; (1) <span class="math notranslate nohighlight">\(M\)</span> might fail to halt;
or (3) <span class="math notranslate nohighlight">\(M\)</span> might halt in some configuration that doesnât
count as outputting any string.</p>
<p>The fact that a Turing machine can produce an output value allows us
for the first time to deal with computation of <em>functions</em>.
A function <span class="math notranslate nohighlight">\(f\colon A\to B\)</span> takes an input value in the set <span class="math notranslate nohighlight">\(A\)</span>
and produces an output value in the set <span class="math notranslate nohighlight">\(B\)</span>. If the sets are sets
of strings, we can now ask whether the values of the function can
be computed by a Turing machine. That is, is there a Turing machine <span class="math notranslate nohighlight">\(M\)</span>
such that, given any string <span class="math notranslate nohighlight">\(w\)</span> in the domain of <span class="math notranslate nohighlight">\(f\)</span> as input,
<span class="math notranslate nohighlight">\(M\)</span> will compute as its output the string <span class="math notranslate nohighlight">\(f(w)\)</span>. If this is
that case, then we say that <span class="math notranslate nohighlight">\(f\)</span> is a Turing-computable function.</p>
<blockquote>
<div><p>Suppose
that <span class="math notranslate nohighlight">\(\Sigma\)</span> and <span class="math notranslate nohighlight">\(\Gamma\)</span> are alphabets that do not contain # and that
<span class="math notranslate nohighlight">\(f\)</span> is a function from <span class="math notranslate nohighlight">\(\Sigma^*\)</span> to <span class="math notranslate nohighlight">\(\Gamma^*\)</span>. We say that
<span class="math notranslate nohighlight">\(f\)</span> is <strong>Turing-computable</strong> if there is a Turing machine
<span class="math notranslate nohighlight">\(M=(Q,\Lambda,q_0,\delta)\)</span> such that <span class="math notranslate nohighlight">\(\Sigma\subseteq\Lambda\)</span> and <span class="math notranslate nohighlight">\(\Gamma\subseteq\Lambda\)</span>
and for each string <span class="math notranslate nohighlight">\(w\in\Sigma^*\)</span>, when <span class="math notranslate nohighlight">\(M\)</span> is run with input <span class="math notranslate nohighlight">\(w\)</span>,
it halts with output <span class="math notranslate nohighlight">\(f(w)\)</span>. In this case, we say that <span class="math notranslate nohighlight">\(M\)</span>
<strong>computes</strong> the function <span class="math notranslate nohighlight">\(f\)</span>.</p>
</div></blockquote>
<p>For example, let <span class="math notranslate nohighlight">\(\Sigma=\{a\}\)</span> and define <span class="math notranslate nohighlight">\(f\colon\Sigma^*\to\Sigma^*\)</span>
by <span class="math notranslate nohighlight">\(f(a^n)=a^{2n}\)</span>, for <span class="math notranslate nohighlight">\(n\in\N\)</span>. Then <span class="math notranslate nohighlight">\(f\)</span> is Turing-computable
since it is computed by this Turing machine:</p>
<p>&lt;img src={useBaseUrl(âimg/turing4.pngâ)}
alt=âTuring Machine exampleâ className=âcentered-figureâ /&gt;</p>
<p>We can also use Turing machines to define âcomputable languages.â
There are actually two different notions of Turing-computability
for languages. One is based on the idea of Turing-computability
for functions. Suppose that <span class="math notranslate nohighlight">\(\Sigma\)</span> is an alphabet and that
<span class="math notranslate nohighlight">\(L\subseteq\Sigma^*\)</span>. The <strong>characteristic function</strong> of <span class="math notranslate nohighlight">\(L\)</span>
is the function <span class="math notranslate nohighlight">\(\chi_L\colon\Sigma^*\to\{0,1\}\)</span> defined
by the fact that <span class="math notranslate nohighlight">\(\chi_L(w)=1\)</span> if <span class="math notranslate nohighlight">\(w\in L\)</span> and <span class="math notranslate nohighlight">\(\chi_L(w)=0\)</span>
if <span class="math notranslate nohighlight">\(w\not\in L\)</span>. Note that given the function <span class="math notranslate nohighlight">\(\chi_L\)</span>,
<span class="math notranslate nohighlight">\(L\)</span> can be obtained as the set <span class="math notranslate nohighlight">\(L=\{w\in\Sigma^*\;|\; \chi_L(w)=1\}\)</span>.
Given a language <span class="math notranslate nohighlight">\(L\)</span>, we can ask whether the corresponding function
<span class="math notranslate nohighlight">\(\chi_L\)</span> is Turing-computable. If so, then we can use a Turing
machine to decide whether or not a given string <span class="math notranslate nohighlight">\(w\)</span> is in <span class="math notranslate nohighlight">\(L\)</span>.
Just run the machine with input <span class="math notranslate nohighlight">\(w\)</span>. It will halt with output <span class="math notranslate nohighlight">\(\chi_L(w)\)</span>.
(That is, it will halt and when it does so, the tape will be blank except for
a 0 or a 1, and the machine will be positioned on the 0 or 1.)
If the machine halts with output 1, then <span class="math notranslate nohighlight">\(w\in L\)</span>. If the machine halts with
output 0, then <span class="math notranslate nohighlight">\(w\not\in L\)</span>.</p>
<blockquote>
<div><p>Let <span class="math notranslate nohighlight">\(\Sigma\)</span> be an alphabet that does not contain # and let <span class="math notranslate nohighlight">\(L\)</span> be a language over <span class="math notranslate nohighlight">\(\Sigma\)</span>.
We say that <span class="math notranslate nohighlight">\(L\)</span> is <strong>Turing-decidable</strong> if there is a Turing machine
<span class="math notranslate nohighlight">\(M=(Q,\Lambda,q_0,\delta)\)</span> such that <span class="math notranslate nohighlight">\(\Sigma\subseteq\Lambda\)</span>, <span class="math notranslate nohighlight">\(\{0,1\}\subseteq\Lambda\)</span>,
and for each <span class="math notranslate nohighlight">\(w\in\Sigma^*\)</span>, when <span class="math notranslate nohighlight">\(M\)</span> is run with input <span class="math notranslate nohighlight">\(w\)</span>, it halts
with output <span class="math notranslate nohighlight">\(\chi_L(w)\)</span>. (That is, it halts with output 0 or 1, and
the output is 0 if <span class="math notranslate nohighlight">\(w\not\in L\)</span> and is 1 if <span class="math notranslate nohighlight">\(w\in L\)</span>.) In this case,
we say that <span class="math notranslate nohighlight">\(M\)</span> <strong>decides</strong> the language <span class="math notranslate nohighlight">\(L\)</span>.</p>
</div></blockquote>
<p>The second notion of computability for languages is based on the
interesting fact that it is possible for a Turing machine to run
forever, without ever halting.
Whenever we run a Turing machine <span class="math notranslate nohighlight">\(M\)</span> with input <span class="math notranslate nohighlight">\(w\)</span>,
we can ask the question, will <span class="math notranslate nohighlight">\(M\)</span> ever halt or will it run forever? If <span class="math notranslate nohighlight">\(M\)</span>
halts on input <span class="math notranslate nohighlight">\(w\)</span>, we will say that <span class="math notranslate nohighlight">\(M\)</span> âacceptsâ <span class="math notranslate nohighlight">\(w\)</span>. We can then
look at all the strings over a given alphabet that are accepted by
a given Turing machine. This leads to the notion of Turing-acceptable
languages.</p>
<blockquote>
<div><p>Let <span class="math notranslate nohighlight">\(\Sigma\)</span> be an alphabet that does not contain #, and let <span class="math notranslate nohighlight">\(L\)</span> be a language over <span class="math notranslate nohighlight">\(\Sigma\)</span>.
We say that <span class="math notranslate nohighlight">\(L\)</span> is <strong>Turing-acceptable</strong> if there is a Turing machine
<span class="math notranslate nohighlight">\(M=(Q,\Lambda,q_0,\delta)\)</span> such that <span class="math notranslate nohighlight">\(\Sigma\subseteq\Lambda\)</span>, and
for each <span class="math notranslate nohighlight">\(w\in\Sigma^*\)</span>, <span class="math notranslate nohighlight">\(M\)</span> halts on input <span class="math notranslate nohighlight">\(w\)</span> if and only if <span class="math notranslate nohighlight">\(w\in L\)</span>.
In this case, we say that <span class="math notranslate nohighlight">\(M\)</span> <strong>accepts</strong> the language <span class="math notranslate nohighlight">\(L\)</span>.</p>
</div></blockquote>
<p>It should be clear that any Turing-decidable language is Turing-acceptable.
In fact, if <span class="math notranslate nohighlight">\(L\)</span> is a language over an alphabet <span class="math notranslate nohighlight">\(\Sigma\)</span>,
and if <span class="math notranslate nohighlight">\(M\)</span> is a Turing machine that
decides <span class="math notranslate nohighlight">\(L\)</span>, then it is easy to modify <span class="math notranslate nohighlight">\(M\)</span> to produce a Turing machine
that accepts <span class="math notranslate nohighlight">\(L\)</span>. At the point where <span class="math notranslate nohighlight">\(M\)</span> enters the halt state with
output 0, the new machine should enter a new state in which it simply
moves to the right forever, without ever halting. Given an input
<span class="math notranslate nohighlight">\(w\in\Sigma^*\)</span>, the modified machine will halt if and only if <span class="math notranslate nohighlight">\(M\)</span>
halts with output 1, that is, if and only if <span class="math notranslate nohighlight">\(w\in L\)</span>.</p>
</div>
<div class="section" id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">Â¶</a></h2>
<ol class="simple">
<li><p>Let <span class="math notranslate nohighlight">\(\Sigma=\{a\}\)</span>. Draw a transition diagram for a Turing
machine that computes the function <span class="math notranslate nohighlight">\(f\colon\Sigma^*\to\Sigma^*\)</span> where
<span class="math notranslate nohighlight">\(f(a^n)=a^{3n}\)</span>, for <span class="math notranslate nohighlight">\(n\in\N\)</span>. Draw a transition diagram for a Turing
machine that computes the function <span class="math notranslate nohighlight">\(f\colon\Sigma^*\to\Sigma^*\)</span> where
<span class="math notranslate nohighlight">\(f(a^n)=a^{3n+1}\)</span>, for <span class="math notranslate nohighlight">\(n\in\N\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\Sigma=\{a,b\}\)</span>.
Draw a transition diagram for a Turing machine that
computes the function <span class="math notranslate nohighlight">\(f\colon\Sigma^*\to\Sigma^*\)</span> where
<span class="math notranslate nohighlight">\(f(w)=w^R\)</span>.</p></li>
<li><p>Suppose that <span class="math notranslate nohighlight">\(\Sigma\)</span>, <span class="math notranslate nohighlight">\(\Gamma\)</span>, and <span class="math notranslate nohighlight">\(\Xi\)</span> are alphabets and that
<span class="math notranslate nohighlight">\(f\colon\Sigma^*\to\Gamma^*\)</span> and <span class="math notranslate nohighlight">\(g\colon\Gamma^*\to\Xi^*\)</span> are
Turing-computable functions. Show that <span class="math notranslate nohighlight">\(g\circ f\)</span> is Turing-computable.</p></li>
<li><p>We have defined computability for functions <span class="math notranslate nohighlight">\(f\colon\Sigma^*\to\Gamma^*\)</span>,
where <span class="math notranslate nohighlight">\(\Sigma\)</span> and <span class="math notranslate nohighlight">\(\Gamma\)</span> are alphabets. How could Turing machines
be used to define computable functions from <span class="math notranslate nohighlight">\(\N\)</span> to <span class="math notranslate nohighlight">\(\N\,\)</span>?
(Hint: Consider the alphabet <span class="math notranslate nohighlight">\(\Sigma=\{a\}\)</span>.)</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\Sigma\)</span> be an alphabet and let <span class="math notranslate nohighlight">\(L\)</span> be a language over <span class="math notranslate nohighlight">\(\Sigma\)</span>.
Show that <span class="math notranslate nohighlight">\(L\)</span> is Turing-decidable if and only if its complement,
<span class="math notranslate nohighlight">\(\overline{L}\)</span>, is Turing-decidable.</p></li>
<li><p>Draw a transition diagram for a Turing machine which
decides the language <span class="math notranslate nohighlight">\(\{a^nb^n\;|\; n\in\N\}\)</span>. (Hint: Change the
<span class="math notranslate nohighlight">\(a\)</span>âs and <span class="math notranslate nohighlight">\(b\)</span>âs to $âs in pairs.) Explain in general terms how to
make a Turing machine that decides the language <span class="math notranslate nohighlight">\(\{a^nb^nc^n\;|\; n\in\N\}\)</span>.</p></li>
<li><p>Draw a transition diagram for a Turing machine which
decides the language <span class="math notranslate nohighlight">\(\{a^nb^m\;|\; n&gt;0\)</span> and <span class="math notranslate nohighlight">\(m\)</span> is a multiple of <span class="math notranslate nohighlight">\(n\}\)</span>.
(Hint: Erase <span class="math notranslate nohighlight">\(n\)</span> <span class="math notranslate nohighlight">\(b\)</span>âs at a time.)</p></li>
<li><p>Based on your answer to the previous problem and the copying
machine presented in this section, describe in
general terms how you would build a Turing machine to decide the
language <span class="math notranslate nohighlight">\(\{a^p\;|\; p\)</span> is a prime number<span class="math notranslate nohighlight">\(\}\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(g\colon \{a\}^*\to\{0,1\}^*\)</span> be the function such that
for each <span class="math notranslate nohighlight">\(n\in\N\)</span>, <span class="math notranslate nohighlight">\(g(a^n)\)</span> is the representation of <span class="math notranslate nohighlight">\(n\)</span> as a binary
number. Draw a transition diagram for a Turing machine that computes <span class="math notranslate nohighlight">\(g\)</span>.</p></li>
</ol>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./lang"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="pda.html" title="previous page">Pushdown Automata</a>
    <a class='right-next' id="next-link" href="computability.html" title="next page">Computability</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Brian T. Howard, based in part on material by Carol Critchlow and David Eck<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    <script src="../_static/js/index.js"></script>
    
  </body>
</html>