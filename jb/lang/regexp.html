

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Regular Expressions &#8212; FoCSipedia</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" integrity="sha384-KA6wR/X5RY4zFAHpv/CnoG2UW1uogYfdnP67Uv7eULvTveboZJg0qUpmJZb5VqzN" crossorigin="anonymous">
    <link href="../_static/css/index.css" rel="stylesheet">
    <link rel="stylesheet" href="../_static/sphinx-book-theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/jupyter-sphinx.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/sphinx-book-theme.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/mystnb.js"></script>
    <script src="../_static/sphinx-book-theme.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Applications of Regular Expressions" href="regexpapp.html" />
    <link rel="prev" title="Languages" href="languages.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="docsearch:language" content="en">



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../index.html">
  
  <img src="../_static/SmartFoxLogo.jpeg" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">FoCSipedia</h1>
  
</a>
</div>

<form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>

<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <ul class="current nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../attribution.html">
   Attribution
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../topics.html">
   Topics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../overview.html">
   Overview of Topics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../logic/index.html">
   Logic
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sets/index.html">
   Sets
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fp/index.html">
   Functional Programming
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../ds/index.html">
   Data Structures
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="reference internal" href="index.html">
   Formal Languages
  </a>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="languages.html">
     Languages
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Regular Expressions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="regexpapp.html">
     Applications of Regular Expressions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="fsa.html">
     Finite-State Automata
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="nfa.html">
     Nondeterministic Finite-State Automata
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="fsareg.html">
     Finite-State Automata and Regular Languages
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="cfg.html">
     Context-Free Grammars
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="bnf.html">
     Backus-Naur Form
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="parsing.html">
     Parsing and Parse Trees
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="pda.html">
     Pushdown Automata
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="tm.html">
     General Grammars and Turing Machines
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="computability.html">
     Computability
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="halting.html">
     The Halting Problem
    </a>
   </li>
  </ul>
 </li>
</ul>

</nav>

 <!-- To handle the deprecated key -->

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        <div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    
    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/lang/regexp.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
    
</div>
        <!-- Source interaction buttons -->


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> On this page
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#exercises">
   Exercises
  </a>
 </li>
</ul>

        </nav>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="regular-expressions">
<h1>Regular Expressions<a class="headerlink" href="#regular-expressions" title="Permalink to this headline">¶</a></h1>
<p>(Content adapted from Critchlow &amp; Eck)</p>
<p>Though we have used the term <em>string</em> throughout to refer to a sequence of
symbols from an alphabet, an alternative term that is frequently used is <strong>word</strong>.
The analogy seems fairly obvious: strings are made up of “letters”
from an alphabet, just as words are in human languages like English.
In English, however, there are no strict rules specifying which sequences
of letters can be used to form legal English words—even unlikely
combinations like <em>ghth</em> and <em>ckstr</em> have their place.
While some formal languages may simply
be random collections of arbitrary strings, more interesting languages
are those where the strings in the language all share some
common structure: <span class="math notranslate nohighlight">\(L_1 = \{ x\in \{a,b\}^* \ | n_a(x) =
n_b(x)\}\)</span>; <span class="math notranslate nohighlight">\(L_2 = \{\textrm{legal Java identifiers}\}\)</span>; <span class="math notranslate nohighlight">\(L_3 = \{\textrm{legal C++
programs}\}\)</span>. In all of these languages, there are structural
rules which determine which sequences of symbols are in the language and which
aren’t.
So
despite the terminology of “alphabet” and “word” in formal
language theory, the concepts don’t necessarily match “alphabet”
and “word” for human languages. A better parallel is to think of
the <em>alphabet</em> in a formal language as corresponding to the <em>words</em> in a
human language; the <em>words</em> in a formal language correspond to
the <em>sentences</em> in a human language, as there are rules (<em>grammar
rules</em>) which determine how they can legally be constructed.</p>
<p>One way of describing the grammatical structure of the strings in a language is
to use a mathematical formalism called a <strong>regular expression</strong>. A regular
expression is a pattern that “matches” strings that have a particular form. For
example, consider the language (over alphabet <span class="math notranslate nohighlight">\(\Sigma = \{a,b\}\)</span>) <span class="math notranslate nohighlight">\(L= \{x \ | \ x
\textrm{\ starts and ends with\ } a\}\)</span>. What is the symbol-by-symbol
structure of
strings in this language? Well, they start with an <span class="math notranslate nohighlight">\(a\)</span>, followed by zero or more
<span class="math notranslate nohighlight">\(a\)</span>’s or <span class="math notranslate nohighlight">\(b\)</span>’s or both, followed by an <span class="math notranslate nohighlight">\(a\)</span>. The regular expression
<span class="math notranslate nohighlight">\(a \cdot (a \,|\, b)^* \cdot a\)</span> is a pattern that captures this structure and matches any string in
<span class="math notranslate nohighlight">\(L\)</span> (<span class="math notranslate nohighlight">\(\cdot\)</span> and <span class="math notranslate nohighlight">\(^*\)</span> have their usual meanings, and <span class="math notranslate nohighlight">\(\,|\,\)</span> designates <em>or</em>.[^Various
symbols have been used to represent the “or” operation in regular expressions. Both
<span class="math notranslate nohighlight">\(+\)</span> and <span class="math notranslate nohighlight">\(\cup\)</span> have been used for this purpose. In this book, we use the symbol <span class="math notranslate nohighlight">\(|\)</span> because
it is commonly used in computer implementations of regular expressions.])
Conversely, consider the regular expression (<span class="math notranslate nohighlight">\(a\cdot(a\,|\, b)^*) \,|\, ((a\,|\, b)^*\cdot a)\)</span>.
This is a pattern that matches any string that either has the form “<span class="math notranslate nohighlight">\(a\)</span> followed
by zero or more <span class="math notranslate nohighlight">\(a\)</span>’s or <span class="math notranslate nohighlight">\(b\)</span>’s or both” (<em>i.e.</em>, any string that starts with an <span class="math notranslate nohighlight">\(a\)</span>)
<em>or</em> has the form “zero or more <span class="math notranslate nohighlight">\(a\)</span>’s or <span class="math notranslate nohighlight">\(b\)</span>’s or both followed by an <span class="math notranslate nohighlight">\(a\)</span>”
(<em>i.e.</em> any string that ends with an <span class="math notranslate nohighlight">\(a\)</span>). Thus the regular expression
<em>generates</em> the language of all strings that start or end (or both) in an
<span class="math notranslate nohighlight">\(a\)</span>: this is the set of strings that match the regular expression.</p>
<p>Here are the formal definitions of a regular expression and the language
generated by a regular expression:</p>
<blockquote>
<div><p>Let <span class="math notranslate nohighlight">\(\Sigma\)</span> be an alphabet. Then the
following patterns are <strong>regular expressions</strong> over <span class="math notranslate nohighlight">\(\Sigma\)</span>:</p>
<ol class="simple">
<li><p><span class="math notranslate nohighlight">\(\Phi\)</span> and <span class="math notranslate nohighlight">\(\varepsilon\)</span> are regular expressions;</p></li>
</ol>
</div></blockquote>
<ol class="simple">
<li><p><span class="math notranslate nohighlight">\(a\)</span> is a regular expression, for each <span class="math notranslate nohighlight">\(a \in \Sigma\)</span>;</p></li>
<li><p>if <span class="math notranslate nohighlight">\(r_1\)</span> and <span class="math notranslate nohighlight">\(r_2\)</span> are regular expressions, then so are
<span class="math notranslate nohighlight">\(r_1\,|\, r_2\)</span>, <span class="math notranslate nohighlight">\(r_1\cdot r_2\)</span>, <span class="math notranslate nohighlight">\(r_1^*\)</span> and <span class="math notranslate nohighlight">\((r_1)\)</span> (and of course, <span class="math notranslate nohighlight">\(r_2^*\)</span>
and <span class="math notranslate nohighlight">\((r_2)\)</span>).
As in concatenation of strings, the <span class="math notranslate nohighlight">\(\cdot\)</span> is often left out of
the second expression. (Note: the order of precedence of operators, from lowest to highest,
is <span class="math notranslate nohighlight">\(\,|\,\)</span>, <span class="math notranslate nohighlight">\(\cdot\)</span>, <span class="math notranslate nohighlight">\(*\)</span>.)</p></li>
</ol>
<blockquote>
<div><p>No other patterns are regular expressions.</p>
</div></blockquote>
<blockquote>
<div><p>The <strong>language generated by a regular expression <span class="math notranslate nohighlight">\(r\)</span></strong>,
denoted <span class="math notranslate nohighlight">\(L(r)\)</span>,
is defined as follows:</p>
<ol class="simple">
<li><p><span class="math notranslate nohighlight">\(L(\Phi) = \emptyset\)</span>, <em>i.e.</em>, no strings match <span class="math notranslate nohighlight">\(\Phi\)</span>;</p></li>
</ol>
</div></blockquote>
<ol class="simple">
<li><p><span class="math notranslate nohighlight">\(L(\varepsilon) = \{\varepsilon\}\)</span>, <em>i.e.</em>, <span class="math notranslate nohighlight">\(\varepsilon\)</span> matches only the
empty string;</p></li>
<li><p><span class="math notranslate nohighlight">\(L(a) = \{a\}\)</span>, <em>i.e.</em>, <span class="math notranslate nohighlight">\(a\)</span> matches only the string <span class="math notranslate nohighlight">\(a\)</span>;</p></li>
<li><p><span class="math notranslate nohighlight">\(L(r_1\,|\, r_2) = L(r_1) \cup L(r_2)\)</span>, <em>i.e.</em>, <span class="math notranslate nohighlight">\(r_1\,|\, r_2\)</span> matches
strings that match <span class="math notranslate nohighlight">\(r_1\)</span> or <span class="math notranslate nohighlight">\(r_2\)</span> or both;</p></li>
<li><p><span class="math notranslate nohighlight">\(L(r_1r_2) = L(r_1)L(r_2)\)</span>, <em>i.e.</em>, <span class="math notranslate nohighlight">\(r_1r_2\)</span> matches strings of the form
“something that matches <span class="math notranslate nohighlight">\(r_1\)</span> followed by something that
matches <span class="math notranslate nohighlight">\(r_2\)</span>”;</p></li>
<li><p><span class="math notranslate nohighlight">\(L(r_1^*) = (L(r_1))^*\)</span>, <em>i.e.</em>, <span class="math notranslate nohighlight">\(r_1^*\)</span> matches sequences of 0
or more strings each of which matches <span class="math notranslate nohighlight">\(r_1\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(L((r_1)) = L(r_1)\)</span>, <em>i.e.</em>, <span class="math notranslate nohighlight">\((r_1)\)</span> matches exactly those strings
matched by <span class="math notranslate nohighlight">\(r_1\)</span>.</p></li>
</ol>
<hr class="docutils" />
<p><strong>Example:</strong> Let <span class="math notranslate nohighlight">\(\Sigma = \{a,b\}\)</span>, and consider the regular expression <span class="math notranslate nohighlight">\(r=a^*b^*\)</span>. What is
<span class="math notranslate nohighlight">\(L(r)\)</span>? Well, <span class="math notranslate nohighlight">\(L(a) = \{a\}\)</span> so <span class="math notranslate nohighlight">\(L(a^*) = (L(a))^* = \{a\}^*\)</span>, and <span class="math notranslate nohighlight">\(\{a\}^*\)</span> is
the set of all strings of zero or more <span class="math notranslate nohighlight">\(a\)</span>’s, so <span class="math notranslate nohighlight">\(L(a^*) = \{\varepsilon, a, aa, aaa,
\ldots\}\)</span>. Similarly, <span class="math notranslate nohighlight">\(L(b^*) = \{\varepsilon, b, bb, bbb, \ldots\}\)</span>.
Since <span class="math notranslate nohighlight">\(L(a^*b^*) = L(a^*)L(b^*) = \{xy \ | \ x\in L(a^*)\land y\in L(b^*)\}\)</span>, we
have <span class="math notranslate nohighlight">\(L(a^*b^*) = \{\varepsilon, a, b, aa, ab, bb, aaa, aab, abb, bbb, \ldots\}\)</span>,
which is the set of all strings of the form “zero or more <span class="math notranslate nohighlight">\(a\)</span>’s followed by zero
or more <span class="math notranslate nohighlight">\(b\)</span>’s”.</p>
<hr class="docutils" />
<p><strong>Example:</strong> Let <span class="math notranslate nohighlight">\(\Sigma = \{a,b\}\)</span>, and consider the regular expression <span class="math notranslate nohighlight">\(r=(a\,|\, aa\,|\, aaa)(bb)^*\)</span>.
Since <span class="math notranslate nohighlight">\(L(a) = \{a\}\)</span>, <span class="math notranslate nohighlight">\(L(aa) = L(a)L(a) = \{aa\}\)</span>. Similarly, <span class="math notranslate nohighlight">\(L(aaa) = \{aaa\}\)</span>
and <span class="math notranslate nohighlight">\(L(bb) = \{bb\}\)</span>. Now <span class="math notranslate nohighlight">\(L(a\,|\, aa\,|\, aaa) = L(a) \cup L(aa) \cup L(aaa) = \{a, aa,
aaa\}\)</span>, and <span class="math notranslate nohighlight">\(L((bb)^*) = (L((bb)))^* = (L(bb))^*\)</span> (the last equality is from
clause 7 of Definition \ref{lgbre}), and <span class="math notranslate nohighlight">\((L(bb))^* = \{bb\}^* = \{\varepsilon, bb,
bbbb, \ldots\}\)</span>. So <span class="math notranslate nohighlight">\(L(r)\)</span> is the set of strings formed by
concatenating <span class="math notranslate nohighlight">\(a\)</span> or <span class="math notranslate nohighlight">\(aa\)</span> or <span class="math notranslate nohighlight">\(aaa\)</span> with zero or more pairs of <span class="math notranslate nohighlight">\(b\)</span>’s.</p>
<hr class="docutils" />
<blockquote>
<div><p>A language is <strong>regular</strong> if it is generated by
a regular expression.</p>
</div></blockquote>
<p>Regular languages, then, are languages whose strings’ structure can be described
in a very formal, mathematical way. The fact that a language can be
“mechanically” described or generated means that we are likely to be
able to get a computer to recognize strings in that language.
We will pursue the question of mechanical language recognition in
a later section, and subsequently will see that our first attempt to model mechanical
language recognition does in fact produce a family of “machines” that recognize
exactly the regular languages. But first, in the next section, we will look at some
practical applications of regular expressions.</p>
<div class="section" id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h2>
<ol class="simple">
<li><p>Give English-language descriptions of the languages generated by the
following regular expressions:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\((a\,|\, b)^*\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(a^*\,|\, b^*\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(b^*(ab^*ab^*)^*\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(b^*(abb^*)\)</span></p></li>
</ul>
</li>
<li><p>Give regular expressions over <span class="math notranslate nohighlight">\(\Sigma=\{a,b\}\)</span> that generate the
following languages:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(L_1 = \{ x \ | \ x \textrm{ contains 3 consecutive a's}\}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(L_2 = \{ x \ | \ x \textrm{ has even length}\}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(L_3 = \{ x \ | \ n_b(x) = 2 \bmod{3}\}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(L_4 = \{ x \ | \ x \textrm{ contains the substring } aaba\}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(L_5 = \{ x \ | \ n_b(x) &lt; 2 \}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(L_6 = \{ x \ | \ x \textrm{ doesn't end in } aa\}\)</span></p></li>
</ul>
</li>
<li><p>Prove that all finite languages are regular.</p></li>
</ol>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./lang"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="languages.html" title="previous page">Languages</a>
    <a class='right-next' id="next-link" href="regexpapp.html" title="next page">Applications of Regular Expressions</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Brian T. Howard, based in part on material by Carol Critchlow and David Eck<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    <script src="../_static/js/index.js"></script>
    
  </body>
</html>