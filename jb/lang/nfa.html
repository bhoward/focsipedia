

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Nondeterministic Finite-State Automata &#8212; FoCSipedia</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" integrity="sha384-KA6wR/X5RY4zFAHpv/CnoG2UW1uogYfdnP67Uv7eULvTveboZJg0qUpmJZb5VqzN" crossorigin="anonymous">
    <link href="../_static/css/index.css" rel="stylesheet">
    <link rel="stylesheet" href="../_static/sphinx-book-theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/jupyter-sphinx.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/sphinx-book-theme.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/mystnb.js"></script>
    <script src="../_static/sphinx-book-theme.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Finite-State Automata and Regular Languages" href="fsareg.html" />
    <link rel="prev" title="Finite-State Automata" href="fsa.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="docsearch:language" content="en">



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../index.html">
  
  <img src="../_static/SmartFoxLogo.jpeg" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">FoCSipedia</h1>
  
</a>
</div>

<form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>

<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <ul class="current nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../attribution.html">
   Attribution
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../topics.html">
   Topics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../overview.html">
   Overview of Topics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../logic/index.html">
   Logic
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sets/index.html">
   Sets
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fp/index.html">
   Functional Programming
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../ds/index.html">
   Data Structures
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="reference internal" href="index.html">
   Formal Languages
  </a>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="languages.html">
     Languages
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="regexp.html">
     Regular Expressions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="regexpapp.html">
     Applications of Regular Expressions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="fsa.html">
     Finite-State Automata
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Nondeterministic Finite-State Automata
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="fsareg.html">
     Finite-State Automata and Regular Languages
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="cfg.html">
     Context-Free Grammars
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="bnf.html">
     Backus-Naur Form
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="parsing.html">
     Parsing and Parse Trees
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="pda.html">
     Pushdown Automata
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="tm.html">
     General Grammars and Turing Machines
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="computability.html">
     Computability
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="halting.html">
     The Halting Problem
    </a>
   </li>
  </ul>
 </li>
</ul>

</nav>

 <!-- To handle the deprecated key -->

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        <div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    
    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/lang/nfa.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
    
</div>
        <!-- Source interaction buttons -->


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> On this page
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#connection-with-deterministic-finite-state-automata">
   Connection with Deterministic Finite-State Automata
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#exercises">
   Exercises
  </a>
 </li>
</ul>

        </nav>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="nondeterministic-finite-state-automata">
<h1>Nondeterministic Finite-State Automata<a class="headerlink" href="#nondeterministic-finite-state-automata" title="Permalink to this headline">Â¶</a></h1>
<p>(Content adapted from Critchlow &amp; Eck)</p>
<p>As mentioned briefly above, there is an alternative school of though as to what
properties should be required of a finite-state automatonâs transition function.
Recall our motivating example of a C++ compiler and a legal <code class="docutils literal notranslate"><span class="pre">if</span></code> statement.
In our description, we had the compiler in an âexpecting a <code class="docutils literal notranslate"><span class="pre">)</span></code>â state; on
seeing a <code class="docutils literal notranslate"><span class="pre">)</span></code>, the compiler moved into an âexpecting a <code class="docutils literal notranslate"><span class="pre">{</span></code> or a legal
statementâ state. An alternative way to view this would be to say that the
compiler, on seeing a <code class="docutils literal notranslate"><span class="pre">)</span></code>, could move into one of two different states: it could
move to an âexpecting a <code class="docutils literal notranslate"><span class="pre">{</span></code>â state <em>or</em> move to an âexpecting a legal
statementâ state. Thus, from a single state, on input <code class="docutils literal notranslate"><span class="pre">)</span></code>, the compiler has
multiple moves. This alternative interpretation is not
allowed by the DFA model.</p>
<p>A second point on which one
might question the DFA model is the fact that input must be consumed for the
machine to change state.
Think of the syntax for C++ function declarations. The return type of a
function need not be specified (the default is taken to be <code class="docutils literal notranslate"><span class="pre">int</span></code>). The
start state of the compiler when parsing a function declaration might be
âexpecting a return typeâ; then with no
input consumed, the compiler can move to the state âexpecting a legal function
nameâ. To model this, it might seem reasonable to allow transitions that do
not require
the consumption of input (such transitions are called
<strong><span class="math notranslate nohighlight">\(\varepsilon\)</span>-transitions</strong>). Again, this is not supported by the DFA abstraction.
There is, therefore, a second class of finite-state automata that people
study, the class of nondeterministic finite-state automata.</p>
<p>A <strong>nondeterministic finite-state automaton (NFA)</strong> is the same as a
deterministic
finite-state automaton except that the transition function is no longer a
function that maps a state-input pair to a state; rather, it maps a state-input
pair or a state-<span class="math notranslate nohighlight">\(\varepsilon\)</span> pair to a <em>set</em> of states. No longer do we have
<span class="math notranslate nohighlight">\(\delta(q,a) = q'\)</span>, meaning that the machine
must change to state <span class="math notranslate nohighlight">\(q'\)</span> if it is in state <span class="math notranslate nohighlight">\(q\)</span> and consumes an <span class="math notranslate nohighlight">\(a\)</span>. Rather,
we have <span class="math notranslate nohighlight">\(\partial(q,a) = \{q_1, q_2, \ldots, q_n\}\)</span>, meaning that if the
machine is in state <span class="math notranslate nohighlight">\(q\)</span> and consumes an <span class="math notranslate nohighlight">\(a\)</span>, it might move directly to any one
of the states <span class="math notranslate nohighlight">\(q_1, \ldots, q_n\)</span>. Note that the set of next states
<span class="math notranslate nohighlight">\(\partial(q,a)\)</span> is defined for every state <span class="math notranslate nohighlight">\(q\)</span> and every input symbol <span class="math notranslate nohighlight">\(a\)</span>,
but for some <span class="math notranslate nohighlight">\(q\)</span>âs and <span class="math notranslate nohighlight">\(a\)</span>âs it could be empty, or contain just one state (there
donât <em>have</em> to be multiple next states). The function <span class="math notranslate nohighlight">\(\partial\)</span> must
also specify whether it is possible for the machine to make any moves
without input being consumed, <em>i.e.</em>, <span class="math notranslate nohighlight">\(\partial(q, \varepsilon)\)</span> must be
specified for every state <span class="math notranslate nohighlight">\(q\)</span>. Again, it is quite possible that
<span class="math notranslate nohighlight">\(\partial(q, \varepsilon)\)</span> may be empty for some states <span class="math notranslate nohighlight">\(q\)</span>: there need not be
<span class="math notranslate nohighlight">\(\varepsilon\)</span>-transitions out of <span class="math notranslate nohighlight">\(q\)</span>.</p>
<blockquote>
<div><p>Formally, a nondeterministic finite-state automaton <span class="math notranslate nohighlight">\(M\)</span> is specified by 5 components:
<span class="math notranslate nohighlight">\(M=(Q, \Sigma, q_0, \partial, F)\)</span> where</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(Q\)</span>, <span class="math notranslate nohighlight">\(\Sigma\)</span>, <span class="math notranslate nohighlight">\(q_0\)</span> and <span class="math notranslate nohighlight">\(F\)</span> are as in the definition of DFAs;</p></li>
<li><p><span class="math notranslate nohighlight">\(\partial\)</span> is a transition function that takes
<span class="math notranslate nohighlight">\(\langle\textrm{state, input symbol}\rangle\)</span> pairs and maps each one to a set of states. To say
<span class="math notranslate nohighlight">\(\partial(q,a) = \{q_1, q_2, \ldots , q_n\}\)</span> means that
if the machine is in state <span class="math notranslate nohighlight">\(q\)</span> and the input symbol <span class="math notranslate nohighlight">\(a\)</span> is consumed, then the
machine may move directly into any one of states <span class="math notranslate nohighlight">\(q_1, q_2, \ldots , q_n\)</span>.
The function <span class="math notranslate nohighlight">\(\partial\)</span> must also be defined for every <span class="math notranslate nohighlight">\(\langle\textrm{state},\varepsilon\rangle\)</span> pair.
To say
<span class="math notranslate nohighlight">\(\partial(q,\varepsilon) = \{q_1, q_2, \ldots , q_n\}\)</span> means that there are direct
<span class="math notranslate nohighlight">\(\varepsilon\)</span>-transitions from state <span class="math notranslate nohighlight">\(q\)</span> to each of <span class="math notranslate nohighlight">\(q_1, q_2, \ldots , q_n\)</span>.</p></li>
</ul>
<p>The formal description of the function <span class="math notranslate nohighlight">\(\partial\)</span> is <span class="math notranslate nohighlight">\(\partial : Q \times
(\Sigma \cup \{\varepsilon\}) \rightarrow {\mathscr P}(Q)\)</span>.</p>
</div></blockquote>
<p>The function <span class="math notranslate nohighlight">\(\partial\)</span> describes how the machine functions on zero or one
input symbol.
As with DFAs, we will often want to refer to the behavior of the machine on a
string of inputs, and so we use the notation <span class="math notranslate nohighlight">\(\partial^*(q,w)\)</span> as shorthand
for âthe set of states in which
the machine might be if it starts in state <span class="math notranslate nohighlight">\(q\)</span> and consumes input string <span class="math notranslate nohighlight">\(w\)</span>â.
As with DFAs, <span class="math notranslate nohighlight">\(\partial^*(q,w)\)</span> is
determined by the specification of <span class="math notranslate nohighlight">\(\partial\)</span>. Note that for every state <span class="math notranslate nohighlight">\(q\)</span>,
<span class="math notranslate nohighlight">\(\partial^*(q, \varepsilon)\)</span> contains at least <span class="math notranslate nohighlight">\(q\)</span>, and may contain additional states if
there are (sequences of) <span class="math notranslate nohighlight">\(\varepsilon\)</span>-transitions out of <span class="math notranslate nohighlight">\(q\)</span>.</p>
<p>We do have to think a bit carefully about what it means for an NFA to accept a
string <span class="math notranslate nohighlight">\(w\)</span>. Suppose <span class="math notranslate nohighlight">\(\partial^*(q_0,w)\)</span> contains both accepting and non-accepting
states, <em>i.e.</em>, the machine could end in an accepting state after consuming <span class="math notranslate nohighlight">\(w\)</span>,
but it might also end in a non-accepting state. Should we consider the machine
to accept <span class="math notranslate nohighlight">\(w\)</span>, or should we require every state in <span class="math notranslate nohighlight">\(\partial^*(q_0,w)\)</span> to be
accepting before we admit <span class="math notranslate nohighlight">\(w\)</span> to the ranks of the accepted? Think of the C++
compiler again: provided that an <code class="docutils literal notranslate"><span class="pre">if</span></code> statement fits one of the legal
syntax specifications, the compiler will accept it. So we take as the
definition of acceptance by an NFA: A string <span class="math notranslate nohighlight">\(w\)</span> is accepted by an NFA provided
that at least one of the states in <span class="math notranslate nohighlight">\(\partial^*(q_0, w)\)</span> is an accepting state.
That is, if there is some sequence of steps of the machine that consumes <span class="math notranslate nohighlight">\(w\)</span>
and leaves the machine in an accepting state, then the machine accepts <span class="math notranslate nohighlight">\(w\)</span>.
Formally:</p>
<blockquote>
<div><p>Let <span class="math notranslate nohighlight">\(M= (Q, \Sigma, q_0, \partial, F)\)</span> be a nondeterministic finite-state
automaton. The string <span class="math notranslate nohighlight">\(w\in\Sigma^*\)</span> is <strong>accepted</strong>
by <span class="math notranslate nohighlight">\(M\)</span> iff <span class="math notranslate nohighlight">\(\partial^*(q_0,w)\)</span> contains at least one state <span class="math notranslate nohighlight">\(q_F \in F\)</span>.</p>
<p>The <strong>language accepted by <span class="math notranslate nohighlight">\(M\)</span></strong>, denoted <span class="math notranslate nohighlight">\(L(M)\)</span>, is the set of all strings
<span class="math notranslate nohighlight">\(w\in\Sigma^*\)</span> that are
accepted by <span class="math notranslate nohighlight">\(M\)</span>: <span class="math notranslate nohighlight">\(L(M) = \{ w \in \Sigma^* \ | \ \partial^*(q_0, w) \cap F \not= 
\emptyset\}\)</span>.</p>
</div></blockquote>
<hr class="docutils" />
<p><strong>Example:</strong> The NFA shown below accepts all strings of <span class="math notranslate nohighlight">\(a\)</span>âs
and <span class="math notranslate nohighlight">\(b\)</span>âs in which the second-to-last symbol is <span class="math notranslate nohighlight">\(a\)</span>.</p>
<p>&lt;img src={useBaseUrl(âimg/fsa8.pngâ)}
alt=âExample NFAâ className=âcentered-figureâ /&gt;</p>
<hr class="docutils" />
<div class="section" id="connection-with-deterministic-finite-state-automata">
<h2>Connection with Deterministic Finite-State Automata<a class="headerlink" href="#connection-with-deterministic-finite-state-automata" title="Permalink to this headline">Â¶</a></h2>
<p>It should be fairly clear that every language that is accepted by a DFA is also
accepted by an NFA. Pictorially, a DFA looks exactly like an NFA (an NFA that
doesnât happen to have any <span class="math notranslate nohighlight">\(\varepsilon\)</span>-transitions or multiple same-label
transitions from any state), though there is slightly more going on behind
the scenes. Formally, given the DFA <span class="math notranslate nohighlight">\(M=(Q, \Sigma, q_0, \delta, F)\)</span>, you can
build an NFA <span class="math notranslate nohighlight">\(M'=(Q, \Sigma, q_0, \partial, F)\)</span> where 4 of the 5 components
are the same and where every transition <span class="math notranslate nohighlight">\(\delta(q,a) = q'\)</span> has been replaced by
<span class="math notranslate nohighlight">\(\partial(q,a) = \{q'\}\)</span>.</p>
<p>But is the reverse true? Can any NFA-recognized language be recognized by a DFA?
Look, for example, at the language in the example above. Can you come up with
a DFA that accepts this language? Try it. Itâs pretty difficult to do. But
does that mean that there really is <em>no</em> DFA that accepts the language, or
only that we havenât been clever enough to find one?</p>
<p>It turns out that the limitation is in fact in our cleverness, and not in the
power of DFAs.[^The fault, dear reader, is not in our <span class="math notranslate nohighlight">\(\delta^*\)</span>, but in ourselves.]</p>
<blockquote>
<div><p><strong>Theorem: The Subset Construction</strong><br />
Every language that is accepted by an NFA is accepted by a DFA.</p>
<p><strong>Proof:</strong> Suppose we are given an NFA <span class="math notranslate nohighlight">\(N = (P, \Sigma, p_0, \partial, F_p)\)</span>, and we want to
build a DFA <span class="math notranslate nohighlight">\(D=(Q, \Sigma, q_0, \delta, F_q)\)</span> that accepts the same language.
The idea is to make the states in <span class="math notranslate nohighlight">\(D\)</span> correspond to <em>subsets</em>
of <span class="math notranslate nohighlight">\(N\)</span>âs states, and
then to set up <span class="math notranslate nohighlight">\(D\)</span>âs transition function <span class="math notranslate nohighlight">\(\delta\)</span> so that for any string <span class="math notranslate nohighlight">\(w\)</span>,
<span class="math notranslate nohighlight">\(\delta^*(q_0, w)\)</span> corresponds to <span class="math notranslate nohighlight">\(\partial^*(p_0,w)\)</span>; <em>i.e.</em>, the <em>single</em> state that
<span class="math notranslate nohighlight">\(w\)</span> gets you to in <span class="math notranslate nohighlight">\(D\)</span> corresponds to the <em>set</em> of states that <span class="math notranslate nohighlight">\(w\)</span> could get
you to in <span class="math notranslate nohighlight">\(N\)</span>.
If any of those states is accepting in <span class="math notranslate nohighlight">\(N\)</span>, <span class="math notranslate nohighlight">\(w\)</span> would
be accepted by <span class="math notranslate nohighlight">\(N\)</span>, and so the corresponding state in <span class="math notranslate nohighlight">\(D\)</span> would be made accepting
as well.</p>
<p>So how do we make this work? The first thing to do is to deal with a start state
<span class="math notranslate nohighlight">\(q_0\)</span> for <span class="math notranslate nohighlight">\(D\)</span>. If weâre going to make this state correspond to a subset of <span class="math notranslate nohighlight">\(N\)</span>âs
states, what subset should it be? Well, remember (1) that in any DFA,
<span class="math notranslate nohighlight">\(\delta^*(q_0, \varepsilon) = q_0\)</span>; and (2) we want to make <span class="math notranslate nohighlight">\(\delta^*(q_0, w)\)</span> correspond
to <span class="math notranslate nohighlight">\(\partial^*(p_0,w)\)</span> for every <span class="math notranslate nohighlight">\(w\)</span>. Putting these two limitations together tells
us that we should make <span class="math notranslate nohighlight">\(q_0\)</span> correspond to <span class="math notranslate nohighlight">\(\partial^*(p_0, \varepsilon)\)</span>. So <span class="math notranslate nohighlight">\(q_0\)</span>
corresponds to the subset of all of <span class="math notranslate nohighlight">\(N\)</span>âs states that can be reached with no
input.</p>
<p>Now we progressively set up <span class="math notranslate nohighlight">\(D\)</span>âs transition function <span class="math notranslate nohighlight">\(\delta\)</span> by repeatedly
doing the following:</p>
<ul class="simple">
<li><p>Find a state <span class="math notranslate nohighlight">\(q\)</span> that has been added to <span class="math notranslate nohighlight">\(D\)</span> but whose out-transitions have not
yet been added. (Note that <span class="math notranslate nohighlight">\(q_0\)</span> initially fits this description.) Remember
that the state <span class="math notranslate nohighlight">\(q\)</span> corresponds to some subset <span class="math notranslate nohighlight">\(\{p_1, \ldots , p_n\}\)</span> of <span class="math notranslate nohighlight">\(N\)</span>âs
states.</p></li>
<li><p>For each input symbol <span class="math notranslate nohighlight">\(a\)</span>, look at all <span class="math notranslate nohighlight">\(N\)</span>âs states that can be reached from
any one of <span class="math notranslate nohighlight">\(p_1, \ldots , p_n\)</span> by consuming <span class="math notranslate nohighlight">\(a\)</span> (perhaps making some
<span class="math notranslate nohighlight">\(\varepsilon\)</span>-transitions as well). That is, look at <span class="math notranslate nohighlight">\(\partial^*(p_1,a) \cup \ldots \cup
\partial^*(p_n,a)\)</span>. If there is not already a DFA state <span class="math notranslate nohighlight">\(q'\)</span> that corresponds to
this subset of <span class="math notranslate nohighlight">\(N\)</span>âs states, then add one, and add the transition
<span class="math notranslate nohighlight">\(\delta(q, a)= q'\)</span> to <span class="math notranslate nohighlight">\(D\)</span>âs transitions.</p></li>
</ul>
<p>The above process must halt eventually, as there are only a finite
number of states <span class="math notranslate nohighlight">\(n\)</span> in the NFA, and therefore there can be at most <span class="math notranslate nohighlight">\(2^n\)</span> states in the
DFA, as that is the number of subsets of the NFAâs states. The final states of
the new DFA are those where at least one of the associated NFA states is an
accepting state of the NFA.</p>
<p>Can we now argue that <span class="math notranslate nohighlight">\(L(D) = L(N)\)</span>? We can, if we can argue that
<span class="math notranslate nohighlight">\(\delta^*(q_0,w)\)</span> corresponds to <span class="math notranslate nohighlight">\(\partial^*(p_0,w)\)</span> for all <span class="math notranslate nohighlight">\(w\in\Sigma^*\)</span>: if this
latter property holds, then <span class="math notranslate nohighlight">\(w \in L(D)\)</span> iff <span class="math notranslate nohighlight">\(\delta^*(q_0,w)\)</span> is accepting, which
we made be so iff <span class="math notranslate nohighlight">\(\partial^*(p_0,w)\)</span> contains an accepting state of <span class="math notranslate nohighlight">\(N\)</span>, which
happens iff <span class="math notranslate nohighlight">\(N\)</span> accepts <span class="math notranslate nohighlight">\(w\)</span> <em>i.e.</em>, iff <span class="math notranslate nohighlight">\(w \in L(N)\)</span>.</p>
<p>So can we argue that <span class="math notranslate nohighlight">\(\delta^*(q_0,w)\)</span> does in fact correspond to <span class="math notranslate nohighlight">\(\partial^*(p_0,w)\)</span>
for all <span class="math notranslate nohighlight">\(w\)</span>? We can, using induction on the length of <span class="math notranslate nohighlight">\(w\)</span>.</p>
<p>First, a preliminary observation. Suppose <span class="math notranslate nohighlight">\(w=xa\)</span>, <em>i.e.</em>, <span class="math notranslate nohighlight">\(w\)</span> is the string <span class="math notranslate nohighlight">\(x\)</span>
followed by the single symbol <span class="math notranslate nohighlight">\(a\)</span>. How are <span class="math notranslate nohighlight">\(\partial^*(p_0,x)\)</span> and <span class="math notranslate nohighlight">\(\partial^*(p_0,w)\)</span>
related? Well, recall that <span class="math notranslate nohighlight">\(\partial^*(p_0,x)\)</span> is the set of all states that <span class="math notranslate nohighlight">\(N\)</span> can
reach when it starts in <span class="math notranslate nohighlight">\(p_0\)</span> and consumes <span class="math notranslate nohighlight">\(x\)</span>:
<span class="math notranslate nohighlight">\(\partial^*(p_0,x) = \{p_1, \ldots, p_n\}\)</span> for some states
<span class="math notranslate nohighlight">\(p_1, \ldots, p_n\)</span>. Now, <span class="math notranslate nohighlight">\(w\)</span> is just <span class="math notranslate nohighlight">\(x\)</span> with an additional <span class="math notranslate nohighlight">\(a\)</span>, so where might
<span class="math notranslate nohighlight">\(N\)</span> end up if it starts in <span class="math notranslate nohighlight">\(p_0\)</span> and consumes <span class="math notranslate nohighlight">\(w\)</span>? We know that <span class="math notranslate nohighlight">\(x\)</span> gets <span class="math notranslate nohighlight">\(N\)</span> to
<span class="math notranslate nohighlight">\(p_1\)</span> or <span class="math notranslate nohighlight">\(\ldots\)</span> or <span class="math notranslate nohighlight">\(p_n\)</span>, so <span class="math notranslate nohighlight">\(xa\)</span> gets <span class="math notranslate nohighlight">\(N\)</span> to any state that can be reached
from <span class="math notranslate nohighlight">\(p_1\)</span> with an <span class="math notranslate nohighlight">\(a\)</span> (and maybe some <span class="math notranslate nohighlight">\(\varepsilon\)</span>-transitions), and to any state
that can be reached from <span class="math notranslate nohighlight">\(p_2\)</span> with an <span class="math notranslate nohighlight">\(a\)</span> (and maybe some <span class="math notranslate nohighlight">\(\varepsilon\)</span>-transitions),
etc. Thus, our relationship between <span class="math notranslate nohighlight">\(\partial^*(p_0,x)\)</span> and <span class="math notranslate nohighlight">\(\partial^*(p_0,w)\)</span> is that
if <span class="math notranslate nohighlight">\(\partial^*(p_0,x) = \{p_1, \ldots, p_n\}\)</span>, then <span class="math notranslate nohighlight">\(\partial^*(p_0,w) = \partial^*(p_1,a)
\cup \ldots \cup \partial^*(p_n,a)\)</span>. With this observation in hand, letâs proceed to
our proof by induction.</p>
<p>We want to prove that <span class="math notranslate nohighlight">\(\delta^*(q_0,w)\)</span> corresponds to <span class="math notranslate nohighlight">\(\partial^*(p_0,w)\)</span> for all
<span class="math notranslate nohighlight">\(w\in\Sigma^*\)</span>. We use induction on the length of <span class="math notranslate nohighlight">\(w\)</span>.</p>
<p><strong>Base case:</strong> Suppose <span class="math notranslate nohighlight">\(w\)</span> has length 0. The only string <span class="math notranslate nohighlight">\(w\)</span> with length 0 is
<span class="math notranslate nohighlight">\(\varepsilon\)</span>, so we want to show that
<span class="math notranslate nohighlight">\(\delta^*(q_0,\varepsilon)\)</span> corresponds to <span class="math notranslate nohighlight">\(\partial^*(p_0,\varepsilon)\)</span>. Well,
<span class="math notranslate nohighlight">\(\delta^*(q_0, \varepsilon) = q_0\)</span>, since in a DFA, <span class="math notranslate nohighlight">\(\delta^*(q, \varepsilon) = q\)</span> for any
state~<span class="math notranslate nohighlight">\(q\)</span>. We explicitly made <span class="math notranslate nohighlight">\(q_0\)</span> correspond to
<span class="math notranslate nohighlight">\(\partial^*(p_0,\varepsilon)\)</span>, and so the property holds for <span class="math notranslate nohighlight">\(w\)</span> with length 0.</p>
<p><strong>Inductive case:</strong> Assume that the desired property holds for some number <span class="math notranslate nohighlight">\(n\)</span>,
<em>i.e.</em>, that <span class="math notranslate nohighlight">\(\delta^*(q_0,x)\)</span> corresponds to <span class="math notranslate nohighlight">\(\partial^*(p_0,x)\)</span> for all <span class="math notranslate nohighlight">\(x\)</span> with
length <span class="math notranslate nohighlight">\(n\)</span>. Look at an arbitrary string <span class="math notranslate nohighlight">\(w\)</span> with length <span class="math notranslate nohighlight">\(n+1\)</span>.
We want to show that <span class="math notranslate nohighlight">\(\delta^*(q_0,w)\)</span> corresponds to <span class="math notranslate nohighlight">\(\partial^*(p_0,w)\)</span>.
Well, the string <span class="math notranslate nohighlight">\(w\)</span>
must look like <span class="math notranslate nohighlight">\(xa\)</span> for some string <span class="math notranslate nohighlight">\(x\)</span> (whose length is <span class="math notranslate nohighlight">\(n\)</span>) and some symbol
<span class="math notranslate nohighlight">\(a\)</span>. By our inductive hypothesis, we know
<span class="math notranslate nohighlight">\(\delta^*(q_0,x)\)</span> corresponds to <span class="math notranslate nohighlight">\(\partial^*(p_0,x)\)</span>. We know <span class="math notranslate nohighlight">\(\partial^*(p_0,x)\)</span> is a
set of <span class="math notranslate nohighlight">\(N\)</span>âs states, say
<span class="math notranslate nohighlight">\(\partial^*(p_0,x) = \{p_1, \ldots, p_n\}\)</span>.</p>
<p>At this point, our subsequent reasoning might be a bit clearer if we give
explicit names
to <span class="math notranslate nohighlight">\(\delta^*(q_0,w)\)</span> (the state <span class="math notranslate nohighlight">\(D\)</span>
reaches on input <span class="math notranslate nohighlight">\(w\)</span>) and <span class="math notranslate nohighlight">\(\delta^*(q_0,x)\)</span> (the state <span class="math notranslate nohighlight">\(D\)</span>
reaches on input <span class="math notranslate nohighlight">\(x\)</span>). Let <span class="math notranslate nohighlight">\(q_w = \delta^*(q_0, w)\)</span>, and let
<span class="math notranslate nohighlight">\(q_x = \delta^*(q_0,x)\)</span>. We know, because <span class="math notranslate nohighlight">\(w=xa\)</span>, there must be an
<span class="math notranslate nohighlight">\(a\)</span>-transition from <span class="math notranslate nohighlight">\(q_x\)</span> to <span class="math notranslate nohighlight">\(q_w\)</span>. Look at how we added transitions to
<span class="math notranslate nohighlight">\(\delta\)</span>: the fact that there is an <span class="math notranslate nohighlight">\(a\)</span>-transition from <span class="math notranslate nohighlight">\(q_x\)</span> to <span class="math notranslate nohighlight">\(q_w\)</span> means that
<span class="math notranslate nohighlight">\(q_w\)</span> corresponds to the set <span class="math notranslate nohighlight">\(\partial^*(p_1,a)
\cup \ldots \cup \partial^*(p_n,a)\)</span> of <span class="math notranslate nohighlight">\(N\)</span>âs states. By our preliminary observation,
<span class="math notranslate nohighlight">\(\partial^*(p_1,a)
\cup \ldots \cup \partial^*(p_n,a)\)</span> is just <span class="math notranslate nohighlight">\(\partial^*(p_0,w)\)</span>. So <span class="math notranslate nohighlight">\(q_w\)</span> (or
<span class="math notranslate nohighlight">\(\delta^*(q_0,w)\)</span>) corresponds to <span class="math notranslate nohighlight">\(\partial^*(p_0,w)\)</span>, which is what we wanted to
prove. Since <span class="math notranslate nohighlight">\(w\)</span> was an arbitrary string of length <span class="math notranslate nohighlight">\(n+1\)</span>, we have shown that
the property holds for <span class="math notranslate nohighlight">\(n+1\)</span>.</p>
<p>Altogether, we have shown by induction that <span class="math notranslate nohighlight">\(\delta^*(q_0,w)\)</span> corresponds to
<span class="math notranslate nohighlight">\(\partial^*(p_0,w)\)</span> for all
<span class="math notranslate nohighlight">\(w\in\Sigma^*\)</span>. As indicated at the very beginning of this proof, that is enough to
prove that <span class="math notranslate nohighlight">\(L(D)= L(N)\)</span>. So for any NFA <span class="math notranslate nohighlight">\(N\)</span>, we can find a DFA <span class="math notranslate nohighlight">\(D\)</span> that accepts
the same language.</p>
</div></blockquote>
<hr class="docutils" />
<p><strong>Example:</strong>
Consider the NFA shown below.</p>
<p>&lt;img src={useBaseUrl(âimg/fsa9.pngâ)}
alt=âExample NFAâ className=âcentered-figureâ /&gt;</p>
<p>We start by looking at <span class="math notranslate nohighlight">\(\partial^*(p_0, \varepsilon)\)</span>, and then add transitions and
states as described above.</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\partial^*(p_0, \varepsilon) = \{p_0\}\)</span> so <span class="math notranslate nohighlight">\(q_0 = \{p_0\}\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(\delta(q_0,a)\)</span> will be <span class="math notranslate nohighlight">\(\partial^*(p_0,a)\)</span>, which is <span class="math notranslate nohighlight">\(\{p_0\}\)</span>,
so <span class="math notranslate nohighlight">\(\delta(q_0,a) = q_0\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(\delta(q_0,b)\)</span> will be <span class="math notranslate nohighlight">\(\partial^*(p_0,b)\)</span>, which is <span class="math notranslate nohighlight">\(\{p_0, p_1\}\)</span>,
so we need to add a new state
<span class="math notranslate nohighlight">\(q_1 = \{p_0, p_1\}\)</span> to the DFA; and add <span class="math notranslate nohighlight">\(\delta(q_0,b) = q_1\)</span> to the DFAâs
transition function.</p></li>
<li><p><span class="math notranslate nohighlight">\(\delta(q_1,a)\)</span> will be <span class="math notranslate nohighlight">\(\partial^*(p_0,a)\)</span> unioned with <span class="math notranslate nohighlight">\(\partial^*(p_1,a)\)</span> since
<span class="math notranslate nohighlight">\(q_1 = \{p_0, p_1\}\)</span>. Since <span class="math notranslate nohighlight">\(\partial^*(p_0,a) \cup \partial^*(p_1,a) = \{p_0\} \cup
\{p_2\} = \{p_0,p_2\}\)</span>, we need to add a new state <span class="math notranslate nohighlight">\(q_2 = \{p_0, p_2\}\)</span> to the
DFA, and a transition <span class="math notranslate nohighlight">\(\delta(q_1,a) = q_2\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(\delta(q_1,b)\)</span> will be <span class="math notranslate nohighlight">\(\partial^*(p_0,b)\)</span> unioned with <span class="math notranslate nohighlight">\(\partial^*(p_1,b)\)</span>, which
gives <span class="math notranslate nohighlight">\(\{p_0, p_1\} \cup \{p_2\}\)</span>, which again gives us a new state <span class="math notranslate nohighlight">\(q_3\)</span> to add to
the DFA, together with the transition <span class="math notranslate nohighlight">\(\delta(q_1,b) = q_3\)</span>.
\end{itemize}</p></li>
</ul>
<p>At this point, our partially-constructed DFA looks as shown below:</p>
<p>&lt;img src={useBaseUrl(âimg/fsa10.pngâ)}
alt=âExample DFAâ className=âcentered-figureâ /&gt;</p>
<p>The construction continues as long as there are new states being added, and new
transitions from those states that have to be computed.
The final DFA is shown below.</p>
<p>&lt;img src={useBaseUrl(âimg/fsa11.pngâ)}
alt=âExample DFAâ className=âcentered-figureâ /&gt;</p>
</div>
<hr class="docutils" />
<div class="section" id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">Â¶</a></h2>
<ol class="simple">
<li><p>What language does the NFA in the above accept?</p></li>
<li><p>Give a DFA that accepts the language accepted by the
following NFA.</p></li>
</ol>
<p>&lt;img src={useBaseUrl(âimg/fsa3ex.pngâ)}
alt=âExample DFAâ className=âcentered-figureâ /&gt;</p>
<ol class="simple">
<li><p>Give a DFA that accepts the language accepted by the following NFA.
(Be sure to note that, for example, it is possible to reach both <span class="math notranslate nohighlight">\(q_1\)</span> and
<span class="math notranslate nohighlight">\(q_3\)</span> from <span class="math notranslate nohighlight">\(q_0\)</span> on consumption of an <span class="math notranslate nohighlight">\(a\)</span>, because of the
<span class="math notranslate nohighlight">\(\varepsilon\)</span>-transition.)</p></li>
</ol>
<p>&lt;img src={useBaseUrl(âimg/fsa4ex.pngâ)}
alt=âExample DFAâ className=âcentered-figureâ /&gt;</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./lang"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="fsa.html" title="previous page">Finite-State Automata</a>
    <a class='right-next' id="next-link" href="fsareg.html" title="next page">Finite-State Automata and Regular Languages</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Brian T. Howard, based in part on material by Carol Critchlow and David Eck<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    <script src="../_static/js/index.js"></script>
    
  </body>
</html>