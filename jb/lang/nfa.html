

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Nondeterministic Finite-State Automata &#8212; FoCSipedia</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" integrity="sha384-KA6wR/X5RY4zFAHpv/CnoG2UW1uogYfdnP67Uv7eULvTveboZJg0qUpmJZb5VqzN" crossorigin="anonymous">
    <link href="../_static/css/index.css" rel="stylesheet">
    <link rel="stylesheet" href="../_static/sphinx-book-theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/jupyter-sphinx.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/sphinx-book-theme.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/mystnb.js"></script>
    <script src="../_static/sphinx-book-theme.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Finite-State Automata and Regular Languages" href="fsareg.html" />
    <link rel="prev" title="Finite-State Automata" href="fsa.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="docsearch:language" content="en">



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../index.html">
  
  <img src="../_static/SmartFoxLogo.jpeg" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">FoCSipedia</h1>
  
</a>
</div>

<form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>

<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <ul class="current nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../attribution.html">
   Attribution
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../topics.html">
   Topics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../overview.html">
   Overview of Topics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../logic/index.html">
   Logic
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sets/index.html">
   Sets
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fp/index.html">
   Functional Programming
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../ds/index.html">
   Data Structures
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="reference internal" href="index.html">
   Formal Languages
  </a>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="languages.html">
     Languages
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="regexp.html">
     Regular Expressions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="regexpapp.html">
     Applications of Regular Expressions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="fsa.html">
     Finite-State Automata
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Nondeterministic Finite-State Automata
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="fsareg.html">
     Finite-State Automata and Regular Languages
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="cfg.html">
     Context-Free Grammars
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="bnf.html">
     Backus-Naur Form
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="parsing.html">
     Parsing and Parse Trees
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="pda.html">
     Pushdown Automata
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="tm.html">
     General Grammars and Turing Machines
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="computability.html">
     Computability
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="halting.html">
     The Halting Problem
    </a>
   </li>
  </ul>
 </li>
</ul>

</nav>

 <!-- To handle the deprecated key -->

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        <div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    
    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/lang/nfa.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
    
</div>
        <!-- Source interaction buttons -->


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> On this page
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#connection-with-deterministic-finite-state-automata">
   Connection with Deterministic Finite-State Automata
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#exercises">
   Exercises
  </a>
 </li>
</ul>

        </nav>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="nondeterministic-finite-state-automata">
<h1>Nondeterministic Finite-State Automata<a class="headerlink" href="#nondeterministic-finite-state-automata" title="Permalink to this headline">¶</a></h1>
<p>(Content adapted from Critchlow &amp; Eck)</p>
<p>As mentioned briefly above, there is an alternative school of though as to what
properties should be required of a finite-state automaton’s transition function.
Recall our motivating example of a C++ compiler and a legal <code class="docutils literal notranslate"><span class="pre">if</span></code> statement.
In our description, we had the compiler in an “expecting a <code class="docutils literal notranslate"><span class="pre">)</span></code>” state; on
seeing a <code class="docutils literal notranslate"><span class="pre">)</span></code>, the compiler moved into an “expecting a <code class="docutils literal notranslate"><span class="pre">{</span></code> or a legal
statement” state. An alternative way to view this would be to say that the
compiler, on seeing a <code class="docutils literal notranslate"><span class="pre">)</span></code>, could move into one of two different states: it could
move to an “expecting a <code class="docutils literal notranslate"><span class="pre">{</span></code>” state <em>or</em> move to an “expecting a legal
statement” state. Thus, from a single state, on input <code class="docutils literal notranslate"><span class="pre">)</span></code>, the compiler has
multiple moves. This alternative interpretation is not
allowed by the DFA model.</p>
<p>A second point on which one
might question the DFA model is the fact that input must be consumed for the
machine to change state.
Think of the syntax for C++ function declarations. The return type of a
function need not be specified (the default is taken to be <code class="docutils literal notranslate"><span class="pre">int</span></code>). The
start state of the compiler when parsing a function declaration might be
“expecting a return type”; then with no
input consumed, the compiler can move to the state “expecting a legal function
name”. To model this, it might seem reasonable to allow transitions that do
not require
the consumption of input (such transitions are called
<strong><span class="math notranslate nohighlight">\(\varepsilon\)</span>-transitions</strong>). Again, this is not supported by the DFA abstraction.
There is, therefore, a second class of finite-state automata that people
study, the class of nondeterministic finite-state automata.</p>
<p>A <strong>nondeterministic finite-state automaton (NFA)</strong> is the same as a
deterministic
finite-state automaton except that the transition function is no longer a
function that maps a state-input pair to a state; rather, it maps a state-input
pair or a state-<span class="math notranslate nohighlight">\(\varepsilon\)</span> pair to a <em>set</em> of states. No longer do we have
<span class="math notranslate nohighlight">\(\delta(q,a) = q'\)</span>, meaning that the machine
must change to state <span class="math notranslate nohighlight">\(q'\)</span> if it is in state <span class="math notranslate nohighlight">\(q\)</span> and consumes an <span class="math notranslate nohighlight">\(a\)</span>. Rather,
we have <span class="math notranslate nohighlight">\(\partial(q,a) = \{q_1, q_2, \ldots, q_n\}\)</span>, meaning that if the
machine is in state <span class="math notranslate nohighlight">\(q\)</span> and consumes an <span class="math notranslate nohighlight">\(a\)</span>, it might move directly to any one
of the states <span class="math notranslate nohighlight">\(q_1, \ldots, q_n\)</span>. Note that the set of next states
<span class="math notranslate nohighlight">\(\partial(q,a)\)</span> is defined for every state <span class="math notranslate nohighlight">\(q\)</span> and every input symbol <span class="math notranslate nohighlight">\(a\)</span>,
but for some <span class="math notranslate nohighlight">\(q\)</span>’s and <span class="math notranslate nohighlight">\(a\)</span>’s it could be empty, or contain just one state (there
don’t <em>have</em> to be multiple next states). The function <span class="math notranslate nohighlight">\(\partial\)</span> must
also specify whether it is possible for the machine to make any moves
without input being consumed, <em>i.e.</em>, <span class="math notranslate nohighlight">\(\partial(q, \varepsilon)\)</span> must be
specified for every state <span class="math notranslate nohighlight">\(q\)</span>. Again, it is quite possible that
<span class="math notranslate nohighlight">\(\partial(q, \varepsilon)\)</span> may be empty for some states <span class="math notranslate nohighlight">\(q\)</span>: there need not be
<span class="math notranslate nohighlight">\(\varepsilon\)</span>-transitions out of <span class="math notranslate nohighlight">\(q\)</span>.</p>
<blockquote>
<div><p>Formally, a nondeterministic finite-state automaton <span class="math notranslate nohighlight">\(M\)</span> is specified by 5 components:
<span class="math notranslate nohighlight">\(M=(Q, \Sigma, q_0, \partial, F)\)</span> where</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(Q\)</span>, <span class="math notranslate nohighlight">\(\Sigma\)</span>, <span class="math notranslate nohighlight">\(q_0\)</span> and <span class="math notranslate nohighlight">\(F\)</span> are as in the definition of DFAs;</p></li>
<li><p><span class="math notranslate nohighlight">\(\partial\)</span> is a transition function that takes
<span class="math notranslate nohighlight">\(\langle\textrm{state, input symbol}\rangle\)</span> pairs and maps each one to a set of states. To say
<span class="math notranslate nohighlight">\(\partial(q,a) = \{q_1, q_2, \ldots , q_n\}\)</span> means that
if the machine is in state <span class="math notranslate nohighlight">\(q\)</span> and the input symbol <span class="math notranslate nohighlight">\(a\)</span> is consumed, then the
machine may move directly into any one of states <span class="math notranslate nohighlight">\(q_1, q_2, \ldots , q_n\)</span>.
The function <span class="math notranslate nohighlight">\(\partial\)</span> must also be defined for every <span class="math notranslate nohighlight">\(\langle\textrm{state},\varepsilon\rangle\)</span> pair.
To say
<span class="math notranslate nohighlight">\(\partial(q,\varepsilon) = \{q_1, q_2, \ldots , q_n\}\)</span> means that there are direct
<span class="math notranslate nohighlight">\(\varepsilon\)</span>-transitions from state <span class="math notranslate nohighlight">\(q\)</span> to each of <span class="math notranslate nohighlight">\(q_1, q_2, \ldots , q_n\)</span>.</p></li>
</ul>
<p>The formal description of the function <span class="math notranslate nohighlight">\(\partial\)</span> is <span class="math notranslate nohighlight">\(\partial : Q \times
(\Sigma \cup \{\varepsilon\}) \rightarrow {\mathscr P}(Q)\)</span>.</p>
</div></blockquote>
<p>The function <span class="math notranslate nohighlight">\(\partial\)</span> describes how the machine functions on zero or one
input symbol.
As with DFAs, we will often want to refer to the behavior of the machine on a
string of inputs, and so we use the notation <span class="math notranslate nohighlight">\(\partial^*(q,w)\)</span> as shorthand
for “the set of states in which
the machine might be if it starts in state <span class="math notranslate nohighlight">\(q\)</span> and consumes input string <span class="math notranslate nohighlight">\(w\)</span>”.
As with DFAs, <span class="math notranslate nohighlight">\(\partial^*(q,w)\)</span> is
determined by the specification of <span class="math notranslate nohighlight">\(\partial\)</span>. Note that for every state <span class="math notranslate nohighlight">\(q\)</span>,
<span class="math notranslate nohighlight">\(\partial^*(q, \varepsilon)\)</span> contains at least <span class="math notranslate nohighlight">\(q\)</span>, and may contain additional states if
there are (sequences of) <span class="math notranslate nohighlight">\(\varepsilon\)</span>-transitions out of <span class="math notranslate nohighlight">\(q\)</span>.</p>
<p>We do have to think a bit carefully about what it means for an NFA to accept a
string <span class="math notranslate nohighlight">\(w\)</span>. Suppose <span class="math notranslate nohighlight">\(\partial^*(q_0,w)\)</span> contains both accepting and non-accepting
states, <em>i.e.</em>, the machine could end in an accepting state after consuming <span class="math notranslate nohighlight">\(w\)</span>,
but it might also end in a non-accepting state. Should we consider the machine
to accept <span class="math notranslate nohighlight">\(w\)</span>, or should we require every state in <span class="math notranslate nohighlight">\(\partial^*(q_0,w)\)</span> to be
accepting before we admit <span class="math notranslate nohighlight">\(w\)</span> to the ranks of the accepted? Think of the C++
compiler again: provided that an <code class="docutils literal notranslate"><span class="pre">if</span></code> statement fits one of the legal
syntax specifications, the compiler will accept it. So we take as the
definition of acceptance by an NFA: A string <span class="math notranslate nohighlight">\(w\)</span> is accepted by an NFA provided
that at least one of the states in <span class="math notranslate nohighlight">\(\partial^*(q_0, w)\)</span> is an accepting state.
That is, if there is some sequence of steps of the machine that consumes <span class="math notranslate nohighlight">\(w\)</span>
and leaves the machine in an accepting state, then the machine accepts <span class="math notranslate nohighlight">\(w\)</span>.
Formally:</p>
<blockquote>
<div><p>Let <span class="math notranslate nohighlight">\(M= (Q, \Sigma, q_0, \partial, F)\)</span> be a nondeterministic finite-state
automaton. The string <span class="math notranslate nohighlight">\(w\in\Sigma^*\)</span> is <strong>accepted</strong>
by <span class="math notranslate nohighlight">\(M\)</span> iff <span class="math notranslate nohighlight">\(\partial^*(q_0,w)\)</span> contains at least one state <span class="math notranslate nohighlight">\(q_F \in F\)</span>.</p>
<p>The <strong>language accepted by <span class="math notranslate nohighlight">\(M\)</span></strong>, denoted <span class="math notranslate nohighlight">\(L(M)\)</span>, is the set of all strings
<span class="math notranslate nohighlight">\(w\in\Sigma^*\)</span> that are
accepted by <span class="math notranslate nohighlight">\(M\)</span>: <span class="math notranslate nohighlight">\(L(M) = \{ w \in \Sigma^* \ | \ \partial^*(q_0, w) \cap F \not= 
\emptyset\}\)</span>.</p>
</div></blockquote>
<hr class="docutils" />
<p><strong>Example:</strong> The NFA shown below accepts all strings of <span class="math notranslate nohighlight">\(a\)</span>’s
and <span class="math notranslate nohighlight">\(b\)</span>’s in which the second-to-last symbol is <span class="math notranslate nohighlight">\(a\)</span>.</p>
<p>&lt;img src={useBaseUrl(‘img/fsa8.png’)}
alt=”Example NFA” className=”centered-figure” /&gt;</p>
<hr class="docutils" />
<div class="section" id="connection-with-deterministic-finite-state-automata">
<h2>Connection with Deterministic Finite-State Automata<a class="headerlink" href="#connection-with-deterministic-finite-state-automata" title="Permalink to this headline">¶</a></h2>
<p>It should be fairly clear that every language that is accepted by a DFA is also
accepted by an NFA. Pictorially, a DFA looks exactly like an NFA (an NFA that
doesn’t happen to have any <span class="math notranslate nohighlight">\(\varepsilon\)</span>-transitions or multiple same-label
transitions from any state), though there is slightly more going on behind
the scenes. Formally, given the DFA <span class="math notranslate nohighlight">\(M=(Q, \Sigma, q_0, \delta, F)\)</span>, you can
build an NFA <span class="math notranslate nohighlight">\(M'=(Q, \Sigma, q_0, \partial, F)\)</span> where 4 of the 5 components
are the same and where every transition <span class="math notranslate nohighlight">\(\delta(q,a) = q'\)</span> has been replaced by
<span class="math notranslate nohighlight">\(\partial(q,a) = \{q'\}\)</span>.</p>
<p>But is the reverse true? Can any NFA-recognized language be recognized by a DFA?
Look, for example, at the language in the example above. Can you come up with
a DFA that accepts this language? Try it. It’s pretty difficult to do. But
does that mean that there really is <em>no</em> DFA that accepts the language, or
only that we haven’t been clever enough to find one?</p>
<p>It turns out that the limitation is in fact in our cleverness, and not in the
power of DFAs.[^The fault, dear reader, is not in our <span class="math notranslate nohighlight">\(\delta^*\)</span>, but in ourselves.]</p>
<blockquote>
<div><p><strong>Theorem: The Subset Construction</strong><br />
Every language that is accepted by an NFA is accepted by a DFA.</p>
<p><strong>Proof:</strong> Suppose we are given an NFA <span class="math notranslate nohighlight">\(N = (P, \Sigma, p_0, \partial, F_p)\)</span>, and we want to
build a DFA <span class="math notranslate nohighlight">\(D=(Q, \Sigma, q_0, \delta, F_q)\)</span> that accepts the same language.
The idea is to make the states in <span class="math notranslate nohighlight">\(D\)</span> correspond to <em>subsets</em>
of <span class="math notranslate nohighlight">\(N\)</span>’s states, and
then to set up <span class="math notranslate nohighlight">\(D\)</span>’s transition function <span class="math notranslate nohighlight">\(\delta\)</span> so that for any string <span class="math notranslate nohighlight">\(w\)</span>,
<span class="math notranslate nohighlight">\(\delta^*(q_0, w)\)</span> corresponds to <span class="math notranslate nohighlight">\(\partial^*(p_0,w)\)</span>; <em>i.e.</em>, the <em>single</em> state that
<span class="math notranslate nohighlight">\(w\)</span> gets you to in <span class="math notranslate nohighlight">\(D\)</span> corresponds to the <em>set</em> of states that <span class="math notranslate nohighlight">\(w\)</span> could get
you to in <span class="math notranslate nohighlight">\(N\)</span>.
If any of those states is accepting in <span class="math notranslate nohighlight">\(N\)</span>, <span class="math notranslate nohighlight">\(w\)</span> would
be accepted by <span class="math notranslate nohighlight">\(N\)</span>, and so the corresponding state in <span class="math notranslate nohighlight">\(D\)</span> would be made accepting
as well.</p>
<p>So how do we make this work? The first thing to do is to deal with a start state
<span class="math notranslate nohighlight">\(q_0\)</span> for <span class="math notranslate nohighlight">\(D\)</span>. If we’re going to make this state correspond to a subset of <span class="math notranslate nohighlight">\(N\)</span>’s
states, what subset should it be? Well, remember (1) that in any DFA,
<span class="math notranslate nohighlight">\(\delta^*(q_0, \varepsilon) = q_0\)</span>; and (2) we want to make <span class="math notranslate nohighlight">\(\delta^*(q_0, w)\)</span> correspond
to <span class="math notranslate nohighlight">\(\partial^*(p_0,w)\)</span> for every <span class="math notranslate nohighlight">\(w\)</span>. Putting these two limitations together tells
us that we should make <span class="math notranslate nohighlight">\(q_0\)</span> correspond to <span class="math notranslate nohighlight">\(\partial^*(p_0, \varepsilon)\)</span>. So <span class="math notranslate nohighlight">\(q_0\)</span>
corresponds to the subset of all of <span class="math notranslate nohighlight">\(N\)</span>’s states that can be reached with no
input.</p>
<p>Now we progressively set up <span class="math notranslate nohighlight">\(D\)</span>’s transition function <span class="math notranslate nohighlight">\(\delta\)</span> by repeatedly
doing the following:</p>
<ul class="simple">
<li><p>Find a state <span class="math notranslate nohighlight">\(q\)</span> that has been added to <span class="math notranslate nohighlight">\(D\)</span> but whose out-transitions have not
yet been added. (Note that <span class="math notranslate nohighlight">\(q_0\)</span> initially fits this description.) Remember
that the state <span class="math notranslate nohighlight">\(q\)</span> corresponds to some subset <span class="math notranslate nohighlight">\(\{p_1, \ldots , p_n\}\)</span> of <span class="math notranslate nohighlight">\(N\)</span>’s
states.</p></li>
<li><p>For each input symbol <span class="math notranslate nohighlight">\(a\)</span>, look at all <span class="math notranslate nohighlight">\(N\)</span>’s states that can be reached from
any one of <span class="math notranslate nohighlight">\(p_1, \ldots , p_n\)</span> by consuming <span class="math notranslate nohighlight">\(a\)</span> (perhaps making some
<span class="math notranslate nohighlight">\(\varepsilon\)</span>-transitions as well). That is, look at <span class="math notranslate nohighlight">\(\partial^*(p_1,a) \cup \ldots \cup
\partial^*(p_n,a)\)</span>. If there is not already a DFA state <span class="math notranslate nohighlight">\(q'\)</span> that corresponds to
this subset of <span class="math notranslate nohighlight">\(N\)</span>’s states, then add one, and add the transition
<span class="math notranslate nohighlight">\(\delta(q, a)= q'\)</span> to <span class="math notranslate nohighlight">\(D\)</span>’s transitions.</p></li>
</ul>
<p>The above process must halt eventually, as there are only a finite
number of states <span class="math notranslate nohighlight">\(n\)</span> in the NFA, and therefore there can be at most <span class="math notranslate nohighlight">\(2^n\)</span> states in the
DFA, as that is the number of subsets of the NFA’s states. The final states of
the new DFA are those where at least one of the associated NFA states is an
accepting state of the NFA.</p>
<p>Can we now argue that <span class="math notranslate nohighlight">\(L(D) = L(N)\)</span>? We can, if we can argue that
<span class="math notranslate nohighlight">\(\delta^*(q_0,w)\)</span> corresponds to <span class="math notranslate nohighlight">\(\partial^*(p_0,w)\)</span> for all <span class="math notranslate nohighlight">\(w\in\Sigma^*\)</span>: if this
latter property holds, then <span class="math notranslate nohighlight">\(w \in L(D)\)</span> iff <span class="math notranslate nohighlight">\(\delta^*(q_0,w)\)</span> is accepting, which
we made be so iff <span class="math notranslate nohighlight">\(\partial^*(p_0,w)\)</span> contains an accepting state of <span class="math notranslate nohighlight">\(N\)</span>, which
happens iff <span class="math notranslate nohighlight">\(N\)</span> accepts <span class="math notranslate nohighlight">\(w\)</span> <em>i.e.</em>, iff <span class="math notranslate nohighlight">\(w \in L(N)\)</span>.</p>
<p>So can we argue that <span class="math notranslate nohighlight">\(\delta^*(q_0,w)\)</span> does in fact correspond to <span class="math notranslate nohighlight">\(\partial^*(p_0,w)\)</span>
for all <span class="math notranslate nohighlight">\(w\)</span>? We can, using induction on the length of <span class="math notranslate nohighlight">\(w\)</span>.</p>
<p>First, a preliminary observation. Suppose <span class="math notranslate nohighlight">\(w=xa\)</span>, <em>i.e.</em>, <span class="math notranslate nohighlight">\(w\)</span> is the string <span class="math notranslate nohighlight">\(x\)</span>
followed by the single symbol <span class="math notranslate nohighlight">\(a\)</span>. How are <span class="math notranslate nohighlight">\(\partial^*(p_0,x)\)</span> and <span class="math notranslate nohighlight">\(\partial^*(p_0,w)\)</span>
related? Well, recall that <span class="math notranslate nohighlight">\(\partial^*(p_0,x)\)</span> is the set of all states that <span class="math notranslate nohighlight">\(N\)</span> can
reach when it starts in <span class="math notranslate nohighlight">\(p_0\)</span> and consumes <span class="math notranslate nohighlight">\(x\)</span>:
<span class="math notranslate nohighlight">\(\partial^*(p_0,x) = \{p_1, \ldots, p_n\}\)</span> for some states
<span class="math notranslate nohighlight">\(p_1, \ldots, p_n\)</span>. Now, <span class="math notranslate nohighlight">\(w\)</span> is just <span class="math notranslate nohighlight">\(x\)</span> with an additional <span class="math notranslate nohighlight">\(a\)</span>, so where might
<span class="math notranslate nohighlight">\(N\)</span> end up if it starts in <span class="math notranslate nohighlight">\(p_0\)</span> and consumes <span class="math notranslate nohighlight">\(w\)</span>? We know that <span class="math notranslate nohighlight">\(x\)</span> gets <span class="math notranslate nohighlight">\(N\)</span> to
<span class="math notranslate nohighlight">\(p_1\)</span> or <span class="math notranslate nohighlight">\(\ldots\)</span> or <span class="math notranslate nohighlight">\(p_n\)</span>, so <span class="math notranslate nohighlight">\(xa\)</span> gets <span class="math notranslate nohighlight">\(N\)</span> to any state that can be reached
from <span class="math notranslate nohighlight">\(p_1\)</span> with an <span class="math notranslate nohighlight">\(a\)</span> (and maybe some <span class="math notranslate nohighlight">\(\varepsilon\)</span>-transitions), and to any state
that can be reached from <span class="math notranslate nohighlight">\(p_2\)</span> with an <span class="math notranslate nohighlight">\(a\)</span> (and maybe some <span class="math notranslate nohighlight">\(\varepsilon\)</span>-transitions),
etc. Thus, our relationship between <span class="math notranslate nohighlight">\(\partial^*(p_0,x)\)</span> and <span class="math notranslate nohighlight">\(\partial^*(p_0,w)\)</span> is that
if <span class="math notranslate nohighlight">\(\partial^*(p_0,x) = \{p_1, \ldots, p_n\}\)</span>, then <span class="math notranslate nohighlight">\(\partial^*(p_0,w) = \partial^*(p_1,a)
\cup \ldots \cup \partial^*(p_n,a)\)</span>. With this observation in hand, let’s proceed to
our proof by induction.</p>
<p>We want to prove that <span class="math notranslate nohighlight">\(\delta^*(q_0,w)\)</span> corresponds to <span class="math notranslate nohighlight">\(\partial^*(p_0,w)\)</span> for all
<span class="math notranslate nohighlight">\(w\in\Sigma^*\)</span>. We use induction on the length of <span class="math notranslate nohighlight">\(w\)</span>.</p>
<p><strong>Base case:</strong> Suppose <span class="math notranslate nohighlight">\(w\)</span> has length 0. The only string <span class="math notranslate nohighlight">\(w\)</span> with length 0 is
<span class="math notranslate nohighlight">\(\varepsilon\)</span>, so we want to show that
<span class="math notranslate nohighlight">\(\delta^*(q_0,\varepsilon)\)</span> corresponds to <span class="math notranslate nohighlight">\(\partial^*(p_0,\varepsilon)\)</span>. Well,
<span class="math notranslate nohighlight">\(\delta^*(q_0, \varepsilon) = q_0\)</span>, since in a DFA, <span class="math notranslate nohighlight">\(\delta^*(q, \varepsilon) = q\)</span> for any
state~<span class="math notranslate nohighlight">\(q\)</span>. We explicitly made <span class="math notranslate nohighlight">\(q_0\)</span> correspond to
<span class="math notranslate nohighlight">\(\partial^*(p_0,\varepsilon)\)</span>, and so the property holds for <span class="math notranslate nohighlight">\(w\)</span> with length 0.</p>
<p><strong>Inductive case:</strong> Assume that the desired property holds for some number <span class="math notranslate nohighlight">\(n\)</span>,
<em>i.e.</em>, that <span class="math notranslate nohighlight">\(\delta^*(q_0,x)\)</span> corresponds to <span class="math notranslate nohighlight">\(\partial^*(p_0,x)\)</span> for all <span class="math notranslate nohighlight">\(x\)</span> with
length <span class="math notranslate nohighlight">\(n\)</span>. Look at an arbitrary string <span class="math notranslate nohighlight">\(w\)</span> with length <span class="math notranslate nohighlight">\(n+1\)</span>.
We want to show that <span class="math notranslate nohighlight">\(\delta^*(q_0,w)\)</span> corresponds to <span class="math notranslate nohighlight">\(\partial^*(p_0,w)\)</span>.
Well, the string <span class="math notranslate nohighlight">\(w\)</span>
must look like <span class="math notranslate nohighlight">\(xa\)</span> for some string <span class="math notranslate nohighlight">\(x\)</span> (whose length is <span class="math notranslate nohighlight">\(n\)</span>) and some symbol
<span class="math notranslate nohighlight">\(a\)</span>. By our inductive hypothesis, we know
<span class="math notranslate nohighlight">\(\delta^*(q_0,x)\)</span> corresponds to <span class="math notranslate nohighlight">\(\partial^*(p_0,x)\)</span>. We know <span class="math notranslate nohighlight">\(\partial^*(p_0,x)\)</span> is a
set of <span class="math notranslate nohighlight">\(N\)</span>’s states, say
<span class="math notranslate nohighlight">\(\partial^*(p_0,x) = \{p_1, \ldots, p_n\}\)</span>.</p>
<p>At this point, our subsequent reasoning might be a bit clearer if we give
explicit names
to <span class="math notranslate nohighlight">\(\delta^*(q_0,w)\)</span> (the state <span class="math notranslate nohighlight">\(D\)</span>
reaches on input <span class="math notranslate nohighlight">\(w\)</span>) and <span class="math notranslate nohighlight">\(\delta^*(q_0,x)\)</span> (the state <span class="math notranslate nohighlight">\(D\)</span>
reaches on input <span class="math notranslate nohighlight">\(x\)</span>). Let <span class="math notranslate nohighlight">\(q_w = \delta^*(q_0, w)\)</span>, and let
<span class="math notranslate nohighlight">\(q_x = \delta^*(q_0,x)\)</span>. We know, because <span class="math notranslate nohighlight">\(w=xa\)</span>, there must be an
<span class="math notranslate nohighlight">\(a\)</span>-transition from <span class="math notranslate nohighlight">\(q_x\)</span> to <span class="math notranslate nohighlight">\(q_w\)</span>. Look at how we added transitions to
<span class="math notranslate nohighlight">\(\delta\)</span>: the fact that there is an <span class="math notranslate nohighlight">\(a\)</span>-transition from <span class="math notranslate nohighlight">\(q_x\)</span> to <span class="math notranslate nohighlight">\(q_w\)</span> means that
<span class="math notranslate nohighlight">\(q_w\)</span> corresponds to the set <span class="math notranslate nohighlight">\(\partial^*(p_1,a)
\cup \ldots \cup \partial^*(p_n,a)\)</span> of <span class="math notranslate nohighlight">\(N\)</span>’s states. By our preliminary observation,
<span class="math notranslate nohighlight">\(\partial^*(p_1,a)
\cup \ldots \cup \partial^*(p_n,a)\)</span> is just <span class="math notranslate nohighlight">\(\partial^*(p_0,w)\)</span>. So <span class="math notranslate nohighlight">\(q_w\)</span> (or
<span class="math notranslate nohighlight">\(\delta^*(q_0,w)\)</span>) corresponds to <span class="math notranslate nohighlight">\(\partial^*(p_0,w)\)</span>, which is what we wanted to
prove. Since <span class="math notranslate nohighlight">\(w\)</span> was an arbitrary string of length <span class="math notranslate nohighlight">\(n+1\)</span>, we have shown that
the property holds for <span class="math notranslate nohighlight">\(n+1\)</span>.</p>
<p>Altogether, we have shown by induction that <span class="math notranslate nohighlight">\(\delta^*(q_0,w)\)</span> corresponds to
<span class="math notranslate nohighlight">\(\partial^*(p_0,w)\)</span> for all
<span class="math notranslate nohighlight">\(w\in\Sigma^*\)</span>. As indicated at the very beginning of this proof, that is enough to
prove that <span class="math notranslate nohighlight">\(L(D)= L(N)\)</span>. So for any NFA <span class="math notranslate nohighlight">\(N\)</span>, we can find a DFA <span class="math notranslate nohighlight">\(D\)</span> that accepts
the same language.</p>
</div></blockquote>
<hr class="docutils" />
<p><strong>Example:</strong>
Consider the NFA shown below.</p>
<p>&lt;img src={useBaseUrl(‘img/fsa9.png’)}
alt=”Example NFA” className=”centered-figure” /&gt;</p>
<p>We start by looking at <span class="math notranslate nohighlight">\(\partial^*(p_0, \varepsilon)\)</span>, and then add transitions and
states as described above.</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\partial^*(p_0, \varepsilon) = \{p_0\}\)</span> so <span class="math notranslate nohighlight">\(q_0 = \{p_0\}\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(\delta(q_0,a)\)</span> will be <span class="math notranslate nohighlight">\(\partial^*(p_0,a)\)</span>, which is <span class="math notranslate nohighlight">\(\{p_0\}\)</span>,
so <span class="math notranslate nohighlight">\(\delta(q_0,a) = q_0\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(\delta(q_0,b)\)</span> will be <span class="math notranslate nohighlight">\(\partial^*(p_0,b)\)</span>, which is <span class="math notranslate nohighlight">\(\{p_0, p_1\}\)</span>,
so we need to add a new state
<span class="math notranslate nohighlight">\(q_1 = \{p_0, p_1\}\)</span> to the DFA; and add <span class="math notranslate nohighlight">\(\delta(q_0,b) = q_1\)</span> to the DFA’s
transition function.</p></li>
<li><p><span class="math notranslate nohighlight">\(\delta(q_1,a)\)</span> will be <span class="math notranslate nohighlight">\(\partial^*(p_0,a)\)</span> unioned with <span class="math notranslate nohighlight">\(\partial^*(p_1,a)\)</span> since
<span class="math notranslate nohighlight">\(q_1 = \{p_0, p_1\}\)</span>. Since <span class="math notranslate nohighlight">\(\partial^*(p_0,a) \cup \partial^*(p_1,a) = \{p_0\} \cup
\{p_2\} = \{p_0,p_2\}\)</span>, we need to add a new state <span class="math notranslate nohighlight">\(q_2 = \{p_0, p_2\}\)</span> to the
DFA, and a transition <span class="math notranslate nohighlight">\(\delta(q_1,a) = q_2\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(\delta(q_1,b)\)</span> will be <span class="math notranslate nohighlight">\(\partial^*(p_0,b)\)</span> unioned with <span class="math notranslate nohighlight">\(\partial^*(p_1,b)\)</span>, which
gives <span class="math notranslate nohighlight">\(\{p_0, p_1\} \cup \{p_2\}\)</span>, which again gives us a new state <span class="math notranslate nohighlight">\(q_3\)</span> to add to
the DFA, together with the transition <span class="math notranslate nohighlight">\(\delta(q_1,b) = q_3\)</span>.
\end{itemize}</p></li>
</ul>
<p>At this point, our partially-constructed DFA looks as shown below:</p>
<p>&lt;img src={useBaseUrl(‘img/fsa10.png’)}
alt=”Example DFA” className=”centered-figure” /&gt;</p>
<p>The construction continues as long as there are new states being added, and new
transitions from those states that have to be computed.
The final DFA is shown below.</p>
<p>&lt;img src={useBaseUrl(‘img/fsa11.png’)}
alt=”Example DFA” className=”centered-figure” /&gt;</p>
</div>
<hr class="docutils" />
<div class="section" id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h2>
<ol class="simple">
<li><p>What language does the NFA in the above accept?</p></li>
<li><p>Give a DFA that accepts the language accepted by the
following NFA.</p></li>
</ol>
<p>&lt;img src={useBaseUrl(‘img/fsa3ex.png’)}
alt=”Example DFA” className=”centered-figure” /&gt;</p>
<ol class="simple">
<li><p>Give a DFA that accepts the language accepted by the following NFA.
(Be sure to note that, for example, it is possible to reach both <span class="math notranslate nohighlight">\(q_1\)</span> and
<span class="math notranslate nohighlight">\(q_3\)</span> from <span class="math notranslate nohighlight">\(q_0\)</span> on consumption of an <span class="math notranslate nohighlight">\(a\)</span>, because of the
<span class="math notranslate nohighlight">\(\varepsilon\)</span>-transition.)</p></li>
</ol>
<p>&lt;img src={useBaseUrl(‘img/fsa4ex.png’)}
alt=”Example DFA” className=”centered-figure” /&gt;</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./lang"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="fsa.html" title="previous page">Finite-State Automata</a>
    <a class='right-next' id="next-link" href="fsareg.html" title="next page">Finite-State Automata and Regular Languages</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Brian T. Howard, based in part on material by Carol Critchlow and David Eck<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    <script src="../_static/js/index.js"></script>
    
  </body>
</html>