

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Parsing and Parse Trees &#8212; FoCSipedia</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" integrity="sha384-KA6wR/X5RY4zFAHpv/CnoG2UW1uogYfdnP67Uv7eULvTveboZJg0qUpmJZb5VqzN" crossorigin="anonymous">
    <link href="../_static/css/index.css" rel="stylesheet">
    <link rel="stylesheet" href="../_static/sphinx-book-theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/jupyter-sphinx.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/sphinx-book-theme.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/mystnb.js"></script>
    <script src="../_static/sphinx-book-theme.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Pushdown Automata" href="pda.html" />
    <link rel="prev" title="Backus-Naur Form" href="bnf.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="docsearch:language" content="en">



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../index.html">
  
  <img src="../_static/SmartFoxLogo.jpeg" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">FoCSipedia</h1>
  
</a>
</div>

<form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>

<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <ul class="current nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../attribution.html">
   Attribution
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../topics.html">
   Topics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../overview.html">
   Overview of Topics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../logic/index.html">
   Logic
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sets/index.html">
   Sets
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fp/index.html">
   Functional Programming
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../ds/index.html">
   Data Structures
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="reference internal" href="index.html">
   Formal Languages
  </a>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="languages.html">
     Languages
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="regexp.html">
     Regular Expressions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="regexpapp.html">
     Applications of Regular Expressions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="fsa.html">
     Finite-State Automata
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="nfa.html">
     Nondeterministic Finite-State Automata
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="fsareg.html">
     Finite-State Automata and Regular Languages
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="cfg.html">
     Context-Free Grammars
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="bnf.html">
     Backus-Naur Form
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Parsing and Parse Trees
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="pda.html">
     Pushdown Automata
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="tm.html">
     General Grammars and Turing Machines
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="computability.html">
     Computability
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="halting.html">
     The Halting Problem
    </a>
   </li>
  </ul>
 </li>
</ul>

</nav>

 <!-- To handle the deprecated key -->

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        <div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    
    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/lang/parsing.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
    
</div>
        <!-- Source interaction buttons -->


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> On this page
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#exercises">
   Exercises
  </a>
 </li>
</ul>

        </nav>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="parsing-and-parse-trees">
<h1>Parsing and Parse Trees<a class="headerlink" href="#parsing-and-parse-trees" title="Permalink to this headline">Â¶</a></h1>
<p>(Content adapted from Critchlow &amp; Eck)</p>
<p>Suppose that <span class="math notranslate nohighlight">\(G\)</span> is a grammar for the language <span class="math notranslate nohighlight">\(L\)</span>. That is,
<span class="math notranslate nohighlight">\(L=L(G)\)</span>. The grammar <span class="math notranslate nohighlight">\(G\)</span> can be used to generate strings in
the language <span class="math notranslate nohighlight">\(L\)</span>. In practice, though, we often start with a string
which might or might not be in <span class="math notranslate nohighlight">\(L\)</span>, and the problem is
to determine whether the string is in the language and, if so,
how it can be generated by <span class="math notranslate nohighlight">\(G\)</span>. The goal is to find a derivation
of the string, using the production rules of the grammar, or to
show that no such derivation exists. This is known as <strong>parsing</strong>
the string. When the string is a computer program or a sentence
in a natural language, parsing the string is an essential step
in determining its meaning.</p>
<p>As an example that we will use throughout
this section, consider the language that consists of arithmetic
expressions containing parentheses, the binary operators <span class="math notranslate nohighlight">\(+\)</span> and <span class="math notranslate nohighlight">\(*\)</span>,
and the variables <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span>, and <span class="math notranslate nohighlight">\(z\)</span>. Strings in this language
include <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(x+y*z\)</span>, and <span class="math notranslate nohighlight">\(((x+y)*y)+z*z\)</span>. Here is a context-free
grammar that generates this language:
<span class="math notranslate nohighlight">\($
\begin{aligned}
  E&amp;\longrightarrow E+E\\
  E&amp;\longrightarrow E*E\\
  E&amp;\longrightarrow (E)\\
  E&amp;\longrightarrow x\\
  E&amp;\longrightarrow y\\
  E&amp;\longrightarrow z
\end{aligned}
$\)</span>
Call the grammar described by these production rules <span class="math notranslate nohighlight">\(G_1\)</span>.
The grammar <span class="math notranslate nohighlight">\(G_1\)</span> says that <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span>, and <span class="math notranslate nohighlight">\(z\)</span> are expressions, and that
you can make new expressions by adding two expressions, by multiplying
two expressions, and by enclosing an expression in parentheses.
(Later, weâll look at other grammars for the same languageâones that
turn out to have certain advantages over <span class="math notranslate nohighlight">\(G_1\)</span>.)</p>
<p>Consider the string <span class="math notranslate nohighlight">\(x+y*z\)</span>. To show that this string is in the
language <span class="math notranslate nohighlight">\(L(G_1)\)</span>, we can exhibit a derivation of the string
from the start symbol <span class="math notranslate nohighlight">\(E\)</span>. For example:
<span class="math notranslate nohighlight">\($
\begin{aligned}
  E &amp; \Longrightarrow E+E\\
   &amp; \Longrightarrow E+E*E\\
   &amp; \Longrightarrow E+y*E\\
   &amp; \Longrightarrow x+y*E\\
   &amp; \Longrightarrow x+y*z
\end{aligned}
$\)</span>
This derivation shows that the string <span class="math notranslate nohighlight">\(x+y*z\)</span> is in fact in <span class="math notranslate nohighlight">\(L(G_1)\)</span>.
Now, this string has many other derivations. At each step in the
derivation, there can be a lot of freedom about which rule in the
grammar to apply next. Some of this freedom is clearly not very
meaningful. When faced with the string <span class="math notranslate nohighlight">\(E+E*E\)</span> in the above example,
the order in which we replace the <span class="math notranslate nohighlight">\(E\)</span>âs with the variables <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span>,
and <span class="math notranslate nohighlight">\(z\)</span> doesnât much matter. To cut out some of this meaningless
freedom, we could agree that in each step of a derivation, the
non-terminal symbol that is replaced is the leftmost non-terminal
symbol in the string. A derivation in which this is true is
called a <strong>left derivation</strong>. The following left derivation
of the string <span class="math notranslate nohighlight">\(x+y*z\)</span> uses the same production rules as the previous
derivation, but it applies them in a different order:
<span class="math notranslate nohighlight">\($
\begin{aligned}
  E &amp; \Longrightarrow E+E\\
   &amp; \Longrightarrow x+E\\
   &amp; \Longrightarrow x+E*E\\
   &amp; \Longrightarrow x+y*E\\
   &amp; \Longrightarrow x+y*z
\end{aligned}
$\)</span>
It shouldnât be too hard to convince yourself that any string that
has a derivation has a left derivation (which can be obtained
by changing the order in which production rules are applied).</p>
<p>We have seen that the same string might have several different derivations.
We might ask whether it can have several different left derivations.
The answer is that it depends on the grammar. A context-free
grammar <span class="math notranslate nohighlight">\(G\)</span> is said to be <strong>ambiguous</strong>
if there is a string <span class="math notranslate nohighlight">\(w\in L(G)\)</span> such that <span class="math notranslate nohighlight">\(w\)</span> has more than one
left derivation according to the grammar <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>Our example grammar <span class="math notranslate nohighlight">\(G_1\)</span> is ambiguous. In fact, in addition to the
left derivation given above, the string <span class="math notranslate nohighlight">\(x+y*z\)</span> has the alternative
left derivation
<span class="math notranslate nohighlight">\($
\begin{aligned}
  E &amp; \Longrightarrow E*E\\
   &amp; \Longrightarrow E+E*E\\
   &amp; \Longrightarrow x+E*E\\
   &amp; \Longrightarrow x+y*E\\
   &amp; \Longrightarrow x+y*z
\end{aligned}
$\)</span>
In this left derivation of the string <span class="math notranslate nohighlight">\(x+y*z\)</span>, the first production
rule that is applied is <span class="math notranslate nohighlight">\(E\longrightarrow E*E\)</span>. The first <span class="math notranslate nohighlight">\(E\)</span> on the right-hand
side eventually yields â<span class="math notranslate nohighlight">\(x+y\)</span>â while the second yields â<span class="math notranslate nohighlight">\(z\)</span>â.
In the previous left derivation, the first production rule that was
applied was <span class="math notranslate nohighlight">\(E\longrightarrow E+E\)</span>, with the first <span class="math notranslate nohighlight">\(E\)</span> on the right yielding
â<span class="math notranslate nohighlight">\(x\)</span>â and the second <span class="math notranslate nohighlight">\(E\)</span> yielding â<span class="math notranslate nohighlight">\(y*z\)</span>â. If we think in terms
of arithmetic expressions, the two left derivations lead to
two different interpretations of the expression <span class="math notranslate nohighlight">\(x+y*z\)</span>. In one
interpretation, the <span class="math notranslate nohighlight">\(x+y\)</span> is a unit that is multiplied by <span class="math notranslate nohighlight">\(z\)</span>.
In the second interpretation, the <span class="math notranslate nohighlight">\(y*z\)</span> is a unit that is added to <span class="math notranslate nohighlight">\(x\)</span>.
The second interpretation is the one that is correct according to
the usual rules of arithmetic. However, the grammar allows either
interpretation. The ambiguity of the grammar allows the string to
be parsed in two essentially different ways, and only one of the
parsings is consistent with the meaning of the string. Of course,
the grammar for English is also ambiguous. In a famous example,
itâs impossible to tell whether a âpretty girlsâ campâ is
meant to describe a pretty camp for girls or a camp for pretty girls.[^A
related example with many more interpretations is âpretty little girlsâ school.â]</p>
<p>When dealing with artificial languages such as programming languages,
itâs better to avoid ambiguity.
The grammar <span class="math notranslate nohighlight">\(G_1\)</span> is perfectly correct in that it generates the correct
set of strings, but in a practical situation where we are interested
in the meaning of the strings, <span class="math notranslate nohighlight">\(G_1\)</span> is not the right grammar for
the job. There are other grammars that generate the same language
as <span class="math notranslate nohighlight">\(G_1\)</span>. Some of them are unambiguous grammars that better reflect
the meaning of the strings in the language. For example, the
language <span class="math notranslate nohighlight">\(L(G_1)\)</span> is also generated by the BNF grammar
<span class="math notranslate nohighlight">\($
\begin{aligned}
  E\ &amp;::=\ T\ [\ +\ T\ ]\ldots\\
  T\ &amp;::=\ F\ [\ *\ F\ ]\ldots\\
  F\ &amp;::=\ \textrm{``(''}\ E\ \textrm{``)''}\ |\ x\ |\ y\ |\ z
\end{aligned} 
$\)</span>
This grammar can be translated into a standard context-free grammar, which
I will call <span class="math notranslate nohighlight">\(G_2\)</span>:
<span class="math notranslate nohighlight">\($
\begin{aligned}
  E &amp;\longrightarrow TA\\
  A &amp;\longrightarrow +TA\\
  A &amp;\longrightarrow  \varepsilon\\
  T &amp;\longrightarrow FB\\
  B &amp;\longrightarrow *FB\\
  B &amp;\longrightarrow  \varepsilon\\
  F &amp;\longrightarrow (E)\\
  F &amp;\longrightarrow x\\
  F &amp;\longrightarrow y\\
  F &amp;\longrightarrow z
\end{aligned}
$\)</span>
The language generated by
<span class="math notranslate nohighlight">\(G_2\)</span> consists of all legal arithmetic expressions made up of
parentheses, the operators <span class="math notranslate nohighlight">\(+\)</span> and <span class="math notranslate nohighlight">\(-\)</span>, and the variables <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span>,
and <span class="math notranslate nohighlight">\(z\)</span>. That is, <span class="math notranslate nohighlight">\(L(G_2)=L(G_1)\)</span>. However, <span class="math notranslate nohighlight">\(G_2\)</span> is an unambiguous
grammar. Consider, for example, the string <span class="math notranslate nohighlight">\(x+y*z\)</span>. Using the
grammar <span class="math notranslate nohighlight">\(G_2\)</span>, the only left derivation for this string is:
<span class="math notranslate nohighlight">\($
\begin{aligned}
  E &amp; \Longrightarrow TA\\
   &amp; \Longrightarrow FBA\\
   &amp; \Longrightarrow xBA\\
   &amp; \Longrightarrow xA\\
   &amp; \Longrightarrow x+TA\\
   &amp; \Longrightarrow x+FBA\\
   &amp; \Longrightarrow x+yBA\\
   &amp; \Longrightarrow x+y*FBA\\
   &amp; \Longrightarrow x+y*zBA\\
   &amp; \Longrightarrow x+y*zA\\
   &amp; \Longrightarrow x+y*z
\end{aligned}
$\)</span>
There is no choice about the first step in this derivation, since the
only production rule with <span class="math notranslate nohighlight">\(E\)</span> on the left-hand side is <span class="math notranslate nohighlight">\(E\longrightarrow TA\)</span>.
Similarly, the second step is forced by the fact that there is only
one rule for rewriting a <span class="math notranslate nohighlight">\(T\)</span>. In the third step, we must replace
an <span class="math notranslate nohighlight">\(F\)</span>. There are four ways to rewrite <span class="math notranslate nohighlight">\(F\)</span>, but only one way to produce
the <span class="math notranslate nohighlight">\(x\)</span> that begins the string <span class="math notranslate nohighlight">\(x+y*z\)</span>, so we apply the rule <span class="math notranslate nohighlight">\(F\longrightarrow x\)</span>.
Now, we have to decide what to do with the <span class="math notranslate nohighlight">\(B\)</span> in <span class="math notranslate nohighlight">\(xBA\)</span>. There are two rules
for rewriting <span class="math notranslate nohighlight">\(B\)</span>, <span class="math notranslate nohighlight">\(B\longrightarrow *FB\)</span> and <span class="math notranslate nohighlight">\(B\longrightarrow \varepsilon\)</span>. However,
the first of these rules introduces a terminal, <span class="math notranslate nohighlight">\(*\)</span>, which does not
match the string we are trying to parse. So, the only choice is to
apply the production rule <span class="math notranslate nohighlight">\(B\longrightarrow \varepsilon\)</span>. In the next step
of the derivation, we must apply the rule <span class="math notranslate nohighlight">\(A\longrightarrow +TA\)</span> in order to
account for the <span class="math notranslate nohighlight">\(+\)</span> in the string <span class="math notranslate nohighlight">\(x+y*z\)</span>. Similarly, each of the
remaining steps in the left derivation is forced.</p>
<hr class="docutils" />
<p>The fact that <span class="math notranslate nohighlight">\(G_2\)</span> is an unambiguous grammar means that at each
step in a left derivation for a string <span class="math notranslate nohighlight">\(w\)</span>, there is only one production
rule that can be applied which will lead ultimately to a correct
derivation of <span class="math notranslate nohighlight">\(w\)</span>. However, <span class="math notranslate nohighlight">\(G_2\)</span> actually satisfies a much stronger
property: at each step in the left derivation of <span class="math notranslate nohighlight">\(w\)</span>, we can tell which
production rule has to be applied by looking ahead at the next
symbol in <span class="math notranslate nohighlight">\(w\)</span>. We say that <span class="math notranslate nohighlight">\(G_2\)</span> is an <strong>LL(1) grammar</strong>.
(This notation means that we can read a string from <strong>L</strong>eft to
right and construct a <strong>L</strong>eft derivation of the string by
looking ahead at most <strong>1</strong> character in the string.)
Given an LL(1) grammar for a language, it is fairly straightforward
to write a computer program that can parse strings in that language.
If the language is a programming language, then parsing is one of the
essential steps in translating a computer program into machine language.
LL(1) grammars and parsing programs that use them are often studied
in courses in programming languages and the theory of compilers. For more
details on how to turn an LL(1) grammar into code, see the section on
<a class="reference internal" href="../fp/parser-comb.html"><span class="doc std std-doc">recursive descent and parser combinators</span></a>.</p>
<p>Not every unambiguous context-free grammar is an LL(1) grammar. Consider, for
example, the following grammar, which I will call <span class="math notranslate nohighlight">\(G_3\)</span>:
<span class="math notranslate nohighlight">\($
\begin{aligned}
  E &amp;\longrightarrow E + T\\
  E &amp;\longrightarrow T\\
  T &amp;\longrightarrow T*F\\
  T &amp;\longrightarrow F\\
  F &amp;\longrightarrow (E)\\
  F &amp;\longrightarrow x\\
  F &amp;\longrightarrow y\\
  F &amp;\longrightarrow z
\end{aligned}
$\)</span>
This grammar generates the same language as <span class="math notranslate nohighlight">\(G_1\)</span> and <span class="math notranslate nohighlight">\(G_2\)</span>,
and it is unambiguous. However, it is not possible to construct
a left derivation for a string according to the grammar <span class="math notranslate nohighlight">\(G_3\)</span> by
looking ahead one character in the string at each step.
The first step in any left derivation must be either
<span class="math notranslate nohighlight">\(E \Longrightarrow E+T\)</span> or <span class="math notranslate nohighlight">\(E \Longrightarrow T\)</span>. But how can we decide which of
these is the correct first step?
Consider the strings <span class="math notranslate nohighlight">\((x+y)*z\)</span> and <span class="math notranslate nohighlight">\((x+y)*z+z*x\)</span>, which are both
in the language <span class="math notranslate nohighlight">\(L(G_3)\)</span>. For the string <span class="math notranslate nohighlight">\((x+y)*z\)</span>, the
first step in a left derivation must be <span class="math notranslate nohighlight">\(E \Longrightarrow T\)</span>, while
the first step in a left derivation of <span class="math notranslate nohighlight">\((x+y)*z+z*x\)</span> must be
<span class="math notranslate nohighlight">\(E \Longrightarrow E+T\)</span>. However, the first seven characters of the strings
are identical, so clearly looking even seven characters ahead is not
enough to tell us which production rule to apply. In fact,
similar examples show that looking ahead any given finite number of
characters is not enough.</p>
<p>However, there is an alternative parsing procedure that will work
for <span class="math notranslate nohighlight">\(G_3\)</span>. This alternative method of parsing a string produces
a <strong>right derivation</strong> of the string, that is, a derivation in
which at each step, the non-terminal symbol that is replaced is
the rightmost non-terminal symbol in the string. Here, for example,
is a right derivation of the string <span class="math notranslate nohighlight">\((x+y)*z\)</span> according to the
grammar <span class="math notranslate nohighlight">\(G_3\)</span>:
<span class="math notranslate nohighlight">\($
\begin{aligned}
 E &amp; \Longrightarrow T\\
  &amp; \Longrightarrow T*F\\
  &amp; \Longrightarrow T*z\\
  &amp; \Longrightarrow F*z\\
  &amp; \Longrightarrow (E)*z\\
  &amp; \Longrightarrow (E+T)*z\\
  &amp; \Longrightarrow (E+F)*z\\
  &amp; \Longrightarrow (E+y)*z\\
  &amp; \Longrightarrow (T+y)*z\\
  &amp; \Longrightarrow (F+y)*z\\
  &amp; \Longrightarrow (x+y)*z
\end{aligned}
$\)</span>
The parsing method that produces this right derivation produces
it from âbottom to top.â That is, it begins with
the string <span class="math notranslate nohighlight">\((x+y)*z\)</span> and works backward to the start symbol <span class="math notranslate nohighlight">\(E\)</span>,
generating the steps of the right derivation in reverse order.
The method works because <span class="math notranslate nohighlight">\(G_3\)</span> is what is called an
<strong>LR(1) grammar</strong>. That is, roughly, it is possible to read
a string from <strong>L</strong>eft to right and produce a <strong>R</strong>ight
derivation of the string, by looking ahead at most <strong>1</strong> symbol at
each step. Although LL(1) grammars are easier for people to work
with, LR(1) grammars turn out to be very suitable for machine
processing, and they are used as the basis for the parsing
process in many compilers.</p>
<p>LR(1) parsing uses a <strong>shift/reduce</strong> algorithm. Imagine a
cursor or current position that moves through the string that
is being parsed. We can visualize the cursor as a vertical
bar, so for the string <span class="math notranslate nohighlight">\((x+y)*z\)</span>, we start with the
configuration <span class="math notranslate nohighlight">\(|(x+y)*z\)</span>. A <em>shift</em> operation simply
moves the cursor one symbol to the right. For example,
a shift operation would convert <span class="math notranslate nohighlight">\(|(x+y)*z\)</span> to <span class="math notranslate nohighlight">\((|x+y)*z\)</span>,
and a second shift operation would convert that to
<span class="math notranslate nohighlight">\((x|+y)*z\)</span>. In a <em>reduce</em>
operation, one or more symbols immediately to the left of
the cursor are recognized as the right-hand side of one of
the production rules in the grammar. These symbols are removed
and replaced by the left-hand side of the production rule.
For example, in the configuration <span class="math notranslate nohighlight">\((x|+y)*z\)</span>, the <span class="math notranslate nohighlight">\(x\)</span> to the left
of the cursor is the right-hand side of the production rule
<span class="math notranslate nohighlight">\(F\longrightarrow x\)</span>, so we can apply a reduce operation and replace
the <span class="math notranslate nohighlight">\(x\)</span> with <span class="math notranslate nohighlight">\(F\)</span>, giving <span class="math notranslate nohighlight">\((F|+y)*z\)</span>. This first reduce operation
corresponds to the last step in the right derivation of the
string, <span class="math notranslate nohighlight">\((F+y)*z \Longrightarrow (x+y)*z\)</span>. Now the <span class="math notranslate nohighlight">\(F\)</span> can be recognized
as the right-hand side of the production rule <span class="math notranslate nohighlight">\(T\longrightarrow F\)</span>,
so we can replace the <span class="math notranslate nohighlight">\(F\)</span> with <span class="math notranslate nohighlight">\(T\)</span>, giving <span class="math notranslate nohighlight">\((T|+y)*z\)</span>.
This corresponds to the next-to-last step in the right
derivation, <span class="math notranslate nohighlight">\((T+y)*z \Longrightarrow (F+y)*z\)</span>.</p>
<p>At this point, we have the configuration <span class="math notranslate nohighlight">\((T|+y)*z\)</span>. The <span class="math notranslate nohighlight">\(T\)</span>
could be the right-hand side of the production rule <span class="math notranslate nohighlight">\(E\longrightarrow T\)</span>.
However, it could also conceivably come from the rule <span class="math notranslate nohighlight">\(T\longrightarrow T*F\)</span>.
How do we know whether to reduce the <span class="math notranslate nohighlight">\(T\)</span> to <span class="math notranslate nohighlight">\(E\)</span> at this point or to
wait for a <span class="math notranslate nohighlight">\(*F\)</span> to come along so that we can reduce <span class="math notranslate nohighlight">\(T*F\,\)</span>?
We can decide by looking ahead at the next character after the
cursor. Since this character is a <span class="math notranslate nohighlight">\(+\)</span> rather than a <span class="math notranslate nohighlight">\(*\)</span>,
we should choose the reduce operation that replaces <span class="math notranslate nohighlight">\(T\)</span> with <span class="math notranslate nohighlight">\(E\)</span>,
giving <span class="math notranslate nohighlight">\((E|+y)*z\)</span>. What makes <span class="math notranslate nohighlight">\(G_3\)</span> an LR(1) grammar is the fact
that we can always decide what operation to apply by looking
ahead at most one symbol past the cursor.</p>
<p>After a few more shift and reduce operations, the configuration
becomes <span class="math notranslate nohighlight">\((E)|*z\)</span>, which we can reduce to <span class="math notranslate nohighlight">\(T|*z\)</span> by applying the
production rules <span class="math notranslate nohighlight">\(F\longrightarrow (E)\)</span> and <span class="math notranslate nohighlight">\(T\longrightarrow F\)</span>.
Now, faced with <span class="math notranslate nohighlight">\(T|*z\)</span>, we must once again decide between
a shift operation and a reduce operation that applies the
rule <span class="math notranslate nohighlight">\(E\longrightarrow T\)</span>. In this case, since the next character is
a <span class="math notranslate nohighlight">\(*\)</span> rather than a <span class="math notranslate nohighlight">\(+\)</span>, we apply the shift operation, giving
<span class="math notranslate nohighlight">\(T*|z\)</span>. From there we get, in succession, <span class="math notranslate nohighlight">\(T*z|\)</span>,
<span class="math notranslate nohighlight">\(T*F|\)</span>, <span class="math notranslate nohighlight">\(T|\)</span>, and finally <span class="math notranslate nohighlight">\(E|\)</span>. At this point, we have reduced
the entire string <span class="math notranslate nohighlight">\((x+y)*z\)</span> to the start symbol of the grammar.
The very last step, the reduction of <span class="math notranslate nohighlight">\(T\)</span> to <span class="math notranslate nohighlight">\(E\)</span> corresponds to
the first step of the right derivation, <span class="math notranslate nohighlight">\(E \Longrightarrow T\)</span>.</p>
<p>In summary, LR(1) parsing transforms a string into the
start symbol of the grammar by a sequence of shift and
reduce operations. Each reduce operation corresponds to a
step in a right derivation of the string, and these steps
are generated in reverse order. Because the steps in the
derivation are generated from âbottom to top,â LR(1)
parsing is a type of <strong>bottom-up parsing</strong>. LL(1) parsing,
on the other hand, generates the steps in a left derivation
from âtop to bottomâ and so is a type of <strong>top-down parsing</strong>.</p>
<hr class="docutils" />
<p>Although the language generated by a context-free grammar
is defined in terms of derivations, there is another way of
presenting the generation of a string that is often more useful.
A <strong>parse tree</strong> displays the generation of a string from
the start symbol of a grammar as a two dimensional diagram.
Here are two parse trees that show two derivations of the
string x+y*z according to the grammar <span class="math notranslate nohighlight">\(G_1\)</span>, which was given
at the beginning of this section:</p>
<p>&lt;img src={useBaseUrl(âimg/fig-5-1.pngâ)}
alt=âSample parse treesâ className=âcentered-figureâ /&gt;</p>
<p>A parse tree is made up of terminal and non-terminal symbols,
connected by lines. The start symbol is at the top, or âroot,â of
the tree. Terminal symbols are at the lowest level, or âleaves,â of
the tree. (For some reason, computer scientists traditionally
draw trees with leaves at the bottom and root at the top.)
A production rule <span class="math notranslate nohighlight">\(A\longrightarrow w\)</span> is represented
in a parse tree by the symbol <span class="math notranslate nohighlight">\(A\)</span> lying above all the symbols in <span class="math notranslate nohighlight">\(w\)</span>,
with a line joining <span class="math notranslate nohighlight">\(A\)</span> to each of the symbols in <span class="math notranslate nohighlight">\(w\)</span>. For
example, in the left parse tree above, the root,
<span class="math notranslate nohighlight">\(E\)</span>, is connected to the symbols <span class="math notranslate nohighlight">\(E\)</span>, <span class="math notranslate nohighlight">\(+\)</span>, and <span class="math notranslate nohighlight">\(E\)</span>, and this
corresponds to an application of the production rule
<span class="math notranslate nohighlight">\(E\longrightarrow E+E\)</span>.</p>
<p>It is customary to draw a parse tree with the string of non-terminals
in a row across the bottom, and with the rest of the tree built on
top of that base. Thus, the two parse trees shown above might
be drawn as:</p>
<p>&lt;img src={useBaseUrl(âimg/fig-5-2.pngâ)}
alt=âSample parse trees, adjustedâ className=âcentered-figureâ /&gt;</p>
<p>Given any derivation of a string, it is possible to construct
a parse tree that shows each of the steps in that derivation.
However, two different derivations can give rise to the same
parse tree, since the parse tree does not show the order in
which production rules are applied. For example, the parse
tree on the left, above, does not show whether the production
rule <span class="math notranslate nohighlight">\(E\longrightarrow x\)</span> is applied before or after the production
rule <span class="math notranslate nohighlight">\(E\longrightarrow y\)</span>. However, if we restrict our attention to left
derivations, then we find that each parse tree corresponds to
a unique left derivation and <em>vice versa</em>. I will state this
fact as a theorem, without proof. A similar result holds for
right derivations.</p>
<blockquote>
<div><p><strong>Theorem:</strong>
Let <span class="math notranslate nohighlight">\(G\)</span> be a context-free grammar. There is a one-to-one correspondence
between parse trees and left derivations based on the grammar <span class="math notranslate nohighlight">\(G\)</span>.</p>
</div></blockquote>
<p>Based on this theorem, we can say that a context-free grammar <span class="math notranslate nohighlight">\(G\)</span>
is ambiguous if and only if there is a string <span class="math notranslate nohighlight">\(w\in L(G)\)</span> which has
two parse trees.</p>
<div class="section" id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">Â¶</a></h2>
<ol>
<li><p>Show that each of the following grammars is ambiguous by finding
a string that has two left derivations according to the grammar:</p>
<p>a)
<span class="math notranslate nohighlight">\($
\begin{aligned}
S&amp;\longrightarrow SS\\
S&amp;\longrightarrow aSb\\
S&amp;\longrightarrow bSa\\
S&amp;\longrightarrow \varepsilon
\end{aligned}
$\)</span></p>
<p>b)
<span class="math notranslate nohighlight">\($
\begin{aligned}
S&amp;\longrightarrow ASb\\
S&amp;\longrightarrow  \varepsilon\\
A&amp;\longrightarrow aA\\
A&amp;\longrightarrow a
\end{aligned}
$\)</span></p>
</li>
<li><p>Consider the string <span class="math notranslate nohighlight">\(z+(x+y)*x\)</span>. Find a left derivation
of this string according to each of the grammars <span class="math notranslate nohighlight">\(G_1\)</span>, <span class="math notranslate nohighlight">\(G_2\)</span>, and
<span class="math notranslate nohighlight">\(G_3\)</span>, as given in this section.</p></li>
<li><p>Draw a parse tree for the string <span class="math notranslate nohighlight">\((x+y)*z*x\)</span> according to
each of the grammars <span class="math notranslate nohighlight">\(G_1\)</span>, <span class="math notranslate nohighlight">\(G_2\)</span>, and <span class="math notranslate nohighlight">\(G_3\)</span>, as given in this section.</p></li>
<li><p>Draw three different parse trees for the string
<span class="math notranslate nohighlight">\(ababbaab\)</span> based on the grammar given in part a) of exercise 1.</p></li>
<li><p>Suppose that the string <span class="math notranslate nohighlight">\(abbcabac\)</span> has the parse
tree shown below, according to some grammar <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>a) List five production rules that must be rules in the grammar <span class="math notranslate nohighlight">\(G\)</span>,
given that this is a valid parse tree.</p>
<p>b) Give a left derivation for the string <span class="math notranslate nohighlight">\(abbcabac\)</span> according to the
grammar <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>c) Give a right derivation for the string <span class="math notranslate nohighlight">\(abbcabac\)</span> according to the
grammar <span class="math notranslate nohighlight">\(G\)</span>.</p>
</li>
</ol>
<p>&lt;img src={useBaseUrl(âimg/fig-5-3.pngâ)}
alt=âExercise parse treeâ className=âcentered-figureâ /&gt;</p>
<ol class="simple">
<li><p>Show the full sequence of shift and reduce operations
that are used in the LR(1) parsing of the string <span class="math notranslate nohighlight">\(x+(y)*z\)</span> according
to the grammar <span class="math notranslate nohighlight">\(G_3\)</span>, and give the corresponding right derivation
of the string.</p></li>
<li><p>This section showed how to use LL(1) and LR(1) parsing to
find a derivation of a string in the language <span class="math notranslate nohighlight">\(L(G)\)</span> generated by
some grammar <span class="math notranslate nohighlight">\(G\)</span>. How is it possible to use LL(1) or LR(1) parsing
to determine for an arbitrary string <span class="math notranslate nohighlight">\(w\)</span> whether <span class="math notranslate nohighlight">\(w\in L(G)\,\)</span>?
Give an example.</p></li>
</ol>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./lang"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="bnf.html" title="previous page">Backus-Naur Form</a>
    <a class='right-next' id="next-link" href="pda.html" title="next page">Pushdown Automata</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Brian T. Howard, based in part on material by Carol Critchlow and David Eck<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    <script src="../_static/js/index.js"></script>
    
  </body>
</html>