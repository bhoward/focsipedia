(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{131:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return o})),a.d(t,"metadata",(function(){return i})),a.d(t,"rightToc",(function(){return c})),a.d(t,"default",(function(){return p}));var n=a(1),r=a(6),s=(a(0),a(212)),o={id:"regexpapp",title:"Applications of Regular Expressions"},i={id:"lang/regexpapp",title:"Applications of Regular Expressions",description:"(Content adapted from Critchlow &amp; Eck)",source:"@site/docs/lang/regexpapp.md",permalink:"/focsipedia/docs/lang/regexpapp",editUrl:"https://github.com/bhoward/focsipedia/edit/master/docs/lang/regexpapp.md",sidebar:"someSidebar",previous:{title:"Regular Expressions",permalink:"/focsipedia/docs/lang/regexp"},next:{title:"ReasonML",permalink:"/focsipedia/docs/reason"}},c=[],l={rightToc:c};function p(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(s.b)("wrapper",Object(n.a)({},l,a,{components:t,mdxType:"MDXLayout"}),Object(s.b)("p",null,"(Content adapted from Critchlow ","&"," Eck)"),Object(s.b)("p",null,"\\newcommand{\\bk}{\\char",Object(s.b)("inlineCode",{parentName:"p"},"\\\\}\n\\newcommand{\\vb}{\\char"),"|","}\n\\newcommand{\\sol}{\\char`\\^}"),Object(s.b)("p",null,"A common operation when editing text is to search for a\ngiven string of characters, sometimes with the purpose of\nreplacing it with another string.  Many ``search and replace''\\index{search\nand replace} facilities have the option of using regular expressions\ninstead of simple strings of characters.  A regular expression describes\na language, that is, a \\textit{set} of strings.  We can think of a regular\nexpression as a \\nw{pattern} that matches certain strings, namely all\nthe strings in the language described by the regular expression.\nWhen a regular expression is used in a search operation, the\ngoal is to find a string that matches the expression.  This type\nof \\nw{pattern matching} is very useful.\\index{regular expressions!and\npattern matching}"),Object(s.b)("p",null,"The ability to do pattern matching with regular expressions is provided\nin many text editors, including \\textit{jedit} and \\textit{kwrite}.\nProgramming languages often come with libraries for working with\nregular expressions.  Java (as of version 1.4) provides regular\nexpression handling though a package named \\textit{java.util.regexp}.\nC++ typically provides a header file named \\textit{regexp.h} for\nthe same purpose.  In all these applications, many new notations are added to the syntax to make it\nmore convenient to use.  The syntax can vary from one implementation\nto another, but most implementations include the capabilities\ndiscussed in this section."),Object(s.b)("p",null,"\\medskip"),Object(s.b)("p",null,"In applications of regular expressions, the alphabet usually includes\nall the characters on the keyboard.  This leads to a problem, because\nregular expressions actually use two types of symbols:  symbols that\nare members of the alphabet and special symbols such a ",Object(s.b)("inlineCode",{parentName:"p"},"\\texttt{*}'' and "),"\\texttt{)}'' that\nare used to construct expressions.  These special symbols, which\nare not part of the language being described but are used in the\ndescription, are called \\nw{meta-characters}.  The problem is,\nwhen the alphabet includes all the available characters, what do we\ndo about meta-characters?  If the language that we are describing\nuses the ``\\texttt{*}'' character, for example, how can we represent the\nKleene star operation?"),Object(s.b)("p",null,"The solution is to use a so-called ``escape character,'' which is\nusually the backslash,~\\texttt{\\bk}.  We agree, for example, that the notation\n\\texttt{\\bk",Object(s.b)("em",{parentName:"p"},"} refers to the symbol \\texttt{"),"} that is a member of\nthe alphabet, while \\texttt{",Object(s.b)("em",{parentName:"p"},"} by itself is the meta-character\nthat represents the Kleene star operation.  Similarly,\n\\texttt{(} and \\texttt{)} are the meta-characters that are used\nfor grouping, while the corresponding characters in the language\nare written as \\texttt{\\bk(} and \\texttt{\\bk)}.  For example,\na regular expression that matches the string \\texttt{a"),"b} repeated\nany number of times would be written: \\texttt{(a\\bk",Object(s.b)("em",{parentName:"p"},"b)"),"}.\nThe backslash is also used to represent certain non-printing\ncharacters.  For example, a tab is represented as \\texttt{\\bk t}\nand a new line character is \\texttt{\\bk n}."),Object(s.b)("p",null,"%Outside this section of this book, ",Object(s.b)("strong",{parentName:"p"},"*"),"\n%we use the symbol + as a meta-character to represent\n%a choice between alternatives in a regular expression.  In applications,\n%however, the same operation is almost universally expressed using\n%the vertical bar symbol~\\texttt{\\vb}, which computer scientists tend to\n%associate with the word ``or.''  In this section, we follow the\n%same convention and use \\texttt{a\\vb b} rather than \\texttt{a+b} for\n%the regular expression that matches either \\texttt{a} or\n%\\texttt{b}.  (This means, of course, that if we want to use\n%\\texttt{\\vb} as a normal character rather than a meta-character, we must\n%write it as~\\texttt{\\bk\\vb}.  The same remark applies to all the new\n%meta-characters that are introduced below.)"),Object(s.b)("p",null,"We introduce two new common operations on regular expressions and two\nnew meta-characters to represent them.\nThe first operation is represented by the meta-character~\\texttt{+}:\nIf \\texttt{r} is a regular expression, then \\texttt{r+} represents the\noccurrence of \\texttt{r} one or more times.  The second operation\nis represented by~\\texttt{?}: The notation \\texttt{r?} represents an occurrence of \\texttt{r}\nzero or one times.  That is to say, \\texttt{r?} represents an optional\noccurrence of \\texttt{r}.  Note that these operations are introduced\nfor convenience only and do not represent any real increase\nin the power.  In fact, \\texttt{r+} is exactly equivalent to\n\\texttt{rr*}, and \\texttt{r?} is equivalent to \\texttt{(r|",Object(s.b)("span",Object(n.a)({parentName:"p"},{className:"math math-inline"}),Object(s.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(s.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(s.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(s.b)("semantics",{parentName:"math"},Object(s.b)("mrow",{parentName:"semantics"},Object(s.b)("mstyle",Object(n.a)({parentName:"mrow"},{mathcolor:"#cc0000"}),Object(s.b)("mtext",{parentName:"mstyle"},"\\varep"))),Object(s.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"\\varep")))),Object(s.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(s.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(s.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}})),Object(s.b)("span",Object(n.a)({parentName:"span"},{className:"mord text",style:{color:"#cc0000"}}),Object(s.b)("span",Object(n.a)({parentName:"span"},{className:"mord",style:{color:"#cc0000"}}),"\\varep")))))),")}\n(except that in applications there is generally no equivalent to ",Object(s.b)("span",Object(n.a)({parentName:"p"},{className:"math math-inline"}),Object(s.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(s.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(s.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(s.b)("semantics",{parentName:"math"},Object(s.b)("mrow",{parentName:"semantics"},Object(s.b)("mstyle",Object(n.a)({parentName:"mrow"},{mathcolor:"#cc0000"}),Object(s.b)("mtext",{parentName:"mstyle"},"\\varep"))),Object(s.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"\\varep")))),Object(s.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(s.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(s.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}})),Object(s.b)("span",Object(n.a)({parentName:"span"},{className:"mord text",style:{color:"#cc0000"}}),Object(s.b)("span",Object(n.a)({parentName:"span"},{className:"mord",style:{color:"#cc0000"}}),"\\varep")))))),")."),Object(s.b)("p",null,"To make it easier to deal with the large number of characters in the\nalphabet, \\nw{character classes} are introduced.  A character class\nconsists of a list of characters enclosed between brackets, \\texttt{","[} and\n\\texttt{]","}.  (The brackets are meta-characters.)  A character class\nmatches a single character, which can be any of the characters in\nthe list.  For example, \\texttt{","[0123456789]","} matches any one of\nthe digits 0 through 9.  The same thing could be expressed\nas \\texttt{(0\\vb1\\vb2\\vb3\\vb4\\vb5\\vb6\\vb7\\vb8\\vb9)}, so once again\nwe have added only convenience, not new representational power.\nFor even more convenience, a hyphen can be included in a character\nclass to indicate a range of characters.  This means that\n\\texttt{","[0123456789]","} could also be written as \\texttt{","[0-9]","}\nand that the regular expression \\texttt{","[a-z]","} will match any\nsingle lowercase letter.  A character class can include multiple\nranges, so that \\texttt{","[a-zA-Z]","} will match any letter, lower- or\nuppercase.  The period~(\\texttt{.}) is a meta-character that will\nmatch any single character, except (in most implementations)\nfor an end-of-line.\nThese notations can, of course, be used in more complex\nregular expressions.  For example, \\texttt{","[A-Z][a-zA-Z]",Object(s.b)("em",{parentName:"p"},"}\nwill match any capitalized word, and \\texttt{\\bk(."),"\\bk)} matches\nany string of characters enclosed in parentheses."),Object(s.b)("p",null,"In most implementations, the meta-character \\texttt{\\sol} can be used in\na regular expression to match the beginning of a line of text, so that\nthe expression \\texttt{\\sol ","[a-zA-Z]","+} will only match a word that\noccurs at the start of a line.  Similarly, \\texttt{","$","} is used\nas a meta-character to match the end of a line.  Some implementations\nalso have a way of matching beginnings and ends of words.\nTypically, \\texttt{\\bk b} will match such ",Object(s.b)("inlineCode",{parentName:"p"},"word boundaries.''\nUsing this notation, \nthe pattern \\texttt{\\bk band\\bk b} will match the string "),"and''\nwhen it occurs as a word, but will not match the \\hbox{a-n-d}\nin the word ``random.''  We are going a bit beyond\nbasic regular expressions here: Previously, we only thought of\na regular expression as something that either will match\nor will not match a given string in its entirety.   When\nwe use a regular expression for a search operation, however,\nwe want to find a \\textit{substring} of a given string that\nmatches the expression.  The notations \\texttt{\\sol},\n\\texttt{","$","} and \\texttt{\\bk b} put a restrictions\non \\textit{where} the matching substring can be located in the string."),Object(s.b)("p",null,"\\medskip"),Object(s.b)("p",null,"When regular expressions are used in search-and-replace operations,\na regular expression is used for the search pattern.  A search is\nmade in a (typically long) string for a substring that matches the pattern,\nand then the substring is replaced by a specified replacement\npattern.  The replacement pattern is not used for matching\nand is not a regular expression.  However, it can be more than\njust a simple string.  It's possible to include parts of the\nsubstring that is being replaced in the replacement string.\nThe notations \\texttt{\\bk0}, \\texttt{\\bk1}, \\dots, \\texttt{\\bk9}\nare used for this purpose.  The first of these, \\texttt{\\bk0},\nstands for the entire substring that is being replaced.\nThe others are only available when parentheses are used in\nthe search pattern.  The notation \\texttt{\\bk1} stands for\n``the part of the substring that matched the part of the\nsearch pattern beginning with the first \\texttt{(} in the\npattern and ending with the matching \\texttt{)}.''  Similarly,\n\\texttt{\\bk2} represents whatever matched the part of the\nsearch pattern between the second pair of parentheses, and so on."),Object(s.b)("p",null,"Suppose, for example, that you would like to search for\na name in the form \\textit{last-name,~first-name} and\nreplace it with the same name in the form \\textit{first-name last-name}.\nFor example, ",Object(s.b)("inlineCode",{parentName:"p"},"Reeves, Keanu'' should be converted to "),"Keanu Reeves''.\nAssuming that names contain only letters,\nthis could be done using the search pattern \\texttt{(","[A-Za-z]","+),~(","[A-Za-z]","+)}\nand the replacement pattern \\texttt{\\bk2 \\bk1}.  When the match is\nmade, the first \\texttt{(","[A-Za-z]","+)} will match ",Object(s.b)("inlineCode",{parentName:"p"},"Reeves,'' \nso that in the replacement pattern, \\texttt{\\bk1} represents the\nsubstring "),"Reeves''. Similarly, \\texttt{\\bk2} will represent\n",Object(s.b)("inlineCode",{parentName:"p"},"Keanu''.  Note that the parentheses\nare included in the search pattern \\textit{only} to specify what parts\nof the string are represented by \\texttt{\\bk1} and \\texttt{\\bk2}.\nIn practice, you might use \\texttt{\\sol([A-Za-z]+),~([A-Za-z])\\$}\nas the search pattern to constrain it so that it will only \nmatch a complete line of text.  By using a "),"global'' search-and-replace,\nyou could convert an entire file of names from one format to the other\nin a single operation."),Object(s.b)("p",null,"\\medskip"),Object(s.b)("p",null,"Regular expressions are a powerful and useful technique that\nshould be part of any computer scientist's toolbox.  This section\nhas given you a taste of what they can do, but you should check\nout the specific capabilities of the regular expression implementation\nin the tools and programming languages that you use."),Object(s.b)("p",null,"\\begin{exercises}"),Object(s.b)("p",null,"\\problem The backslash is itself a meta-character.  Suppose that\nyou want to match a string that contains a backslash\ncharacter.  How do you suppose you would represent the backslash in\nthe regular expression?"),Object(s.b)("p",null,"\\problem Using the notation introduced in this section,\nwrite a regular expression that could be used to match\neach of the following:\n\\ppart Any sequence of letters (upper- or lowercase) that\nincludes the letter Z (in uppercase).\n\\ppart Any eleven-digit telephone number written in the form\n\\texttt{(xxx)xxx-xxxx}.\n\\ppart Any eleven-digit telephone number \\textit{either}\nin the form \\texttt{(xxx)xxx-xxxx} or \\texttt{xxx-xxx-xxxx}.\n\\ppart A non-negative real number with an optional decimal\npart.  The expression should match numbers such as\n17, 183.9999, 182., 0, 0.001, and 21333.2.\n\\ppart A complete line of  text that contains only letters.\n\\ppart A C++ style one-line comment consisting of \\texttt{//} and all the\nfollowing characters up to the end-of-line."),Object(s.b)("p",null,"\\problem Give a search pattern and a replace pattern that could\nbe used to perform the following conversions:\n\\ppart Convert a string that is enclosed in a pair of double quotes to\nthe same string with the double quotes replaced by single quotes.\n\\ppart Convert seven-digit telephone numbers in the format\n\\texttt{xxx-xxx-xxxx} to the format \\texttt{(xxx)xxx-xxxx}.\n\\ppart Convert C++ one-line comments, consisting of characters\nbetween \\texttt{//} and end-of-line, to C style comments enclosed\nbetween \\texttt{/",Object(s.b)("em",{parentName:"p"},"} and \\texttt{"),"/}",Object(s.b)("span",Object(n.a)({parentName:"p"},{className:"math math-inline"}),Object(s.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(s.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(s.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(s.b)("semantics",{parentName:"math"},Object(s.b)("mrow",{parentName:"semantics"},Object(s.b)("mtext",{parentName:"mrow"},"\u2009")),Object(s.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"\\,")))),Object(s.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(s.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(s.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0em",verticalAlign:"0em"}})),Object(s.b)("span",Object(n.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.16666666666666666em"}})))))),".\n\\ppart Convert any number of consecutive spaces and tabs to\na single space."),Object(s.b)("p",null,"\\problem In some implementations of ",Object(s.b)("inlineCode",{parentName:"p"},"regular expressions,'' the\nnotations \\texttt{\\bk 1}, \\texttt{\\bk 2}, and so on can occur\nin a search pattern.  For example, consider the search pattern\n\\texttt{\\sol([a-zA-Z]).*\\bk1\\$}.  Here, \\texttt{\\bk1} represents\na recurrence of the same substring that matched \\texttt{[a-zA-Z]},\nthe part of the pattern between the first pair of parentheses.\nThe entire pattern, therefore, will match a line of text that\nbegins and ends with the same letter.  Using this notation,\nwrite a pattern that matches all strings in the language\n$L=\\{a^nba^n\\,\\st\\,n\\ge0\\}$.  (Later in this chapter, we will\nsee that $L$ is \\textit{not} a regular language, so allowing the\nuse of \\texttt{\\bk1} in a "),"regular expression'' means that it's\nnot really a regular expression at all!  This notation can add\na real increase in expressive power to the patterns that contain it.)"),Object(s.b)("p",null,"\\end{exercises}"))}p.isMDXComponent=!0},212:function(e,t,a){"use strict";a.d(t,"a",(function(){return h})),a.d(t,"b",(function(){return u}));var n=a(0),r=a.n(n);function s(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){s(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function c(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=r.a.createContext({}),p=function(e){var t=r.a.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i({},t,{},e)),a},h=function(e){var t=p(e.components);return r.a.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},b=Object(n.forwardRef)((function(e,t){var a=e.components,n=e.mdxType,s=e.originalType,o=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),h=p(a),b=n,u=h["".concat(o,".").concat(b)]||h[b]||m[b]||s;return a?r.a.createElement(u,i({ref:t},l,{components:a})):r.a.createElement(u,i({ref:t},l))}));function u(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var s=a.length,o=new Array(s);o[0]=b;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:n,o[1]=i;for(var l=2;l<s;l++)o[l]=a[l];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,a)}b.displayName="MDXCreateElement"}}]);