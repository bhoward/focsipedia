---
id: pda
title: Pushdown Automata
---
import useBaseUrl from '@docusaurus/useBaseUrl';

(Content adapted from Critchlow &amp; Eck)

In the previous chapter, we saw that there is a neat correspondence
between regular expressions and finite automata. That is, a language
is generated by a regular expression if and only if that language is
accepted by a finite automaton. Finite automata come in two types,
deterministic and nondeterministic, but the two types of finite
automata are equivalent in terms of their ability to recognize
languages. So, the class of regular languages can be defined in
two ways: either as the set of languages that can be generated by
regular expressions or as the set of languages that can be recognized
by finite automata (either deterministic or nondeterministic).

In this chapter, we have introduced the class of context-free languages,
and we have considered how context-free grammars can be used to
generate context-free languages. You might wonder whether there is any
type of automaton that can be used to recognize context-free languages.
In fact, there is: The abstract machines known as 
**pushdown automata** can be used to define
context-free languages. That is, a language is context-free if and only
if there is a pushdown automaton that accepts that language.

A pushdown automaton is essentially a finite automaton with an auxiliary 
data structure known as a **stack**. A stack consists of
a finite list of symbols. Symbols can be added to and removed from the
list, but only at one end of the list. The end of the list where items
can be added and removed is called the **top** of the stack.
The list is usually visualized as a vertical "stack" of symbols,
with items being added and removed at the top. Adding a symbol at
the top of the stack is referred to as **pushing** a symbol onto 
the stack, and removing a symbol is referred to as **popping**
an item from the stack. During each step of its computation, 
a pushdown automaton is capable of doing several
push and pop operations on its stack (this in addition to possibly reading
a symbol from the input string that is being processed by the automaton).

Before giving a formal definition of pushdown automata, we will look
at how they can be represented by transition diagrams. A diagram of
a pushdown automaton is similar to a diagram for an NFA, except that
each transition in the diagram can involve stack operations. We will
use a label of the form $\sigma,x$/$y$ on a transition to mean
that the automaton consumes $\sigma$ from its input string, pops
$x$ from the stack, and pushes $y$ onto the stack. $\sigma$ can be
either $\varepsilon$ or a single symbol.
$x$ and $y$ are strings, possibly empty. (When a string $x=a_1a_2\ldots a_m$ is
popped from the stack, $a_1$ must be the top symbol on the stack, followed by
$a_2$, _etc_.; for $y=b_1b_2\ldots b_n$ to be pushed onto a stack, the symbols are
pushed in the order $b_n,\ldots,b_1$, so that
$b_1$ ends up on the top of the stack.) 
For example, consider the following transition diagram for a pushdown automaton:

<img src={useBaseUrl('img/fig-5-pa-1.png')}
alt="Sample PDA" className="centered-figure" />

This pushdown automaton has start state $q_0$ and one accepting
state, $q_1$. It can read strings over the alphabet $\Sigma=\{a,b\}$.
The transition from $q_0$ to $q_0$, labeled with $a,\varepsilon$/1,
means that if the machine is in state $q_0$, then it can read an
$a$ from its input string, pop nothing from the stack, push 1 onto
the stack, and remain in state $q_0$. Similarly, the transition
from $q_1$ to $q_1$ means that if the machine is in state $q_1$,
it can read a $b$ from its input string, pop a 1 from the stack,
and push nothing onto the stack. Finally, the transition
from state $q_0$ to $q_1$, labeled with $\varepsilon,\varepsilon$/$\varepsilon$,
means that the machine can transition from state $q_0$ to state $q_1$
without reading, pushing, or popping anything.

Note that the automation can follow transition $b,1$/$\varepsilon$ only
if the next symbol in the input string is $b$ and if $1$ is on the 
top of the stack. When it makes the transition, it consumes the $b$ from
input and pops the $1$ from the stack. Since in this case, the automaton
pushes $\varepsilon$ (that is, no symbols at all) onto the stack, the net
change in the stack is simply to pop the 1.

We have to say what it means for this pushdown automaton to accept
a string. For $w\in\{a,b\}^*$, we say that the pushdown automaton
accepts $w$ if and only if it is possible for the machine to start
in its start state, $q_0$, read all of $w$, and finish in the
accepting state, $q_1$, with an empty stack. Note in particular that
it is not enough for the machine to finish in an accepting state&mdash;it
must also empty the stack.[^We could relax this restriction
and require only that the machine finish in an accepting state after
reading the string $w$, without requiring that the stack be empty.
In fact, using this definition of accepting would not change the
class of languages that are accepted by pushdown automata.]

It's not difficult to see that with this definition, the language
accepted by our pushdown automaton is $\{a^nb^n\;|\; n\in\N\}$.
In fact, given the string $w=a^kb^k$, the machine can process this
string by following the transition from $q_0$ to $q_0$ $k$ times.
This will consume all the $a$'s and will push $k$ 1's onto the stack.
The machine can then jump to state $q_1$ and follow the transition from
$q_1$ to $q_1$ $k$ times. Each time it does so, it consumes one $b$ from
the input and pops one 1 from the stack. At the end, the input has been
completely consumed and the stack is empty. So, the string $w$ is
accepted by the automaton. Conversely, this pushdown automaton _only_
accepts strings of the form $a^kb^k$, since the only way that the
automaton can finish in the accepting state, $q_1$, is to follow
the transition from $q_0$ to $q_0$ some number of times, reading
$a$'s as it does so, then jump at some point to $q_1$, and then
follow the transition from $q_1$ to $q_1$ some number of times,
reading $b$'s as it does so. This means that an accepted string
must be of the form $a^kb^\ell$ for some $k,\ell\in\N$. However, in
reading this string, the automaton pushes $k$ 1's onto the stack
and pops $\ell$ 1's from the stack. For the stack to end up empty,
$\ell$ must equal $k$, which means that in fact the string is of
the form $a^kb^k$, as claimed. 

---

Here are two more examples. These pushdown automata use the capability
to push or pop more than one symbol at a time:

<img src={useBaseUrl('img/fig-5-pa-1b.png')}
alt="Sample PDAs" className="centered-figure" />

The automaton on the left accepts the language
$\{a^nb^m\;|\; n\le m\le 2n\}$. Each time it reads an $a$,
it pushes either one or two 1's onto the stack, so that
after reading $n$ $a$'s, the number of 1's on the stack
is between $n$ and $2n$. If the machine then jumps to state
$q_1$, it must be able to read exactly enough $b$'s to empty 
the stack, so any string accepted by this machine must
be of the form $a^nb^m$ with $n\le m\le 2n$. Conversely,
any such string can be accepted by the machine. Similarly,
the automaton on the right above accepts the
language $\{a^nb^m\;|\; n/2 \le m \le n\}$.
To accept $a^nb^m$, it must push $n$ 1'a onto the
stack and then pop one or two 1's for each b; this
can succeed only if the number of $b$'s is between
$n/2$ and $n$.

---

Note that an NFA can be considered to be a pushdown automaton that
does not make any use of its stack. This means that any language
that can be accepted by an NFA (that is, any regular language) can
be accepted by a pushdown automaton.
Since the language $\{a^nb^n\;|\; n\in\N\}$ is context-free but not regular,
and since it is accepted by the above pushdown automaton,
we see that pushdown automata are capable of recognizing context-free languages
that are not regular, therefore pushdown automata are strictly more
powerful than finite automata.

## Formal Definition

Although it is not particularly illuminating, we can give a formal
definition of pushdown automaton. The definition does at least
make it clear that the set of symbols that can be used on the
stack is not necessarily the same as the set of symbols that can
be used as input.

> A pushdown automaton $M$ is specified by six components
$M=(Q,\Sigma,\Lambda,q_0,\partial,F)$ where
>
>   * $Q$ is a finite set of states.
>   * $\Sigma$ is an alphabet. $\Sigma$ is the **input alphabet** for $M$.
>   * $\Lambda$ is an alphabet. $\Lambda$ is the **stack alphabet** for $M$.
>   * $q_0\in Q$ is the **start state** of $M$.
>   * $F\subseteq Q$ is the set of **final** or **accepting** states in $M$.
>   * $\partial$ is the set of transitions in $M$. $\partial$ can be taken
to be a finite subset of the set 
$(Q\times(\Sigma\cup\{\varepsilon\})\times\Lambda^*\big)\times\big(Q\times\Lambda^*\big)$.
An element $\big((q_1,\sigma,x),(q_2,y)\big)$ of $\partial$ represents a transition from
state $q_1$ to state $q_2$ in which $M$ reads $\sigma$ from its input string,
pops $x$ from the stack, and pushes $y$ onto the stack.

We can then define the language $L(M)$ accepted by a pushdown
automaton $M=(Q,\Sigma,\Lambda,q_0,\partial,F)$ to be the set
$L(M)=\{w\in\Sigma^*\;|\;M\textrm{ can start from }q_0\textrm{, read all of }w\textrm{, and end with an empty stack in a state in }F\}$.

With this definition, the class of languages accepted by pushdown automata
is the same as the class of languages generated by context-free grammars.

> **Theorem:**
Let $\Sigma$ be an alphabet, and let $L$ be a language over $L$. Then
$L$ is context-free if and only if there is a pushdown automaton whose
input alphabet is $\Sigma$ such that $L=L(M)$.

We will not prove this theorem, but we do discuss how one direction can
be proved. Suppose that $L$ is a context-free language over an alphabet
$\Sigma$. Let $G=(V,\Sigma,P,S)$ be a context-free grammar for $L$.
Then we can construct a pushdown automaton $M$ that accepts $L$. In fact,
we can take $M=(Q,\Sigma,\Lambda,q_0,\partial,F)$ where
$Q=\{q_0,q_1\}$, $\Lambda=\Sigma\cup V$, $F=\{q_1\}$, and
$\partial$ contains transitions of the forms
   * $\big((q_0,\varepsilon,\varepsilon),(q_1,S)\big)$;
   * $\big((q_1,\sigma,\sigma),(q_1,\varepsilon)\big)$, for $\sigma\in\Sigma$; and
   * $\big((q_1,\varepsilon,A),(q_1,x)\big)$, for each production $A\longrightarrow x$ in $G$.

The transition $\big((q_0,\varepsilon,\varepsilon),(q_1,S)\big)$ lets $M$
move from the start state $q_0$ to the accepting state $q_1$ while reading
no input and pushing $S$ onto the stack. This is the only possible first move
by $M$. 

A transition of the form $\big((q_1,\sigma,\sigma),(q_1,\varepsilon)\big)$, for $\sigma\in\Sigma$,
allows $M$ to read $\sigma$ from its input string, provided there is a $\sigma$
on the top of the stack. Note that if $\sigma$ is at the top of the stack, then this
transition is the _only_ transition that applies. Effectively, any terminal symbol
that appears at the top of the stack must be matched by the same symbol in the
input string, and the transition rule allows $M$ to consume the symbol from the
input string and remove it from the stack at the same time.

A transition of the third form, $\big((q_1,\varepsilon,A),(q_1,x)\big)$, can
be applied if and only if the non-terminal symbol $A$ is at the top of
the stack. $M$ consumes no input when this rule is applied, but $A$ is
replaced on the top of the stack by the string on the right-hand
side of the production rule $A\longrightarrow x$. Since the grammar $G$ can
contain several production rules that have $A$ as their left-hand side,
there can be several transition rules in $M$ that apply when $A$ is on the
top of the stack. This is the only source of nondeterminism in $M$; note
that is also the source of nondeterminism in $G$.

The proof that $L(M)=L(G)$ follows from the fact that
a computation of $M$ that accepts a string $w\in\Sigma^*$ corresponds in
a natural way to a left derivation of $w$ from $G$'s start symbol, $S$.
Instead of giving a proof of this fact, we look at an example.
Consider the following context-free grammar:
$$
\begin{aligned}
 S&\longrightarrow AB\\
 A&\longrightarrow aAb\\
 A&\longrightarrow \varepsilon\\
 B&\longrightarrow bB\\
 B&\longrightarrow b
\end{aligned}
$$
This grammar generates the language $\{a^nb^m\;|\; m > n\}$. The pushdown
automaton constructed from this grammar by the procedure given above has
the following set of transition rules:
$$
\begin{aligned}
 &\big((q_0,\varepsilon,\varepsilon),(q_1,S)\big)\\
 &\big((q_1,a,a),(q_1,\varepsilon)\big)\\
 &\big((q_1,b,b),(q_1,\varepsilon)\big)\\
 &\big((q_1,\varepsilon,S),(q_1,AB)\big)\\
 &\big((q_1,\varepsilon,A),(q_1,aAb)\big)\\
 &\big((q_1,\varepsilon,A),(q_1,\varepsilon)\big)\\
 &\big((q_1,\varepsilon,B),(q_1,bB)\big)\\
 &\big((q_1,\varepsilon,B),(q_1,b)\big)
\end{aligned}
$$
Suppose that the automaton is run on the input $aabbbb$. We can trace the
sequence of transitions that are applied in a computation that accepts this
input, and we can compare that computation to a left derivation of the
string:

| Transition                                        | Input Consumed | Stack   | Derivation               | Production                    |
| :------------------------------------------------ | -------------: | :------ | :----------------------- | :---------------------------- |
| $\big((q_0,\varepsilon,\varepsilon),(q_1,S)\big)$ |                | $S$     |                          |                               |
| $\big((q_1,\varepsilon,S),(q_1,AB)\big)$          |                | $AB$    | $S\Longrightarrow AB$    | $S\longrightarrow AB$         |
| $\big((q_1,\varepsilon,A),(q_1,aAb)\big)$         |                | $aAbB$  | $\Longrightarrow aAbB$   | $A\longrightarrow aAb$        |
| $\big((q_1,a,a),(q_1,\varepsilon)\big)$           |            $a$ | $AbB$   |                          |                               |
| $\big((q_1,\varepsilon,A),(q_1,aAb)\big)$         |            $a$ | $aAbbB$ | $\Longrightarrow aaAbbB$ | $A\longrightarrow aAb$        |
| $\big((q_1,a,a),(q_1,\varepsilon)\big)$           |           $aa$ | $AbbB$  |                          |                               |
| $\big((q_1,\varepsilon,A),(q_1,\varepsilon)\big)$ |           $aa$ | $bbB$   | $\Longrightarrow aabbB$  | $A\longrightarrow\varepsilon$ |
| $\big((q_1,b,b),(q_1,\varepsilon)\big)$           |          $aab$ | $bB$    |                          |                               |
| $\big((q_1,b,b),(q_1,\varepsilon)\big)$           |         $aabb$ | $B$     |                          |                               |
| $\big((q_1,\varepsilon,B),(q_1,bB)\big)$          |         $aabb$ | $bB$    | $\Longrightarrow aabbbB$ | $B\longrightarrow bB$         |
| $\big((q_1,b),(q_1,b,\varepsilon)\big)$           |        $aabbb$ | $B$     |                          |                               |
| $\big((q_1,\varepsilon,B),(q_1,b)\big)$           |        $aabbb$ | $b$     | $\Longrightarrow aabbbb$ | $B\longrightarrow b$          |
| $\big((q_1,b,b),(q_1,\varepsilon)\big)$           |       $aabbbb$ |         |                          |                               |


Note that at all times during this computation, the concatenation of the input that has been consumed
so far with the contents of the stack is equal to one of the strings in the left derivation.
Application of a rule of the form $\big((q_1,\sigma,\sigma),(q_1,\varepsilon)\big)$ has the
effect of removing one terminal symbol from the "Stack" column to the "Input Consumed" column.
Application of a rule of the form $\big((q_1,\varepsilon,A),(q_1,x)\big)$ has the
effect of applying the next step in the left derivation to the non-terminal symbol on the top
of the stack. (In the "Stack" column, the pushdown automaton's stack is shown with its
top on the left.) In the end, the entire input string has been consumed and the stack is empty, which
means that the string has been accepted by the pushdown automaton. It should be easy to see
that for any context free grammar $G$, the same correspondence will always hold between
left derivations and computations performed by the pushdown automaton constructed from $G$.

---

The computation of a pushdown automaton can involve nondeterminism.
That is, at some point in the computation, there might be more than
one transition rule that apply. When this is not the case&mdash;that is,
when there is no circumstance in which two different transition rules
apply&mdash;then we say that the pushdown automaton is **deterministic**.
Note that a deterministic pushdown automaton can have transition
rules of the form $\big((q_i,\varepsilon,x),(q_j,y)\big)$ (or
even $\big((q_i,\varepsilon,\varepsilon),(q_j,y)\big)$ if that is
the _only_ transition from state $q_i$). Note also that is is possible
for a deterministic pushdown automaton to get "stuck"; that is, it
is possible that no rules apply in some circumstances even though the
input has not been completely consumed or the stack is not empty.
If a deterministic pushdown automaton gets stuck while reading a string
$x$, then $x$ is not accepted by the automaton.

The automaton given at the beginning of this section,
which accepts the language $\{a^nb^n\;|\; n\in\N\}$, 
is not deterministic. However, it is easy to construct a deterministic
pushdown automaton for this language:

<img src={useBaseUrl('img/fig-5-pa-2.png')}
alt="DPDA for a^nb^n" className="centered-figure" />

However, consider the language $\{ww^R\;|\; w\in\{a,b\}^*\}$. Here is
a pushdown automaton that accepts this language:

<img src={useBaseUrl('img/fig-5-pa-3.png')}
alt="PDA for ww^R" className="centered-figure" />

In state $q_0$, this machine copies the first part of its input
string onto the stack. In state $q_1$, it tries to match the remainder of the
input against the contents of the stack. In order for this to work, it must "guess"
where the middle of the string occurs by following the transition
from state $q_0$ to state $q_1$. 
In this case, it is by no means clear that it is possible to
construct a deterministic pushdown automaton that accepts the same
language.

---

At this point, it might be tempting to define a deterministic context-free
language as one for which there exists a deterministic pushdown automaton
which accepts that language. However, there is a technical problem with
this definition: we need to make it possible for the pushdown automaton
to detect the end of the input string. Consider the language
$\{w\;|\; w\in\{a,b\}^* \land n_a(w)=n_b(w)\}$, which consists of strings over the
alphabet $\{a,b\}$ in which the number of $a$'s is equal to the number
of $b$'s. This language is accepted by the following pushdown automaton:

<img src={useBaseUrl('img/fig-5-pa-4.png')}
alt="Example PDA" className="centered-figure" />

In this automaton, a $c$ is first pushed onto the stack,
and it remains on the bottom of the stack until the computation ends.
During the process of reading an input string,
if the machine is in state $q_3$, then the
number of $a$'s that have been read is greater than or equal to
the number of $b$'s that have been read, and the stack contains
(copies of) the excess $a$'s that have been read. Similarly,
if the machine is in state $q_4$, then the
number of $b$'s that have been read is greater than or equal to
the number of $a$'s that have been read, and the stack contains
(copies of) the excess $b$'s that have been read.
As the computation proceeds, if the stack contains nothing but a $c$,
then the number of $a$'s that have been consumed by the machine
is equal to the number of $b$'s that have been consumed; in such
cases, the machine can pop the $c$ from the stack&mdash;leaving the
stack empty&mdash;and jump to state $q_2$. If the entire string has
been read at that time, then the string is accepted. This involves
nondeterminism because the automaton has to "guess" when to
jump to state $q_2$; it has no way of knowing whether it has
actually reached the end of the string.

Although this pushdown automaton is not deterministic, we can
modify it easily to get a deterministic pushdown automaton that
accepts a closely related language. We just have to add a
special end-of-string symbol to the language. We use the
symbol $\$$ for this purpose. The following deterministic
automaton accepts the language $\{w\$\;|\; w\in \{a,b\}^*\land n_a(w)=n_b(w)\}\,$:

<img src={useBaseUrl('img/fig-5-pa-4b.png')}
alt="Example DPDA" className="centered-figure" />

In this modified automaton, it is only possible for the
machine to reach the accepting state $q_2$ by reading the end-of-string
symbol at a time when the number of $a$'s that have been consumed is equal
to the number of $b$'s. Taking our cue from this example, we define 
what it means for a language to be deterministic context-free as follows:

> Let $L$ be a language over an alphabet $\Sigma$, and let $\$$ be
a symbol that is not in $\Sigma$. We say that $L$ is a **deterministic
context-free language**
if there is a deterministic pushdown automaton
that accepts the language $L\$$ (which is equal to 
$\{w\$\;|\; w\in L\}$).

There are context-free languages that are not deterministic context-free.
An example, given without proof, is the language of even-length palindromes
over the alphabet $\{a, b\}$: $\{ww^R\;|\; w\in\{a,b\}^*\}$.
This means that for pushdown automata, nondeterminism adds real power.
This contrasts with the case of finite automata, where deterministic
finite automata and nondeterministic finite automata are equivalent in
power in the sense that they accept the same class of languages.

A deterministic context-free language can be parsed efficiently (in $O(n)$ time,
where $n$ is the length of the input).
LL(1) parsing and LR(1) parsing can both be defined in terms of deterministic
pushdown automata, although we have not pursued that approach here. It can be shown
that every deterministic context-free language can be generated by an LR(1) grammar.
However, the languages that have LL(1) grammars are a strict subset: an example of
a language that has an LR(1) grammar but not an LL(1) grammar is
$\{a^nb^n\;|\; n\in\N\}\cup\{a^nc^n\;|\; n\in\N\}$.

## Exercises

1. Identify the context-free language that is accepted by each of the following
pushdown automata. Explain your answers.

   a)
<img src={useBaseUrl('img/fig-5-pa-ex1.png')}
alt="Exercise PDA" className="centered-figure" />

   b)
<img src={useBaseUrl('img/fig-5-pa-ex2.png')}
alt="Exercise PDA" className="centered-figure" />

   c)
<img src={useBaseUrl('img/fig-5-pa-ex3.png')}
alt="Exercise PDA" className="centered-figure" />

   d)
<img src={useBaseUrl('img/fig-5-pa-ex4.png')}
alt="Exercise PDA" className="centered-figure" />

2. Let $B$ be the language over the alphabet $\{\,\texttt{(}\,,\texttt{)}\,\}$ that consists of 
strings of parentheses that are balanced in the sense that every left parenthesis has
a matching right parenthesis. Examples include $\texttt{()}$, $\texttt{(())()}$, $\texttt{((())())()(())}$,
and the empty string. Find a deterministic pushdown automaton with a single state that
accepts the language $B$. Explain how your automaton works, and explain the circumstances
in which it will _fail_ to accept a given string of parentheses.

3. Suppose that $L$ is a language over an alphabet $\Sigma$.
Suppose that there is a deterministic pushdown automaton that accepts $L$.
Show that $L$ is deterministic context-free. That is, show how to construct
a deterministic pushdown automaton that accepts the language $L\$$.
(Assume that the symbol $\$$ is not in $\Sigma$.)

4. Find a deterministic pushdown automaton that accepts the language $\{wcw^R\;|\; w\in\{a,b\}^*\}$.

5. Show that the language $\{a^nb^m\;|\; n\not=m\}$ is deterministic context-free.

6. Show that the language $L=\{w\in\{a,b\}^*\;|\; n_a(w) > n_b(w)\}$ is deterministic context-free.

7. Let $M=(Q,\Sigma,\Lambda,q_0,\partial,F)$ be a pushdown automaton. Define $L^\prime(M)$ to be 
the language $L^\prime(M)=\{w\in\Sigma^*\ |$ it is possible for $M$ to start in state $q_0$,
read all of $w$, and end in an accepting state$\}$. $L^\prime(M)$ differs from $L(M)$ in that
for $w\in L^\prime(M)$, we do not require that the stack be empty at the end of the computation.
   * Show that there is a pushdown automaton $M^\prime$ such that $L(M^\prime)=L^\prime(M)$.
   * Show that a language $L$ is context-free if and only if there is a pushdown automaton
$M$ such that $L=L^\prime(M)$.
   * Identify the language $L^\prime(M)$ for each of the automata in Exercise 1.

8. Let $L$ be a regular language over an alphabet $\Sigma$, and let $K$
be a context-free language over the same alphabet. Let $M=(Q,\Sigma,q_0,\delta,F)$ be a DFA that
accepts $L$, and let $N=(P,\Sigma,\Lambda,p_0,\partial,E))$ be a pushdown automaton that accepts $K$.
Show that the language $L\cap K$ is context-free by constructing a pushdown automaton
that accepts $L\cap K$. The pushdown automaton can be constructed as a "cross product"
of $M$ and $N$ in which the set of states is $Q\times P$. The construction is analogous
to the proof that the intersection of two regular languages is regular, as outlined
in an exercise in the section on regular languages.
