<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="generator" content="Docusaurus">
<link rel="alternate" type="application/rss+xml" href="/focsipedia/blog/rss.xml" title="FoCSipedia Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/focsipedia/blog/atom.xml" title="FoCSipedia Blog Atom Feed">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css">
<script src="/focsipedia/eval.js"></script>
<script src="/focsipedia/refmt.js"></script>

<title data-react-helmet="true">Circuit Simplification</title>

<meta data-react-helmet="true" http-equiv="x-ua-compatible" content="ie=edge"><meta data-react-helmet="true" property="og:title" content="FoCSipedia · Foundations of Computation"><meta data-react-helmet="true" name="twitter:card" content="summary"><meta data-react-helmet="true" name="description" content="As noted above, a physical circuit does have some dependence on time, since each device in the circuit requires a non-zero time to respond to a change in its inputs. A more precise model needs to take these delays into account---a circuit is modeled by a Boolean expression \emph{plus} a set of delay factors (other cost measures may also be important: power consumption, heat production, area occupied, \textit{etc.}, but we will focus on the delay issue here). We will make the simplifying assumption that all gates have the same delay time, so we will measure the total delay of a circuit in terms of the number of gate delays required before the output values accurately reflect a change to the input values."><meta data-react-helmet="true" property="og:description" content="As noted above, a physical circuit does have some dependence on time, since each device in the circuit requires a non-zero time to respond to a change in its inputs. A more precise model needs to take these delays into account---a circuit is modeled by a Boolean expression \emph{plus} a set of delay factors (other cost measures may also be important: power consumption, heat production, area occupied, \textit{etc.}, but we will focus on the delay issue here). We will make the simplifying assumption that all gates have the same delay time, so we will measure the total delay of a circuit in terms of the number of gate delays required before the output values accurately reflect a change to the input values."><meta data-react-helmet="true" property="og:url" content="https://bhoward.github.io//focsipedia/docs/logic/simplify">

<link data-react-helmet="true" rel="shortcut icon" href="/focsipedia/img/favicon.ico">


<link rel="stylesheet" href="/focsipedia/styles.ac10d940.css">

</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}function e(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}var n=window.matchMedia("(prefers-color-scheme: dark)");n.addListener((function(n){null===e()&&t(n.matches?"dark":"")}));var a=e();null!==a?t(a):n.matches&&t("dark")}()</script>
<div id="__docusaurus">
<nav class="navbar navbar--light navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a aria-current="page" class="navbar__brand active" href="/focsipedia/"><img class="navbar__logo" src="/focsipedia/img/SmartFoxIcon.jpeg" alt="Smart Fox Logo"><strong>FoCSipedia</strong></a><a class="navbar__item navbar__link" href="/focsipedia/docs/topics">Topics</a><a class="navbar__item navbar__link" href="/focsipedia/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" target="_blank" rel="noopener noreferrer" href="https://github.com/bhoward/focsipedia">GitHub</a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_1gtM"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_keGJ moon_1gwN"></span></div><div class="react-toggle-track-x"><span class="toggle_keGJ sun_3CPA"></span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a aria-current="page" class="navbar__brand active" href="/focsipedia/"><img class="navbar__logo" src="/focsipedia/img/SmartFoxIcon.jpeg" alt="Smart Fox Logo"><strong>FoCSipedia</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/focsipedia/docs/topics">Topics</a></li><li class="menu__list-item"><a class="menu__link" href="/focsipedia/blog">Blog</a></li><li class="menu__list-item"><a class="menu__link" target="_blank" rel="noopener noreferrer" href="https://github.com/bhoward/focsipedia">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_1kjD"><div class="docSidebarContainer_1cYp"><div class="sidebar_1kLs"><div class="menu menu--responsive"><button aria-label="Open Menu" class="button button--secondary button--sm menu__button" type="button"><svg class="sidebarMenuIcon_2vk4" xmlns="http://www.w3.org/2000/svg" height="24" width="24" viewBox="0 0 32 32" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Course Info</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/focsipedia/docs/policies">Course Information and Policies</a></li><li class="menu__list-item"><a class="menu__link" href="/focsipedia/docs/topics">Topics</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">Logic</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/focsipedia/docs/logic/intro">Logic</a></li><li class="menu__list-item"><a class="menu__link" href="/focsipedia/docs/logic/props">Propositional Logic</a></li><li class="menu__list-item"><a class="menu__link" href="/focsipedia/docs/logic/boolean">Boolean Algebra</a></li><li class="menu__list-item"><a class="menu__link" href="/focsipedia/docs/logic/circuits">Logic Circuits</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active" href="/focsipedia/docs/logic/simplify">Circuit Simplification</a></li><li class="menu__list-item"><a class="menu__link" href="/focsipedia/docs/logic/components">Common Circuit Components</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Features</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/focsipedia/docs/reason">ReasonML</a></li><li class="menu__list-item"><a class="menu__link" href="/focsipedia/docs/styleGuide">Style Guide</a></li></ul></li></ul></div></div></div><main class="docMainContainer_FFX1"><div class="padding-vert--lg"><div class="container"><div class="row"><div class="col"><div class="docItemContainer_2cwg"><article><header><h1 class="docTitle_1vWb">Circuit Simplification</h1></header><div class="markdown"><p>As noted above, a physical circuit does have some dependence on time, since each device in the circuit requires a non-zero time to respond to a change in its inputs. A more precise model needs to take these delays into account---a circuit is modeled by a Boolean expression \emph{plus} a set of delay factors (other cost measures may also be important: power consumption, heat production, area occupied, \textit{etc.}, but we will focus on the delay issue here). We will make the simplifying assumption that all gates have the same delay time, so we will measure the total delay of a circuit in terms of the number of gate delays required before the output values accurately reflect a change to the input values.</p><p>Given a combinational circuit, we may compute the delay, also known as the \nw{span}, by finding the number of gates on the longest path (the \nw{critical path}) from an input to an output. For example, the circuit in Figure~\ref{F-labellc} has a span of three gate delays, with the critical path passing either through the \textsc{and}, \textsc{not}, \textsc{and} sequence along the top, or through the \textsc{not}, \textsc{or}, \textsc{and} along the bottom. Note that this is a conservative estimate of the delay required, although for certain inputs the output may become stable sooner---for example, if the <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em"></span><span class="mord mathdefault" style="margin-right:0.05017em">B</span></span></span></span></span> input changes from 0 to 1
while <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em"></span><span class="mord mathdefault">A</span></span></span></span></span> is 0, then after one gate delay the output of the \textsc{or} will become 1; since the output of the upper \textsc{not} was already 1 in this case (why?), the final output will settle at 1 after only two gate delays. However, other combinations of inputs may well take the entire three gate delays to correctly determine the value of the output.</p><p>One approach to reducing the delay of a circuit is to use the disjunctive normal form, also known as the \nw{sum-of-products} (see Definition~\ref{D-DNF}). Since an expression in DNF is the \textsc{or} of a collection of terms which are the \textsc{and} of some number of simple terms, and a simple term is either an input or a negated input, the corresponding circuit can be constructed in three layers:
\begin{center}
\includegraphics[width=!,height=!,scale=0.75]{graphics/DNFlayers.png}
\end{center}</p><p>An interesting property of the sum-of-products representation falls out of the De Morgan laws. Since <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mi>b</mi><mo stretchy="false">)</mo><mstyle mathcolor="#cc0000"><mtext>\OR</mtext></mstyle><mo stretchy="false">(</mo><mi>c</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mi>d</mi><mo stretchy="false">)</mo><mo>=</mo><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mo stretchy="false">(</mo><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mo stretchy="false">(</mo><mi>a</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mi>b</mi><mo stretchy="false">)</mo><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mo stretchy="false">(</mo><mi>c</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mi>d</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>a</mi><mo>↑</mo><mi>b</mi><mo stretchy="false">)</mo><mo>↑</mo><mo stretchy="false">(</mo><mi>c</mi><mo>↑</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a\AND b)\OR(c\AND d)=\NOT(\NOT(a\AND b)\AND\NOT(c\AND d))=(a\uparrow b)\uparrow(c\uparrow d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\OR</span></span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mopen">(</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">↑</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">↑</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">↑</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span></span>, the two layers of \textsc{and} and \textsc{or} gates may be replaced entirely with \textsc{nand} gates to get an equivalent circuit!
\begin{center}
\includegraphics[width=!,height=!,scale=0.75]{graphics/DNFlayersNand.png}
\end{center}</p><p>Unfortunately, this does not mean that any Boolean expression can be computed by a circuit with only three gate delays. One problem comes when we need \textsc{and} and \textsc{or} gates (or \textsc{nand} gates) with more than two inputs---in general, with <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em"></span><span class="mord mathdefault">n</span></span></span></span></span> input variables, there may be \textsc{and} gates that need <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em"></span><span class="mord mathdefault">n</span></span></span></span></span> inputs, and there could be on the order of <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span> gates in the \textsc{and} level, requiring an \textsc{or} gate with that many input lines. We will see in the next section how to build gates with a larger number of inputs out of gates with just two inputs.</p><p>Another problem with DNF comes if we use the full DNF expression extracted from a truth table.
If we use Theorem~\ref{T-DNF} to produce an expression from the truth table for the implication <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>→</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p\rightarrow q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em"></span><span class="mord mathdefault" style="margin-right:0.03588em">q</span></span></span></span></span>, we will get <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>p</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>q</mi><mo stretchy="false">)</mo><mstyle mathcolor="#cc0000"><mtext>\OR</mtext></mstyle><mo stretchy="false">(</mo><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>p</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mi>q</mi><mo stretchy="false">)</mo><mstyle mathcolor="#cc0000"><mtext>\OR</mtext></mstyle><mo stretchy="false">(</mo><mi>p</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\NOT p\AND\NOT q)\OR(\NOT p\AND q)\OR(p\AND q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord mathdefault">p</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord mathdefault" style="margin-right:0.03588em">q</span><span class="mclose">)</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\OR</span></span><span class="mopen">(</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord mathdefault">p</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord mathdefault" style="margin-right:0.03588em">q</span><span class="mclose">)</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\OR</span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord mathdefault" style="margin-right:0.03588em">q</span><span class="mclose">)</span></span></span></span></span>. We may use Boolean algebra identities to find an equivalent DNF expression, <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>p</mi><mstyle mathcolor="#cc0000"><mtext>\OR</mtext></mstyle><mi>q</mi></mrow><annotation encoding="application/x-tex">\NOT p\OR q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord mathdefault">p</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\OR</span></span><span class="mord mathdefault" style="margin-right:0.03588em">q</span></span></span></span></span> (which only needs two gate delays, since the \textsc{and} layer disappears). There are general techniques for finding simpler DNF expressions such as this; we will look at a straightforward technique called a \textit{Karnaugh map}, although for computer implementation the related Quine-McCluskey algorithm is better (and for large numbers of input variables a heuristic approach is necessary).</p><p>A Karnaugh map is a way of visualizing entries in a truth table so that adjacent entries only differ on the value of one input variable. For example, the entry for <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>p</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mi>q</mi></mrow><annotation encoding="application/x-tex">\NOT p\AND q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord mathdefault">p</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord mathdefault" style="margin-right:0.03588em">q</span></span></span></span></span> will be next to the entry for <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mi>q</mi></mrow><annotation encoding="application/x-tex">p\AND q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathdefault">p</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord mathdefault" style="margin-right:0.03588em">q</span></span></span></span></span>. If adjacent entries each contain 1, meaning that those terms would participate in the full DNF expression, then they may be replaced by a single term with just the variables that are the same: in the example, this corresponds to the simplification <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>p</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mi>q</mi><mo stretchy="false">)</mo><mstyle mathcolor="#cc0000"><mtext>\OR</mtext></mstyle><mo stretchy="false">(</mo><mi>p</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mi>q</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>p</mi><mstyle mathcolor="#cc0000"><mtext>\OR</mtext></mstyle><mi>p</mi><mo stretchy="false">)</mo><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mi>q</mi><mo>=</mo><mi mathvariant="double-struck">T</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mi>q</mi><mo>=</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">(\NOT p\AND q)\OR(p\AND q)=(\NOT p\OR p)\AND q=\T\AND q=q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord mathdefault">p</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord mathdefault" style="margin-right:0.03588em">q</span><span class="mclose">)</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\OR</span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord mathdefault" style="margin-right:0.03588em">q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord mathdefault">p</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\OR</span></span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord mathdefault" style="margin-right:0.03588em">q</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord"><span class="mord mathbb">T</span></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord mathdefault" style="margin-right:0.03588em">q</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em"></span><span class="mord mathdefault" style="margin-right:0.03588em">q</span></span></span></span></span>.</p><p>For two input variables, a Karnaugh map is a <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2\times 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em"></span><span class="mord">2</span></span></span></span></span> array:
[ \begin{array}{r|cc}
&amp; \NOT{q} &amp; q\ \hline
\NOT{p} &amp; x<em>{00} &amp; x</em>{01}\
p &amp; x<em>{10} &amp; x</em>{11}
\end{array} ]
This is just a compact rearrangement of the truth table:
[ \begin{array}{cc|c}
p &amp; q &amp; x\ \hline
0 &amp; 0 &amp; x<em>{00}\
0 &amp; 1 &amp; x</em>{01}\
1 &amp; 0 &amp; x<em>{10}\
1 &amp; 1 &amp; x</em>{11}
\end{array} ]
However, note that the adjacent cell condition is true: horizontally adjacent cells only differ on <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em"></span><span class="mord mathdefault" style="margin-right:0.03588em">q</span></span></span></span></span>, while vertically adjacent cells only differ on <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em"></span><span class="mord mathdefault">p</span></span></span></span></span>.</p><p>Once we have laid out the Karnaugh map, a simplified expression may be read off by finding a way to cover all of the 1&#x27;s in the map with ``implicants.&#x27;&#x27; An implicant is a rectangle whose side lengths are a power of 2; it corresponds to finding a collection of adjacent cells in the map (all of which contain 1) that all agree on some of the input literals and that collectively include all combinations (negated or not) of the other input variables. The resulting term for an implicant is just the product of the common literals among all the cells covered by the implicant.</p><p>On a <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2\times 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em"></span><span class="mord">2</span></span></span></span></span> map, the only implicants are individual cells (<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1\times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em"></span><span class="mord">1</span></span></span></span></span>), a row (<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">1\times 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em"></span><span class="mord">2</span></span></span></span></span>), a column (<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2\times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em"></span><span class="mord">1</span></span></span></span></span>), or the entire map (<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2\times 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em"></span><span class="mord">2</span></span></span></span></span>). The cells correspond to terms such as <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>q</mi></mrow><annotation encoding="application/x-tex">p\AND\NOT{q}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathdefault">p</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em">q</span></span></span></span></span></span>, the rows are either <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>p</mi></mrow><annotation encoding="application/x-tex">\NOT{p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord"><span class="mord mathdefault">p</span></span></span></span></span></span> or <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em"></span><span class="mord mathdefault">p</span></span></span></span></span>, the columns are either <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>q</mi></mrow><annotation encoding="application/x-tex">\NOT{q}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em">q</span></span></span></span></span></span> or <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em"></span><span class="mord mathdefault" style="margin-right:0.03588em">q</span></span></span></span></span>, and the entire map is <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em"></span><span class="mord">1</span></span></span></span></span> (the empty product). To get the simplest expression, we want to take the fewest number of the largest possible implicants that between them cover all of the 1&#x27;s in the map. Implicants may overlap, as long as all of (and only) the 1&#x27;s are covered by at least one implicant.</p><p>Here is the example again. First the truth table for <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>→</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p\rightarrow q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em"></span><span class="mord mathdefault" style="margin-right:0.03588em">q</span></span></span></span></span>:
[ \begin{array}{cc|c}
p &amp; q &amp; x\ \hline
0 &amp; 0 &amp; 1\
0 &amp; 1 &amp; 1\
1 &amp; 0 &amp; 0\
1 &amp; 1 &amp; 1
\end{array} ]
As a Karnaugh map, this is:
[ \begin{array}{r|cc}
&amp; \NOT{q} &amp; q\ \hline
\NOT{p} &amp; 1 &amp; 1\
p &amp; 0 &amp; 1
\end{array} ]
The best way to cover this map with implicants is to take the first row and the second column. That gives the simplified terms <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>p</mi></mrow><annotation encoding="application/x-tex">\NOT{p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord"><span class="mord mathdefault">p</span></span></span></span></span></span> and <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em"></span><span class="mord mathdefault" style="margin-right:0.03588em">q</span></span></span></span></span>, so the final simplified expression is <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>p</mi><mstyle mathcolor="#cc0000"><mtext>\OR</mtext></mstyle><mi>q</mi></mrow><annotation encoding="application/x-tex">\NOT{p}\OR q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord"><span class="mord mathdefault">p</span></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\OR</span></span><span class="mord mathdefault" style="margin-right:0.03588em">q</span></span></span></span></span>. Here is the map with the implicants outlined:
[ \begin{array}{r|cc}
&amp; \NOT{q} &amp; q\ \hline
\NOT{p} &amp; \tikzmark{left1}1 &amp; \tikzmark{left2}1\tikzmark{right1}\
p &amp; 0 &amp; 1\tikzmark{right2}
\end{array}
\DrawBox[blue]{left1}{right1}
\DrawBox[red]{left2}{right2} ]</p><p>A Karnaugh map can also work with three or four input variables, producing either a <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>×</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">2\times 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em"></span><span class="mord">4</span></span></span></span></span> or a <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>×</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">4\times 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em"></span><span class="mord">4</span></span></span></span></span> array. The same procedure applies, with three complications:
\begin{enumerate}
\item To satisfy the adjacent cell condition, successive rows or columns must change only one variable at a time: for example, the rows might be labelled in order <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>p</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>q</mi></mrow><annotation encoding="application/x-tex">\NOT{p}\AND\NOT{q}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord"><span class="mord mathdefault">p</span></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em">q</span></span></span></span></span></span>, <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>p</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mi>q</mi></mrow><annotation encoding="application/x-tex">\NOT{p}\AND q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord"><span class="mord mathdefault">p</span></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord mathdefault" style="margin-right:0.03588em">q</span></span></span></span></span>, <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mi>q</mi></mrow><annotation encoding="application/x-tex">p\AND q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathdefault">p</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord mathdefault" style="margin-right:0.03588em">q</span></span></span></span></span>, and <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>q</mi></mrow><annotation encoding="application/x-tex">p\NOT{q}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathdefault">p</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em">q</span></span></span></span></span></span>;
\item Implicants may be 1, 2, or 4 rows tall by 1, 2, or 4 columns wide; and
\item Implicants may ``wrap around&#x27;&#x27; from one side of the map to the other.
\end{enumerate}
For example, on a <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>×</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">4\times 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em"></span><span class="mord">4</span></span></span></span></span> map, one possible implicant is the middle two rows; another is the leftmost and rightmost columns (wrapping horizontally); a third is the <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2\times 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em"></span><span class="mord">2</span></span></span></span></span> block consisting of the middle two elements of the top row and the middle two elements of the bottom row (wrapping vertically); a final example is the last two elements of the third row. See Figure~\ref{fig:KarnaughImplicants} for these examples.</p><p>\begin{figure}
Middle two rows (<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em"></span><span class="mord mathdefault" style="margin-right:0.03588em">q</span></span></span></span></span>):
[ \begin{array}{r|cccc}
&amp; \NOT{r}\AND\NOT{s} &amp; \NOT{r}\AND s &amp; r\AND s &amp; r\AND\NOT{s}\ \hline
\NOT{p}\AND\NOT{q} &amp; &amp; &amp; &amp; \
\NOT{p}\AND q &amp; \tikzmark{left1}1 &amp; 1 &amp; 1 &amp; 1\
p\AND q &amp; 1 &amp; 1 &amp; 1 &amp; 1\tikzmark{right1}\
p\AND\NOT{q} &amp; &amp; &amp; &amp;
\end{array}
\DrawBox[blue]{left1}{right1} ]</p><p>Leftmost and rightmost columns (<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>s</mi></mrow><annotation encoding="application/x-tex">\NOT{s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord"><span class="mord mathdefault">s</span></span></span></span></span></span>):
[ \begin{array}{r|cccc}
&amp; \NOT{r}\AND\NOT{s} &amp; \NOT{r}\AND s &amp; r\AND s &amp; r\AND\NOT{s}\ \hline
\NOT{p}\AND\NOT{q} &amp; \tikzmark{left1}1 &amp; &amp; &amp; \tikzmark{left2}1\
\NOT{p}\AND q &amp; 1 &amp; &amp; &amp; 1\
p\AND q &amp; 1 &amp; &amp; &amp; 1\
p\AND\NOT{q} &amp; 1\tikzmark{right1} &amp; &amp; &amp; 1\tikzmark{right2}
\end{array}
\DrawBoxW[blue]{left1}{right1}
\DrawBoxE[blue]{left2}{right2} ]</p><p>Middle elements of top and bottom rows (<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>q</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\NOT{q}s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em">q</span></span><span class="mord mathdefault">s</span></span></span></span></span>):
[ \begin{array}{r|cccc}
&amp; \NOT{r}\AND\NOT{s} &amp; \NOT{r}\AND s &amp; r\AND s &amp; r\AND\NOT{s}\ \hline
\NOT{p}\AND\NOT{q} &amp; &amp; \tikzmark{left1}1 &amp; 1\tikzmark{right1} &amp; \
\NOT{p}\AND q &amp; &amp; &amp; &amp;\
p\AND q &amp; &amp; &amp; &amp;\
p\AND\NOT{q} &amp; &amp; \tikzmark{left2}1 &amp; 1\tikzmark{right2} &amp;
\end{array}
\DrawBoxN[blue]{left1}{right1}
\DrawBoxS[blue]{left2}{right2} ]</p><p>Last two elements of the third row (<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>q</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">pqr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.03588em">q</span><span class="mord mathdefault" style="margin-right:0.02778em">r</span></span></span></span></span>):
[ \begin{array}{r|cccc}
&amp; \NOT{r}\AND\NOT{s} &amp; \NOT{r}\AND s &amp; r\AND s &amp; r\AND\NOT{s}\ \hline
\NOT{p}\AND\NOT{q} &amp; &amp; &amp; &amp; \
\NOT{p}\AND q &amp; &amp; &amp; &amp;\
p\AND q &amp; &amp; &amp; \tikzmark{left1}1 &amp; 1\tikzmark{right1}\
p\AND\NOT{q} &amp; &amp; &amp; &amp;
\end{array}
\DrawBox[blue]{left1}{right1} ]
\caption{Some examples of Karnaugh map implicants}
\label{fig:KarnaughImplicants}
\end{figure}</p><p>A Karnaugh map also allows us to find simple circuits in the case that some combinations of inputs will never occur, so that we do not care what the output is in those rows of the truth table. By entering a \nw{don&#x27;t care} value, such as X, in the map, we have the freedom to either ignore or include those cells when covering the map with implicants; by including a cell with an X along with a group of 1&#x27;s, we might be able to construct a larger (and hence simpler) implicant.</p><p>For example, suppose we have the following truth table for a four-variable Boolean expression (this represents the inputs that are binary numbers less than ten and divisible by three):
[ \begin{array}{cccc|c}
p &amp; q &amp; r &amp; s &amp; x\ \hline
0 &amp; 0 &amp; 0 &amp; 0 &amp; 1\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 0\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 0\
0 &amp; 0 &amp; 1 &amp; 1 &amp; 1\
0 &amp; 1 &amp; 0 &amp; 0 &amp; 0\
0 &amp; 1 &amp; 0 &amp; 1 &amp; 0\
0 &amp; 1 &amp; 1 &amp; 0 &amp; 1\
0 &amp; 1 &amp; 1 &amp; 1 &amp; 0\
1 &amp; 0 &amp; 0 &amp; 0 &amp; 0\
1 &amp; 0 &amp; 0 &amp; 1 &amp; 1\
1 &amp; 0 &amp; 1 &amp; 0 &amp; X\
1 &amp; 0 &amp; 1 &amp; 1 &amp; X\
1 &amp; 1 &amp; 0 &amp; 0 &amp; X\
1 &amp; 1 &amp; 0 &amp; 1 &amp; X\
1 &amp; 1 &amp; 1 &amp; 0 &amp; X\
1 &amp; 1 &amp; 1 &amp; 1 &amp; X
\end{array} ]
As a Karnaugh map, this is:
[ \begin{array}{r|cccc}
&amp; \NOT{r}\AND\NOT{s} &amp; \NOT{r}\AND s &amp; r\AND s &amp; r\AND\NOT{s}\ \hline
\NOT{p}\AND\NOT{q} &amp; 1 &amp; 0 &amp; 1 &amp; 0\
\NOT{p}\AND q &amp; 0 &amp; 0 &amp; 0 &amp; 1\
p\AND q &amp; X &amp; X &amp; X &amp; X\
p\AND\NOT{q} &amp; 0 &amp; 1 &amp; X &amp; X
\end{array} ]
The 1&#x27;s, plus some of the X&#x27;s, may be covered by four implicants: <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>p</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>q</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>r</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>s</mi></mrow><annotation encoding="application/x-tex">\NOT{p}\AND\NOT{q}\AND\NOT{r}\AND\NOT{s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord"><span class="mord mathdefault">p</span></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em">q</span></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em">r</span></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord"><span class="mord mathdefault">s</span></span></span></span></span></span>, <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>q</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mi>r</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mi>s</mi></mrow><annotation encoding="application/x-tex">\NOT{q}\AND r\AND s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em">q</span></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord mathdefault" style="margin-right:0.02778em">r</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord mathdefault">s</span></span></span></span></span>, <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mi>r</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>s</mi></mrow><annotation encoding="application/x-tex">q\AND r\AND\NOT{s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathdefault" style="margin-right:0.03588em">q</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord mathdefault" style="margin-right:0.02778em">r</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord"><span class="mord mathdefault">s</span></span></span></span></span></span>, and <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mi>s</mi></mrow><annotation encoding="application/x-tex">p\AND s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathdefault">p</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord mathdefault">s</span></span></span></span></span>. Note that the second implicant wraps around from the third cell on the top row to the third cell (with an X, which is also covered by the <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mi>s</mi></mrow><annotation encoding="application/x-tex">p\AND s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathdefault">p</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord mathdefault">s</span></span></span></span></span> implicant) on the bottom row; if it were just the 1 on the top row, then the term would be <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>p</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>q</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mi>r</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mi>s</mi></mrow><annotation encoding="application/x-tex">\NOT{p}\AND\NOT{q}\AND r\AND s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord"><span class="mord mathdefault">p</span></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em">q</span></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord mathdefault" style="margin-right:0.02778em">r</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord mathdefault">s</span></span></span></span></span>, which is not as simple. Here are the cells that end up being covered:
[ \begin{array}{r|cccc}
&amp; \NOT{r}\AND\NOT{s} &amp; \NOT{r}\AND s &amp; r\AND s &amp; r\AND\NOT{s}\ \hline
\NOT{p}\AND\NOT{q} &amp; \tikzmark{left1}1\tikzmark{right1} &amp; 0 &amp; \tikzmark{left2a}1\tikzmark{right2a} &amp; 0\
\NOT{p}\AND q &amp; 0 &amp; 0 &amp; 0 &amp; \tikzmark{left3}1\
p\AND q &amp; X &amp; \tikzmark{left4}X &amp; X &amp; X\tikzmark{right3}\
p\AND\NOT{q} &amp; 0 &amp; 1 &amp; \tikzmark{left2b}X\tikzmark{right2b}\tikzmark{right4} &amp; X
\end{array}
\DrawBox[blue]{left1}{right1}
\DrawBoxN[red,rounded corners=3pt]{left2a}{right2a}
\DrawBoxS[red,rounded corners=3pt]{left2b}{right2b}
\DrawBox[green]{left3}{right3}
\DrawBox[purple]{left4}{right4} ]
Therefore, the simplified expression is <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>p</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>q</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>r</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>s</mi><mo stretchy="false">)</mo><mstyle mathcolor="#cc0000"><mtext>\OR</mtext></mstyle><mo stretchy="false">(</mo><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>q</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mi>r</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mi>s</mi><mo stretchy="false">)</mo><mstyle mathcolor="#cc0000"><mtext>\OR</mtext></mstyle><mo stretchy="false">(</mo><mi>q</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mi>r</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>s</mi><mo stretchy="false">)</mo><mstyle mathcolor="#cc0000"><mtext>\OR</mtext></mstyle><mo stretchy="false">(</mo><mi>p</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\NOT{p}\AND\NOT{q}\AND\NOT{r}\AND\NOT{s})\OR(\NOT{q}\AND r\AND s)\OR(q\AND r\AND\NOT{s})\OR(p\AND s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord"><span class="mord mathdefault">p</span></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em">q</span></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em">r</span></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord"><span class="mord mathdefault">s</span></span><span class="mclose">)</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\OR</span></span><span class="mopen">(</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em">q</span></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord mathdefault" style="margin-right:0.02778em">r</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord mathdefault">s</span><span class="mclose">)</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\OR</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em">q</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord mathdefault" style="margin-right:0.02778em">r</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord"><span class="mord mathdefault">s</span></span><span class="mclose">)</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\OR</span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span></span></span>. This may be computed by the following circuit:
\begin{center}
\includegraphics[width=!,height=!,scale=0.75]{graphics/KarnaughExample.png}
\end{center}
In the next section, we will see how to implement this with a total delay of 5, using only two-input \textsc{and} and \textsc{or} gates.</p><p>The final difficulty with building low-delay circuits from DNF expressions is that, even with the simplification provided by something like a Karnaugh map, many Boolean functions lead to an exponential blowup when expressed in DNF. In the worst case, an expression with <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em"></span><span class="mord mathdefault">n</span></span></span></span></span> input variables may require <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathdefault" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> terms in a sum-of-product representation---consider the case of a Karnaugh map where the 1&#x27;s are in a checkerboard arrangement, so that none are adjacent. When <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em"></span><span class="mord mathdefault">n</span></span></span></span></span> is large enough, it might not even be practical to consider the truth table at all; for example, a circuit that can add two 32-bit numbers requires 64 input lines, which would lead to a truth table with <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup><mo>≈</mo><mn>1</mn><msup><mn>0</mn><mn>19</mn></msup></mrow><annotation encoding="application/x-tex">2^{64}\approx 10^{19}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></span></span> entries. The next section will also discuss approaches to this kind of problem.</p><p>\begin{exercises}
\problem For each of the following Boolean expressions, compute the total delay of the direct translation of the expression into a circuit.
\ppart <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mrow><mo stretchy="false">(</mo><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>p</mi><mstyle mathcolor="#cc0000"><mtext>\OR</mtext></mstyle><mi>q</mi><mo stretchy="false">)</mo></mrow><mstyle mathcolor="#cc0000"><mtext>\OR</mtext></mstyle><mo stretchy="false">(</mo><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mrow><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>q</mi></mrow><mstyle mathcolor="#cc0000"><mtext>\OR</mtext></mstyle><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\NOT{(\NOT{p}\OR q)}\OR(\NOT{\NOT{q}}\OR\NOT{p})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord"><span class="mopen">(</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord"><span class="mord mathdefault">p</span></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\OR</span></span><span class="mord mathdefault" style="margin-right:0.03588em">q</span><span class="mclose">)</span></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\OR</span></span><span class="mopen">(</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord"><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em">q</span></span></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\OR</span></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord"><span class="mord mathdefault">p</span></span><span class="mclose">)</span></span></span></span></span>
\ppart <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mo stretchy="false">(</mo><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>r</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mi>p</mi><mo stretchy="false">)</mo><mstyle mathcolor="#cc0000"><mtext>\OR</mtext></mstyle><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>q</mi><mo stretchy="false">)</mo><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mo stretchy="false">(</mo><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mo stretchy="false">(</mo><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>r</mi><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mi>q</mi><mo stretchy="false">)</mo><mstyle mathcolor="#cc0000"><mtext>\OR</mtext></mstyle><mstyle mathcolor="#cc0000"><mtext>\NOT</mtext></mstyle><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\NOT(\NOT{r}\AND p)\OR\NOT{q})\AND(\NOT(\NOT{r}\AND q)\OR\NOT{p})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mopen">(</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em">r</span></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\OR</span></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em">q</span></span><span class="mclose">)</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mopen">(</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mopen">(</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em">r</span></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mord mathdefault" style="margin-right:0.03588em">q</span><span class="mclose">)</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\OR</span></span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\NOT</span></span><span class="mord"><span class="mord mathdefault">p</span></span><span class="mclose">)</span></span></span></span></span>
\ppart <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>p</mi><mstyle mathcolor="#cc0000"><mtext>\OR</mtext></mstyle><mi>q</mi><mo stretchy="false">)</mo><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mo stretchy="false">(</mo><mi>q</mi><mstyle mathcolor="#cc0000"><mtext>\OR</mtext></mstyle><mi>r</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mo stretchy="false">(</mo><mi>r</mi><mstyle mathcolor="#cc0000"><mtext>\OR</mtext></mstyle><mi>s</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>p</mi><mstyle mathcolor="#cc0000"><mtext>\OR</mtext></mstyle><mi>r</mi><mo stretchy="false">)</mo><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mo stretchy="false">(</mo><mi>q</mi><mstyle mathcolor="#cc0000"><mtext>\OR</mtext></mstyle><mi>s</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mstyle mathcolor="#cc0000"><mtext>\AND</mtext></mstyle><mo stretchy="false">(</mo><mi>p</mi><mstyle mathcolor="#cc0000"><mtext>\OR</mtext></mstyle><mi>s</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(((p\OR q)\AND(q\OR r))\AND(r\OR s))\AND(((p\OR r)\AND(q\OR s))\AND(p\OR s))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\OR</span></span><span class="mord mathdefault" style="margin-right:0.03588em">q</span><span class="mclose">)</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em">q</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\OR</span></span><span class="mord mathdefault" style="margin-right:0.02778em">r</span><span class="mclose">)</span><span class="mclose">)</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em">r</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\OR</span></span><span class="mord mathdefault">s</span><span class="mclose">)</span><span class="mclose">)</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mopen">(</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\OR</span></span><span class="mord mathdefault" style="margin-right:0.02778em">r</span><span class="mclose">)</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em">q</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\OR</span></span><span class="mord mathdefault">s</span><span class="mclose">)</span><span class="mclose">)</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\AND</span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mord text" style="color:#cc0000"><span class="mord" style="color:#cc0000">\OR</span></span><span class="mord mathdefault">s</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><p>\problem For each of the expressions in the previous problem, use a Karnaugh map to find an equivalent sum-of-products expression, and draw the resulting circuit.</p><p>\problem Suppose we want to build a counter that cycles through the numbers 0, 1, 2, 3, 4, and back to 0. One element of this counter will be a circuit that takes the current number, expressed in binary, and outputs the next number. Here is the truth table for this function, with three inputs (<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em"></span><span class="mord mathdefault">a</span></span></span></span></span>, <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em"></span><span class="mord mathdefault">b</span></span></span></span></span>, and <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em"></span><span class="mord mathdefault">c</span></span></span></span></span>) and three outputs (<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em"></span><span class="mord mathdefault">x</span></span></span></span></span>, <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em"></span><span class="mord mathdefault" style="margin-right:0.03588em">y</span></span></span></span></span>, and <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em"></span><span class="mord mathdefault" style="margin-right:0.04398em">z</span></span></span></span></span>):
[ \begin{array}{ccc|ccc}
a &amp; b &amp; c &amp; x &amp; y &amp; z\ \hline
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0\
0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1\
0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0\
1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\
1 &amp; 0 &amp; 1 &amp; X &amp; X &amp; X\
1 &amp; 1 &amp; 0 &amp; X &amp; X &amp; X\
1 &amp; 1 &amp; 1 &amp; X &amp; X &amp; X\
\end{array} ]
Since the counter should never reach numbers 5, 6, or 7, we do not care about the output when <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">abc</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault">c</span></span></span></span></span> is 101, 110, or 111. Use Karnaugh maps to find a simple circuit for this function.</p><p>\problem\label{ex:BCD}In binary-coded decimal (BCD), four bits are used to represent the numbers 0 (0000) through 9 (1001); the other six bit patterns (1010 through 1111) are unused. BCD is often used in circuits where decimal numbers need to be displayed; a common device for doing so is the \nw{seven-segment display}. Using only seven elements (for example, light-emitting diodes), we may form a reasonable approximation of all the digits 0--9: \textifsym{0123456789}. Construct a truth table with four inputs and seven outputs showing how to produce these characters from input in BCD (be sure to include a diagram indicating which output column corresponds to which display element). Use Karnaugh maps to design a relatively simple circuit that implements a seven-segment decoder.</p><p>\problem Exercise~\ref{ex:CNF} of Section~\ref{S-logic-3} examines conjunctive normal form (CNF), the dual of DNF. Explore what kind of circuits result from CNF, and how to extract a simplified CNF expression from a Karnaugh map \textit{(Hint: look at blocks of 0&#x27;s.)}.</p><p>\end{exercises}</p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/bhoward/focsipedia/edit/master/docs/logic/simplify.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 40 40" style="margin-right:0.3em;vertical-align:sub"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/focsipedia/docs/logic/circuits"><h5 class="pagination-nav__link--sublabel">Previous</h5><h4 class="pagination-nav__link--label">« Logic Circuits</h4></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/focsipedia/docs/logic/components"><h5 class="pagination-nav__link--sublabel">Next</h5><h4 class="pagination-nav__link--label">Common Circuit Components »</h4></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_TbNY"></div></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Docs</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/focsipedia/docs/policies">Policies</a></li><li class="footer__item"><a class="footer__link-item" href="/focsipedia/docs/styleGuide">Style Guide</a></li><li class="footer__item"><a class="footer__link-item" href="/focsipedia/docs/attribution">Attribution</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Social</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/focsipedia/blog">Blog</a></li><li class="footer__item"><a class="footer__link-item" target="_blank" rel="noopener noreferrer" href="https://github.com/bhoward/focsipedia">GitHub</a></li><li class="footer__item"><a class="footer__link-item" target="_blank" rel="noopener noreferrer" href="https://twitter.com/BrnHwrd">Twitter</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Blog Feed</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/focsipedia/blog/rss.xml">RSS</a></li><li class="footer__item"><a class="footer__link-item" href="/focsipedia/blog/atom.xml">Atom</a></li></ul></div></div><div class="text--center">Copyright © 2020 Brian T. Howard. Built with Docusaurus.</div></div></footer>
</div>

<script src="/focsipedia/styles.b4e8f6dd.js"></script>

<script src="/focsipedia/runtime~main.d74a9924.js"></script>

<script src="/focsipedia/main.f6d4239c.js"></script>

<script src="/focsipedia/1.82a1e9b8.js"></script>

<script src="/focsipedia/2.8f5451b7.js"></script>

<script src="/focsipedia/1be78505.f15a3423.js"></script>

<script src="/focsipedia/90510764.c80e0bb1.js"></script>

<script src="/focsipedia/17896441.f20a9f39.js"></script>

<script src="/focsipedia/d30a9835.e2874c0e.js"></script>


</body>
</html>