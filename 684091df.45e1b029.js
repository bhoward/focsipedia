(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{162:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return p})),a.d(t,"metadata",(function(){return c})),a.d(t,"rightToc",(function(){return m})),a.d(t,"default",(function(){return i}));var n=a(1),s=a(6),r=(a(0),a(252)),p={id:"parser-comb",title:"Recursive Descent and Parser Combinators"},c={id:"fp/parser-comb",isDocsHomePage:!1,title:"Recursive Descent and Parser Combinators",description:"It is particularly easy to turn an LL(1) grammar into an efficient parser",source:"@site/docs/fp/parser-comb.md",permalink:"/focsipedia/docs/fp/parser-comb",editUrl:"https://github.com/bhoward/focsipedia/edit/master/docs/fp/parser-comb.md",sidebar:"someSidebar",previous:{title:"State Machines in Java and ReasonML",permalink:"/focsipedia/docs/fp/state"},next:{title:"Lambda Calculus",permalink:"/focsipedia/docs/fp/lambda"}},m=[{value:"Parser Combinators",id:"parser-combinators",children:[]}],b={rightToc:m};function i(e){var t=e.components,a=Object(s.a)(e,["components"]);return Object(r.b)("wrapper",Object(n.a)({},b,a,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"It is particularly easy to turn an LL(1) grammar into an efficient parser\nusing the technique of ",Object(r.b)("strong",{parentName:"p"},"recursive descent parsing"),". For each non-terminal in\nthe grammar, we write a function that recognizes strings produced from that\nnon-terminal. If there are multiple productions for the non-terminal, we use\nthe next available character to decide which one to use. To parse the right-hand\nside of the chosen production rule, we have to recognize a sequence of terminals\nand non-terminals in order. To recognize a terminal, we just check that the current\ncharacter from the input matches the expected symbol. To recognize a non-terminal,\nwe call the associated function for that non-terminal."),Object(r.b)("p",null,"Therefore, our parser will be a set of mutually recursive functions, one for each\nnon-terminal. To parse a word in the language, we call the function corresponding\nto the starting non-terminal; if that function returns without error, then we have\nsuccessfully matched a word. In addition to recognizing a string of characters, it\nis common for each recursive descent parsing function to return a data structure\n(the parse tree, or a close relative known as an ",Object(r.b)("strong",{parentName:"p"},"abstract syntax tree"),") representing\nthe input that was parsed."),Object(r.b)("p",null,"Here is code for a recursive descent parser in Java, corresponding to the following\ngrammar (expressed here in ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"../lang/bnf"}),"Backus-Naur form"),"; it is very similar\nto the example ",Object(r.b)("span",Object(n.a)({parentName:"p"},{className:"math math-inline"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(r.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(r.b)("semantics",{parentName:"math"},Object(r.b)("mrow",{parentName:"semantics"},Object(r.b)("msub",{parentName:"mrow"},Object(r.b)("mi",{parentName:"msub"},"G"),Object(r.b)("mn",{parentName:"msub"},"2"))),Object(r.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"G_2")))),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.83333em",verticalAlign:"-0.15em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathdefault"}),"G"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"msupsub"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-t vlist-t2"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-r"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"vlist",style:{height:"0.30110799999999993em"}}),Object(r.b)("span",Object(n.a)({parentName:"span"},{style:{top:"-2.5500000000000003em",marginLeft:"0em",marginRight:"0.05em"}}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"pstrut",style:{height:"2.7em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"sizing reset-size6 size3 mtight"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord mtight"}),"2")))),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-s"}),"\u200b")),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-r"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"vlist",style:{height:"0.15em"}}),Object(r.b)("span",{parentName:"span"}))))))))))," discussed in the ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"../lang/parsing"}),"parsing")," section):"),Object(r.b)("div",{className:"math math-display"},Object(r.b)("span",Object(n.a)({parentName:"div"},{className:"katex-display"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(r.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(r.b)("semantics",{parentName:"math"},Object(r.b)("mtable",Object(n.a)({parentName:"semantics"},{rowspacing:"0.24999999999999992em",columnalign:"right left",columnspacing:"0em"}),Object(r.b)("mtr",{parentName:"mtable"},Object(r.b)("mtd",{parentName:"mtr"},Object(r.b)("mstyle",Object(n.a)({parentName:"mtd"},{scriptlevel:"0",displaystyle:"true"}),Object(r.b)("mrow",{parentName:"mstyle"},Object(r.b)("mo",Object(n.a)({parentName:"mrow"},{stretchy:"false"}),"\u27e8"),Object(r.b)("mtext",Object(n.a)({parentName:"mrow"},{mathvariant:"italic"}),"Expr"),Object(r.b)("mo",Object(n.a)({parentName:"mrow"},{stretchy:"false"}),"\u27e9"),Object(r.b)("mtext",{parentName:"mrow"},"\xa0")))),Object(r.b)("mtd",{parentName:"mtr"},Object(r.b)("mstyle",Object(n.a)({parentName:"mtd"},{scriptlevel:"0",displaystyle:"true"}),Object(r.b)("mrow",{parentName:"mstyle"},Object(r.b)("mrow",{parentName:"mrow"}),Object(r.b)("mo",{parentName:"mrow"},":"),Object(r.b)("mo",{parentName:"mrow"},":"),Object(r.b)("mo",{parentName:"mrow"},"="),Object(r.b)("mtext",{parentName:"mrow"},"\xa0"),Object(r.b)("mo",Object(n.a)({parentName:"mrow"},{stretchy:"false"}),"\u27e8"),Object(r.b)("mtext",Object(n.a)({parentName:"mrow"},{mathvariant:"italic"}),"Term"),Object(r.b)("mo",Object(n.a)({parentName:"mrow"},{stretchy:"false"}),"\u27e9"),Object(r.b)("mtext",{parentName:"mrow"},"\xa0"),Object(r.b)("mo",Object(n.a)({parentName:"mrow"},{stretchy:"false"}),"["),Object(r.b)("mtext",{parentName:"mrow"},"\xa0"),Object(r.b)("mo",Object(n.a)({parentName:"mrow"},{stretchy:"false"}),"("),Object(r.b)("mtext",{parentName:"mrow"},"\xa0"),Object(r.b)("mo",{parentName:"mrow"},"+"),Object(r.b)("mtext",{parentName:"mrow"},"\xa0"),Object(r.b)("mi",Object(n.a)({parentName:"mrow"},{mathvariant:"normal"}),"\u2223"),Object(r.b)("mtext",{parentName:"mrow"},"\xa0"),Object(r.b)("mo",{parentName:"mrow"},"\u2212"),Object(r.b)("mtext",{parentName:"mrow"},"\xa0"),Object(r.b)("mo",Object(n.a)({parentName:"mrow"},{stretchy:"false"}),")"),Object(r.b)("mtext",{parentName:"mrow"},"\xa0"),Object(r.b)("mo",Object(n.a)({parentName:"mrow"},{stretchy:"false"}),"\u27e8"),Object(r.b)("mtext",Object(n.a)({parentName:"mrow"},{mathvariant:"italic"}),"Term"),Object(r.b)("mo",Object(n.a)({parentName:"mrow"},{stretchy:"false"}),"\u27e9"),Object(r.b)("mtext",{parentName:"mrow"},"\xa0"),Object(r.b)("mo",Object(n.a)({parentName:"mrow"},{stretchy:"false"}),"]"),Object(r.b)("mo",{parentName:"mrow"},"\u2026"))))),Object(r.b)("mtr",{parentName:"mtable"},Object(r.b)("mtd",{parentName:"mtr"},Object(r.b)("mstyle",Object(n.a)({parentName:"mtd"},{scriptlevel:"0",displaystyle:"true"}),Object(r.b)("mrow",{parentName:"mstyle"},Object(r.b)("mo",Object(n.a)({parentName:"mrow"},{stretchy:"false"}),"\u27e8"),Object(r.b)("mtext",Object(n.a)({parentName:"mrow"},{mathvariant:"italic"}),"Term"),Object(r.b)("mo",Object(n.a)({parentName:"mrow"},{stretchy:"false"}),"\u27e9"),Object(r.b)("mtext",{parentName:"mrow"},"\xa0")))),Object(r.b)("mtd",{parentName:"mtr"},Object(r.b)("mstyle",Object(n.a)({parentName:"mtd"},{scriptlevel:"0",displaystyle:"true"}),Object(r.b)("mrow",{parentName:"mstyle"},Object(r.b)("mrow",{parentName:"mrow"}),Object(r.b)("mo",{parentName:"mrow"},":"),Object(r.b)("mo",{parentName:"mrow"},":"),Object(r.b)("mo",{parentName:"mrow"},"="),Object(r.b)("mtext",{parentName:"mrow"},"\xa0"),Object(r.b)("mo",Object(n.a)({parentName:"mrow"},{stretchy:"false"}),"\u27e8"),Object(r.b)("mtext",Object(n.a)({parentName:"mrow"},{mathvariant:"italic"}),"Factor"),Object(r.b)("mo",Object(n.a)({parentName:"mrow"},{stretchy:"false"}),"\u27e9"),Object(r.b)("mtext",{parentName:"mrow"},"\xa0"),Object(r.b)("mo",Object(n.a)({parentName:"mrow"},{stretchy:"false"}),"["),Object(r.b)("mtext",{parentName:"mrow"},"\xa0"),Object(r.b)("mo",Object(n.a)({parentName:"mrow"},{stretchy:"false"}),"("),Object(r.b)("mtext",{parentName:"mrow"},"\xa0"),Object(r.b)("mo",{parentName:"mrow"},"\u2217"),Object(r.b)("mtext",{parentName:"mrow"},"\xa0"),Object(r.b)("mi",Object(n.a)({parentName:"mrow"},{mathvariant:"normal"}),"\u2223"),Object(r.b)("mtext",{parentName:"mrow"},"\xa0"),Object(r.b)("mi",Object(n.a)({parentName:"mrow"},{mathvariant:"normal"}),"/"),Object(r.b)("mtext",{parentName:"mrow"},"\xa0"),Object(r.b)("mo",Object(n.a)({parentName:"mrow"},{stretchy:"false"}),")"),Object(r.b)("mtext",{parentName:"mrow"},"\xa0"),Object(r.b)("mo",Object(n.a)({parentName:"mrow"},{stretchy:"false"}),"\u27e8"),Object(r.b)("mtext",Object(n.a)({parentName:"mrow"},{mathvariant:"italic"}),"Factor"),Object(r.b)("mo",Object(n.a)({parentName:"mrow"},{stretchy:"false"}),"\u27e9"),Object(r.b)("mtext",{parentName:"mrow"},"\xa0"),Object(r.b)("mo",Object(n.a)({parentName:"mrow"},{stretchy:"false"}),"]"),Object(r.b)("mo",{parentName:"mrow"},"\u2026"))))),Object(r.b)("mtr",{parentName:"mtable"},Object(r.b)("mtd",{parentName:"mtr"},Object(r.b)("mstyle",Object(n.a)({parentName:"mtd"},{scriptlevel:"0",displaystyle:"true"}),Object(r.b)("mrow",{parentName:"mstyle"},Object(r.b)("mo",Object(n.a)({parentName:"mrow"},{stretchy:"false"}),"\u27e8"),Object(r.b)("mtext",Object(n.a)({parentName:"mrow"},{mathvariant:"italic"}),"Factor"),Object(r.b)("mo",Object(n.a)({parentName:"mrow"},{stretchy:"false"}),"\u27e9"),Object(r.b)("mtext",{parentName:"mrow"},"\xa0")))),Object(r.b)("mtd",{parentName:"mtr"},Object(r.b)("mstyle",Object(n.a)({parentName:"mtd"},{scriptlevel:"0",displaystyle:"true"}),Object(r.b)("mrow",{parentName:"mstyle"},Object(r.b)("mrow",{parentName:"mrow"}),Object(r.b)("mo",{parentName:"mrow"},":"),Object(r.b)("mo",{parentName:"mrow"},":"),Object(r.b)("mo",{parentName:"mrow"},"="),Object(r.b)("mtext",{parentName:"mrow"},"\xa0ident\xa0"),Object(r.b)("mi",Object(n.a)({parentName:"mrow"},{mathvariant:"normal"}),"\u2223"),Object(r.b)("mtext",{parentName:"mrow"},"\xa0num\xa0"),Object(r.b)("mi",Object(n.a)({parentName:"mrow"},{mathvariant:"normal"}),"\u2223"),Object(r.b)("mtext",{parentName:"mrow"},"\xa0\u201c(\u201d\xa0"),Object(r.b)("mo",Object(n.a)({parentName:"mrow"},{stretchy:"false"}),"\u27e8"),Object(r.b)("mtext",Object(n.a)({parentName:"mrow"},{mathvariant:"italic"}),"Expr"),Object(r.b)("mo",Object(n.a)({parentName:"mrow"},{stretchy:"false"}),"\u27e9"),Object(r.b)("mtext",{parentName:"mrow"},"\xa0\u201c)\u201d")))))),Object(r.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"\\begin{aligned} \\langle\\textit{Expr}\\rangle\\ &::=\\ \\langle\\textit{Term}\\rangle\\ [\\ (\\ +\\ |\\ -\\ )\\ \\langle\\textit{Term}\\rangle\\ ]\\ldots\\\\ \\langle\\textit{Term}\\rangle\\ &::=\\ \\langle\\textit{Factor}\\rangle\\ [\\ (\\ *\\ |\\ /\\ )\\ \\langle\\textit{Factor}\\rangle\\ ]\\ldots\\\\ \\langle\\textit{Factor}\\rangle\\ &::=\\ \\textrm{ident}\\ |\\ \\textrm{num}\\ |\\ \\textrm{``(''}\\ \\langle\\textit{Expr}\\rangle\\ \\textrm{``)''} \\end{aligned}")))),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"4.500000000000002em",verticalAlign:"-2.000000000000001em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mtable"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"col-align-r"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-t vlist-t2"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-r"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"vlist",style:{height:"2.5000000000000004em"}}),Object(r.b)("span",Object(n.a)({parentName:"span"},{style:{top:"-4.66em"}}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"pstrut",style:{height:"3em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mopen"}),"\u27e8"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord text"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord textit"}),"Expr")),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mclose"}),"\u27e9"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace"}),"\xa0"))),Object(r.b)("span",Object(n.a)({parentName:"span"},{style:{top:"-3.16em"}}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"pstrut",style:{height:"3em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mopen"}),"\u27e8"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord text"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord textit"}),"Term")),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mclose"}),"\u27e9"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace"}),"\xa0"))),Object(r.b)("span",Object(n.a)({parentName:"span"},{style:{top:"-1.6599999999999993em"}}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"pstrut",style:{height:"3em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mopen"}),"\u27e8"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord text"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord textit"}),"Factor")),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mclose"}),"\u27e9"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace"}),"\xa0")))),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-s"}),"\u200b")),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-r"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"vlist",style:{height:"2.000000000000001em"}}),Object(r.b)("span",{parentName:"span"}))))),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"col-align-l"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-t vlist-t2"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-r"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"vlist",style:{height:"2.5000000000000004em"}}),Object(r.b)("span",Object(n.a)({parentName:"span"},{style:{top:"-4.66em"}}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"pstrut",style:{height:"3em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord"})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2777777777777778em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mrel"}),":"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mrel"}),":"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mrel"}),"="),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2777777777777778em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace"}),"\xa0"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mopen"}),"\u27e8"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord text"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord textit"}),"Term")),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mclose"}),"\u27e9"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace"}),"\xa0"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mopen"}),"["),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace"}),"\xa0"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mopen"}),"("),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace"}),"\xa0"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),"+"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace"}),"\xa0"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),"\u2223"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace"}),"\xa0"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),"\u2212"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace"}),"\xa0"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mclose"}),")"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace"}),"\xa0"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mopen"}),"\u27e8"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord text"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord textit"}),"Term")),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mclose"}),"\u27e9"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace"}),"\xa0"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mclose"}),"]"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.16666666666666666em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"minner"}),"\u2026"))),Object(r.b)("span",Object(n.a)({parentName:"span"},{style:{top:"-3.16em"}}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"pstrut",style:{height:"3em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord"})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2777777777777778em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mrel"}),":"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mrel"}),":"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mrel"}),"="),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2777777777777778em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace"}),"\xa0"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mopen"}),"\u27e8"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord text"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord textit"}),"Factor")),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mclose"}),"\u27e9"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace"}),"\xa0"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mopen"}),"["),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace"}),"\xa0"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mopen"}),"("),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace"}),"\xa0"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),"\u2217"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace"}),"\xa0"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),"\u2223"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace"}),"\xa0"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),"/"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace"}),"\xa0"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mclose"}),")"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace"}),"\xa0"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mopen"}),"\u27e8"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord text"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord textit"}),"Factor")),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mclose"}),"\u27e9"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace"}),"\xa0"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mclose"}),"]"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.16666666666666666em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"minner"}),"\u2026"))),Object(r.b)("span",Object(n.a)({parentName:"span"},{style:{top:"-1.6599999999999993em"}}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"pstrut",style:{height:"3em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord"})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2777777777777778em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mrel"}),":"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mrel"}),":"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mrel"}),"="),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace",style:{marginRight:"0.2777777777777778em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace"}),"\xa0"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord text"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord textrm"}),"ident")),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace"}),"\xa0"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),"\u2223"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace"}),"\xa0"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord text"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord textrm"}),"num")),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace"}),"\xa0"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),"\u2223"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace"}),"\xa0"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord text"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord textrm"}),"\u201c(\u201d")),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace"}),"\xa0"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mopen"}),"\u27e8"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord text"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord textit"}),"Expr")),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mclose"}),"\u27e9"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mspace"}),"\xa0"),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord text"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord textrm"}),"\u201c)\u201d"))))),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-s"}),"\u200b")),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-r"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"vlist",style:{height:"2.000000000000001em"}}),Object(r.b)("span",{parentName:"span"})))))))))))),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-java"}),"/**\n * Represents an expression node in an abstract syntax tree.\n */\npublic interface Expr {\n    // instance methods appropriate to the application should be declared here\n\n    /**\n     * Parse an expression (sum/difference of one or more terms).\n     * \n     * @param input\n     * @return\n     */\n    public static Expr parse(Input input) {\n        Expr e = parseTerm(input);\n        while (input.peek() == '+' || input.peek() == '-') {\n            BinOp op = BinOp.parse(input);\n            Expr e2 = Expr.parseTerm(input);\n            e = new BinOpExpr(e, op, e2);\n        }\n        return e;\n    }\n\n    /**\n     * Parse a term (product/quotient of one or more factors).\n     * \n     * @param input\n     * @return\n     */\n    public static Expr parseTerm(Input input) {\n        Expr e = parseFactor(input);\n        while (input.peek() == '*' || input.peek() == '/') {\n            BinOp op = BinOp.parse(input);\n            Expr e2 = Expr.parseFactor(input);\n            e = new BinOpExpr(e, op, e2);\n        }\n        return e;\n    }\n\n    /**\n     * Parse a factor (identifier, number, or parenthesized expression). Throws a\n     * RuntimeException if a factor is not available.\n     * \n     * @param input\n     * @return\n     */\n    public static Expr parseFactor(Input input) {\n        if (Character.isLetter(input.peek())) {\n            String id = input.readIdent();\n            return new IdentExpr(id);\n        } else if (Character.isDigit(input.peek())) {\n            int n = input.readInt();\n            return new NumExpr(n);\n        } else if (input.peek() == '(') {\n            input.skip();\n            Expr e = parse(input);\n            input.match(')');\n            return e;\n        } else {\n            throw new RuntimeException(\"expected a factor\");\n        }\n    }\n}\n\npublic class BinOpExpr implements Expr {\n    private Expr left, right;\n    private BinOp op;\n\n    public BinOpExpr(Expr left, BinOp op, Expr right) {\n        this.left = left;\n        this.op = op;\n        this.right = right;\n    }\n\n    public String toString() {\n        return \"BinOp(\" + left + \", \" + op + \", \" + right + \")\";\n    }\n}\n\npublic class IdentExpr implements Expr {\n    private String id;\n\n    public IdentExpr(String id) {\n        this.id = id;\n    }\n\n    public String toString() {\n        return \"Ident(\" + id + \")\";\n    }\n}\n\npublic class NumExpr implements Expr {\n    private int n;\n\n    public NumExpr(int n) {\n        this.n = n;\n    }\n\n    public String toString() {\n        return \"Num(\" + n + \")\";\n    }\n}\n\n/**\n * Represents the binary operators available in the abstract syntax for\n * expressions.\n */\npublic enum BinOp {\n    PLUS, MINUS, TIMES, DIVIDE;\n\n    /**\n     * Parse a binary operator from the given Input. Should only be called when the\n     * current character may start an operator.\n     * \n     * @param input\n     * @return\n     */\n    static BinOp parse(Input input) {\n        switch (input.peek()) {\n        case '+':\n            input.skip();\n            return PLUS;\n        case '-':\n            input.skip();\n            return MINUS;\n        case '*':\n            input.skip();\n            return TIMES;\n        case '/':\n            input.skip();\n            return DIVIDE;\n        default:\n            return null; // shouldn't happen\n        }\n    }\n}\n\n/**\n * Wrapper around a Reader that provides useful abstractions for recursive\n * descent parsing.\n */\npublic class Input {\n    private java.io.Reader source;\n    private char next;\n    private boolean atEnd;\n\n    public Input(java.io.Reader source) {\n        this.source = source;\n        skip();\n    }\n\n    /**\n     * @return current available character\n     */\n    public char peek() {\n        return next;\n    }\n\n    /**\n     * @return true if no more characters available\n     */\n    public boolean atEnd() {\n        return atEnd;\n    }\n\n    /**\n     * Read the next available character, skipping over whitespace\n     */\n    public void skip() {\n        readNext();\n        skipWhitespace();\n    }\n\n    /**\n     * If the current character is c, skip to the next. Throw a RuntimeException if\n     * the character does not match.\n     * \n     * @param c\n     */\n    public void match(char c) {\n        if (next == c) {\n            skip();\n        } else {\n            throw new RuntimeException(\"expected \" + c + \" but found \" + next);\n        }\n    }\n\n    /**\n     * Read an identifier (letter followed by zero or more letters or digits). This\n     * should only be called when the current character is a letter.\n     * \n     * @return the identifier\n     */\n    public String readIdent() {\n        StringBuilder builder = new StringBuilder();\n        builder.append(next);\n        readNext();\n        while (!atEnd && Character.isLetterOrDigit(next)) {\n            builder.append(next);\n            readNext();\n        }\n        skipWhitespace();\n        return builder.toString();\n    }\n\n    /**\n     * Read an integer (digit followed by zero or more additional digits). This\n     * should only be called when the current character is a digit.\n     * \n     * @return the number\n     */\n    public int readInt() {\n        int result = next - '0';\n        readNext();\n        while (!atEnd && Character.isDigit(next)) {\n            result = result * 10 + next - '0';\n            readNext();\n        }\n        skipWhitespace();\n        return result;\n    }\n\n    private void readNext() {\n        try {\n            int c = source.read();\n            if (c != -1) {\n                next = (char) c;\n                atEnd = false;\n            } else {\n                next = '\\0';\n                atEnd = true;\n            }\n        } catch (java.io.IOException e) {\n            next = '\\0';\n            atEnd = true;\n        }\n    }\n\n    private void skipWhitespace() {\n        while (!atEnd && Character.isWhitespace(next)) {\n            readNext();\n        }\n    }\n}\n\npublic class Demo {\n    public static void main(String[] args) {\n        String sample = \"  3*abc + (x1 - x0) * r2d2/42 \\n\";\n        Input input = new Input(new StringReader(sample));\n        Expr e = Expr.parse(input);\n        if (input.atEnd()) {\n            System.out.println(\"Found \" + e);\n        } else {\n            System.out.println(\"unscanned input after parsing \" + e);\n        }\n    }\n}\n")),Object(r.b)("h2",{id:"parser-combinators"},"Parser Combinators"),Object(r.b)("p",null,"Instead of giving a direct translation of the Java version into ReasonML, it is\ncommon in functional languages to use what are known as ",Object(r.b)("strong",{parentName:"p"},"parser combinators"),'\nto write recursive descent parsers. A parser is viewed as a function from input\nto the pair of a result plus the remaining input (since in a functional language\nwe do not want to use side-effects to update the "current character" available from\nan input source). A parser combinator is then a function that can combine one or\nmore of these parsing functions into a composite parser.'),Object(r.b)("p",null,"For example, given parsers ",Object(r.b)("inlineCode",{parentName:"p"},"p1")," and ",Object(r.b)("inlineCode",{parentName:"p"},"p2"),", the combinator ",Object(r.b)("inlineCode",{parentName:"p"},"<|>")," produces the parser\n",Object(r.b)("inlineCode",{parentName:"p"},"p1 <|> p2")," which attempts to parse according to ",Object(r.b)("inlineCode",{parentName:"p"},"p1"),"; if it fails, then it attempts\nto use ",Object(r.b)("inlineCode",{parentName:"p"},"p2")," instead. This corresponds to the ",Object(r.b)("span",Object(n.a)({parentName:"p"},{className:"math math-inline"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(r.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(r.b)("semantics",{parentName:"math"},Object(r.b)("mrow",{parentName:"semantics"},Object(r.b)("mi",Object(n.a)({parentName:"mrow"},{mathvariant:"normal"}),"\u2223")),Object(r.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"|")))),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}})),Object(r.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),"\u2223")))))," (choice) operator in BNF (and also\nin regular expressions). Some of the other combinators used below are ",Object(r.b)("inlineCode",{parentName:"p"},"<*>"),", which\ncorresponds to sequencing one parser after another, and ",Object(r.b)("inlineCode",{parentName:"p"},"rep"),", which repeats a\nparser zero or more times (like the Kleene star)."),Object(r.b)("p",null,"Here is code for parser combinators in ReasonML, based on\n",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/henoc/bs-little-parser"}),"bs-little-parser"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"module Input = {\n  type t = {text: string, index: int, whitespace: string};\n\n  let fromString = s => {text: s, index: 0, whitespace: \" \\t\\n\"};\n\n  let skipWhitespace = input => {\n    let whitespace = input.whitespace;\n    let spaceChars = List.init(String.length(whitespace), String.get(whitespace));\n    \n    let rec aux = input => {\n      if (String.length(input.text) <= input.index) {\n        input \n      } else if (List.mem(input.text.[input.index], spaceChars)) {\n        aux({...input, index: input.index+1})\n      } else {\n        input\n      }\n    };\n    aux(input)\n  };\n\n  let atEnd = input => {\n    input.index == String.length(input.text)\n  };\n};\n\nmodule Result = {\n  type t('a, 'b) = Ok('a) | Error('b);\n\n  let map = (f, result) => {\n    switch (result) {\n    | Ok(r) => Ok(f(r))\n    | Error(s) => Error(s)\n    }\n  };\n\n  let get = result => {\n    switch (result) {\n    | Ok(r) => Some(r)\n    | _ => None\n    }\n  };\n};\n\nmodule Parser = {\n  type parseResult('a) = Result.t(('a, Input.t), (string, Input.t))\n  type t('a) = Input.t => parseResult('a);\n\n  let success = (result, input): parseResult('a) =>\n    Result.Ok((result, input));\n  \n  let failure = (message, input): parseResult('a) =>\n    Result.Error((message, input));\n\n  let ( <*> ) = (p: t('a), q: t('b), input) => {\n    switch (p(input)) {\n    | Result.Ok((result1, input2)) =>\n        switch (q(input2)) {\n        | Result.Ok((result2, input3)) =>\n            success((result1, result2), input3)\n        | Result.Error((message, input)) =>\n            failure(message, input)\n        }\n    | Result.Error((message, input)) =>\n        failure(message, input)\n    }\n  };\n\n  let ( <* ) = (p: t('a), q: t('b), input) => {\n    switch(p(input)) {\n    | Result.Ok((result1, input2)) =>\n        switch (q(input2)) {\n        | Result.Ok((_, input3)) =>\n            success(result1, input3)\n        | Result.Error((message, input)) =>\n            failure(message, input)\n        }\n    | Result.Error((message, input)) =>\n        failure(message, input)\n    }\n  };\n\n  let ( *> ) = (p: t('a), q: t('b), input) => {\n    switch(p(input)) {\n    | Result.Ok((_, input2)) =>\n        switch (q(input2)) {\n        | Result.Ok((result2, input3)) =>\n            success(result2, input3)\n        | Result.Error((message, input)) =>\n            failure(message, input)\n        }\n    | Result.Error((message, input)) =>\n        failure(message, input)\n    }\n  };\n\n  let ( <|> ) = (p: t('a), q: t('a), input) => {\n    switch (p(input)) {\n    | Result.Ok((s, t)) => success(s, t)\n    | _ => q(input)\n    }\n  };\n\n  let rep = (p: t('a), input) => {\n    let rec aux = (accum, input) => {\n      switch (p(input)) {\n      | Result.Ok((r, i)) => aux([r, ...accum], i)\n      | _ => success(List.rev(accum), input)\n      }\n    };\n\n    aux([], input);\n  };\n\n  let rep1 = (p: t('a)) => p <*> rep(p);\n\n  let opt = (p: t('a), input) => {\n    switch (p(input)) {\n    | Result.Ok((r, i)) => success(Some(r), i)\n    | _ => success(None, input)\n    }\n  };\n\n  let andPred = (p: t('a), input) => {\n    switch (p(input)) {\n    | Result.Ok((r, _)) => success(r, input)\n    | Result.Error((message, input)) => failure(message, input)\n    }\n  };\n\n  let notPred = (p: t('a), input) => {\n    switch (p(input)) {\n    | Result.Ok((_, i)) => failure(\"notPred failure\", i)\n    | _ => success((), input)\n    }\n  };\n\n  let ( >> ) = (p: t('a), f, input) => {\n    switch (p(input)) {\n    | Result.Ok((r, i)) => f(r, i)\n    | Result.Error((message, input)) => failure(message, input)\n    }\n  };\n\n  let ( ^^ ) = (p: t('a), f, input): parseResult('b) =>\n    Result.map(((r, i)) => (f(r), i), p(input));\n\n  let chr = (c, rawInput) => {\n    let input = Input.skipWhitespace(rawInput);\n    if (Input.atEnd(input)) {\n      failure(\"not enough input\", input)\n    } else {\n      let firstChar = input.text.[input.index];\n      if (firstChar == c) {\n        success(c, {...input, index: input.index+1})\n      } else {\n        failure(Printf.sprintf(\"mismatch: %C found, expected %C\", firstChar, c), input)\n      }\n    }\n  };\n\n  let str = (s, rawInput) => {\n    let input = Input.skipWhitespace(rawInput);\n    let slen = String.length(s);\n    if (String.length(input.text) - slen < input.index) {\n      failure(\"not enough input\", input)\n    } else {\n      let substr = String.sub(input.text, input.index, slen);\n      if (substr == s) {\n        success(s, {...input, index: input.index+slen})\n      } else {\n        failure(Printf.sprintf(\"mismatch: %S found, expected %S\", substr, s), input)\n      }\n    }\n  };\n\n  let dfa = (init, step, finish, rawInput) => {\n    let input = Input.skipWhitespace(rawInput);\n    let rec aux = (state, i) => {\n      if (Input.atEnd(i)) {\n        (state, i)\n      } else {\n        let nextChar = i.text.[i.index];\n        switch (step(state, nextChar)) {\n        | Some(nextState) => aux(nextState, {...i, index: i.index+1})\n        | None => (state, i)\n        }\n      }\n    };\n    let (finalState, input2) = aux(init, input);\n    switch (finish(finalState)) {\n    | Ok(result) => success(result, input2)\n    | Error(message) => failure(message, input2)\n    }\n  };\n\n  let eoi = (rawInput) => {\n    let input = Input.skipWhitespace(rawInput);\n    let remain = String.length(input.text) - input.index;\n    if (remain == 0) {\n      success((), input)\n    } else {\n      failure(Printf.sprintf(\"unscanned input at end of parse: %S\", String.sub(input.text, input.index, remain)), input)\n    }\n  };\n\n  let parse = (input, parser: t('a)) => {\n    parser(input)\n  };\n\n  let parseAll = (input, parser: t('a)) => {\n    (parser <* eoi)(input)\n  };\n\n  let test = (parser: t('a), s) => {\n    switch (parseAll(Input.fromString(s), parser)) {\n    | Result.Ok((r, _)) => r\n    | Result.Error((m, _)) => failwith(m)\n    }\n  }\n};\n")),Object(r.b)("p",null,"Here is the parser for arithmetic expressions, corresponding to the Java example above.\nNote how the definitions of ",Object(r.b)("inlineCode",{parentName:"p"},"expr"),", ",Object(r.b)("inlineCode",{parentName:"p"},"term"),", and ",Object(r.b)("inlineCode",{parentName:"p"},"factor")," are very close to the original BNF:"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),"open Parser;\n\ntype exp =\n  | Ident(string)\n  | Num(int)\n  | BinOp(exp, char, exp);\n\nlet isLetter = c => ('A' <= c && c <= 'Z') || ('a' <= c && c <= 'z');\nlet isDigit = c => ('0' <= c && c <= '9');\nlet isLetterOrDigit = c => isLetter(c) || isDigit(c);\n\nlet ident = dfa(\n  \"\",\n  (s, c) => if ((s == \"\" && isLetter(c)) || (s != \"\" && isLetterOrDigit(c))) {\n      Some(s ++ String.make(1, c))\n    } else {\n      None\n    },\n  s => if (s == \"\") {\n      Error(\"expected identifier\")\n    } else {\n      Ok(Ident(s))\n    }\n);\n\nlet number = dfa(\n  \"\",\n  (s, c) => if (isDigit(c)) {\n    Some(s ++ String.make(1, c))\n  } else {\n    None\n  },\n  s => if (s == \"\") {\n    Error(\"expected number\")\n  } else {\n    Ok(Num(int_of_string(s)))\n  }\n);\n\nlet addop = chr('+') <|> chr('-');\nlet mulop = chr('*') <|> chr('/');\n\nlet rec expr = input => (\n  (term <*> rep(addop <*> term))\n  ^^ ((t, ts)) => List.fold_left((l, (op, r)) => BinOp(l, op, r), t, ts)\n)(input)\nand term = input => (\n  (factor <*> rep(mulop <*> factor))\n  ^^ ((f, fs)) => List.fold_left((l, (op, r)) => BinOp(l, op, r), f, fs)\n)(input)\nand factor = input => (\n  ident\n  <|> number\n  <|> (chr('(') *> expr <* chr(')'))\n)(input);\n\nlet sample = \"  3*abc + (x1 - x0) * r2d2/42 \\n\";\nResult.get(parseAll(Input.fromString(sample), expr));\ntest(expr, sample);\n")))}i.isMDXComponent=!0},252:function(e,t,a){"use strict";a.d(t,"a",(function(){return l})),a.d(t,"b",(function(){return j}));var n=a(0),s=a.n(n);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function p(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function c(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?p(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):p(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function m(e,t){if(null==e)return{};var a,n,s=function(e,t){if(null==e)return{};var a,n,s={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(s[a]=e[a]);return s}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(s[a]=e[a])}return s}var b=s.a.createContext({}),i=function(e){var t=s.a.useContext(b),a=t;return e&&(a="function"==typeof e?e(t):c({},t,{},e)),a},l=function(e){var t=i(e.components);return s.a.createElement(b.Provider,{value:t},e.children)},o={inlineCode:"code",wrapper:function(e){var t=e.children;return s.a.createElement(s.a.Fragment,{},t)}},O=Object(n.forwardRef)((function(e,t){var a=e.components,n=e.mdxType,r=e.originalType,p=e.parentName,b=m(e,["components","mdxType","originalType","parentName"]),l=i(a),O=n,j=l["".concat(p,".").concat(O)]||l[O]||o[O]||r;return a?s.a.createElement(j,c({ref:t},b,{components:a})):s.a.createElement(j,c({ref:t},b))}));function j(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var r=a.length,p=new Array(r);p[0]=O;var c={};for(var m in t)hasOwnProperty.call(t,m)&&(c[m]=t[m]);c.originalType=e,c.mdxType="string"==typeof e?e:n,p[1]=c;for(var b=2;b<r;b++)p[b]=a[b];return s.a.createElement.apply(null,p)}return s.a.createElement.apply(null,a)}O.displayName="MDXCreateElement"}}]);