(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{110:function(n,e,t){"use strict";t.r(e),t.d(e,"frontMatter",(function(){return a})),t.d(e,"metadata",(function(){return o})),t.d(e,"rightToc",(function(){return s})),t.d(e,"default",(function(){return c}));var r=t(1),l=t(6),i=(t(0),t(171)),a={id:"doodle",title:"Doodle Graphics"},o={id:"fp/doodle",title:"Doodle Graphics",description:"```reason hidden",source:"@site/docs/fp/doodle.md",permalink:"/focsipedia/docs/fp/doodle",editUrl:"https://github.com/bhoward/focsipedia/edit/master/docs/fp/doodle.md",sidebar:"someSidebar",previous:{title:"Types in Functional Programming",permalink:"/focsipedia/docs/fp/types"},next:{title:"ReasonML",permalink:"/focsipedia/docs/reason"}},s=[],b={rightToc:s},p="wrapper";function c(n){var e=n.components,t=Object(l.a)(n,["components"]);return Object(i.b)(p,Object(r.a)({},b,t,{components:e,mdxType:"MDXLayout"}),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-reason",metastring:"hidden",hidden:!0}),'type point = (float, float);\ntype angle = float;\ntype pathElement =\n| MoveTo(point)\n| LineTo(point)\n| CurveTo(point, point, point);\ntype color =\n| Color(string)\n| RGBA(int, int, int, float)\n| HSLA(angle, float, float, float);\ntype style =\n| LineWidth(float)\n| LineColor(color) /* TODO patterns? */\n| FillColor(color)\n| Dashed; /* TODO: Font(family, size, style, ...) */\ntype image =\n| Empty\n| Ellipse(float, float)\n| Rectangle(float, float)\n| Text(string)\n| OpenPath(list(pathElement))\n| ClosedPath(list(pathElement))\n| Beside(image, image)\n| Above(image, image)\n| On(image, image)\n| Styled(image, list(style))\n| Translate(image, float, float)\n| Rotate(image, angle)\n| Scale(image, float, float)\n| Bounds(image, float, float, float, float);\ntype position = TL | TC | TR | ML | MC | MR | BL | BC | BR;\nlet string_of_color = c => {\n  switch (c) {\n  | Color(s) => s\n  | RGBA(r, g, b, a) =>\n    Printf.sprintf("rgba(%d,%d,%d,%f)",\n      r, g, b, a)\n  | HSLA(h, s, l, a) =>\n    Printf.sprintf("hsla(%f,%d%%,%d%%,%f)",\n      h, int_of_float(s *. 100.), int_of_float(l *. 100.), a)\n  }\n};\nlet string_of_style = s => {\n  switch (s) {\n  | LineWidth(w) =>\n    Printf.sprintf("stroke-width=\'%f\'", w)\n  | LineColor(c) =>\n    Printf.sprintf("stroke=\'%s\'", string_of_color(c))\n  | FillColor(c) => \n    Printf.sprintf("fill=\'%s\'", string_of_color(c))\n  | Dashed =>\n    "stroke-dasharray=\'4\'"\n  }\n}\nlet radians = a => {\n  a *. 3.14159265358979 /. 180.0\n};\nlet getPoint = elt => {\n  switch (elt) {\n  | MoveTo(p) => p\n  | LineTo(p) => p\n  | CurveTo(_, _, p) => p\n  }\n};\nlet rec bbox_of_points = ps => {\n  switch (ps) {\n  | [] => (0., 0., 0., 0.)\n  | [(x, y)] => (x, x, y, y)\n  | [(x, y), ...rest] => {\n      let (l, r, t, b) = bbox_of_points(rest);\n      (min(x, l), max(x, r), min(y, t), max(y, b))\n    }\n  }\n};\nlet rec bbox = img => {\n  switch (img) {\n  | Empty => (0., 0., 0., 0.)\n  | Ellipse(w, h) => (-.w /. 2., w /. 2., -.h /. 2., h /. 2.)\n  | Rectangle(w, h) => (-.w /. 2., w /. 2., -.h /. 2., h /. 2.)\n  | Text(_) => (0., 0., 0., 0.)\n  | OpenPath(elts) => {\n    bbox_of_points(List.map(getPoint, elts))\n  }\n  | ClosedPath(elts) => {\n    bbox_of_points(List.map(getPoint, elts))\n  }\n  | Beside(l, r) => {\n    let (ll, lr, lt, lb) = bbox(l);\n    let (rl, rr, rt, rb) = bbox(r);\n    (ll -. (rr -. rl) /. 2., rr +. (lr -. ll) /. 2., min(lt, rt), max(lb, rb))\n  }\n  | Above(t, b) => {\n    let (tl, tr, tt, tb) = bbox(t);\n    let (bl, br, bt, bb) = bbox(b);\n    (min(tl, bl), max(tr, br), tt -. (bb -. bt) /. 2., bb +. (tb -. tt) /. 2.)\n  }\n  | On(a, b) => {\n    let (al, ar, at, ab) = bbox(a);\n    let (bl, br, bt, bb) = bbox(b);\n    (min(al, bl), max(ar, br), min(at, bt), max(ab, bb))\n  }\n  | Styled(img, _) => bbox(img)\n  | Translate(img, x, y) => {\n    let (l, r, t, b) = bbox(img);\n    (l +. x, r +. x, t +. y, b +. y)\n  }\n  | Rotate(img, a) => {\n    let (l, r, t, b) = bbox(img);\n    let ps = [(l, t), (l, b), (r, t), (r, b)];\n    let arad = radians(a);\n    let cosa = cos(arad);\n    let sina = sin(arad);\n    let rot = ((x, y)) => { (x *. cosa -. y *. sina, x *. sina +. y *. cosa) }\n    bbox_of_points(List.map(rot, ps))\n  }\n  | Scale(img, sx, sy) => {\n    let (l, r, t, b) = bbox(img);\n    (l *. sx, r *. sx, t *. sy, b *. sy)\n  }\n  | Bounds(_, l, r, t, b) => (l, r, t, b)\n  }\n};\nlet rec width = img => {\n  let (l, r, _, _) = bbox(img);\n  r -. l\n};\nlet rec height = img => {\n  let (_, _, t, b) = bbox(img);\n  b -. t\n};\nlet rec string_of_path = path => {\n  switch (path) {\n  | [] => ""\n  | [MoveTo((x, y)), ...rest] =>\n      Printf.sprintf("M %f %f ", x, y) ++ string_of_path(rest)\n  | [LineTo((x, y)), ...rest] =>\n      Printf.sprintf("L %f %f ", x, y) ++ string_of_path(rest)\n  | [CurveTo((x1, y1), (x2, y2), (x3, y3)), ...rest] =>\n      Printf.sprintf("C %f %f, %f %f, %f %f ", x1, y1, x2, y2, x3, y3) ++ string_of_path(rest)\n  }\n};\nlet rec render = img => {\n  switch (img) {\n  | Empty => ""\n  | Ellipse(w, h) =>\n    Printf.sprintf("<ellipse rx=\'%f\' ry=\'%f\' cx=\'0\' cy=\'0\' />",\n      w /. 2., h /. 2.)\n  | Rectangle(w, h) =>\n    Printf.sprintf("<rect width=\'%f\' height=\'%f\' x=\'%f\' y=\'%f\' />",\n      w, h, -.w /. 2., -.h /. 2.)\n  | Text(s) =>\n    Printf.sprintf("<text x=\'0\' y=\'0\' text-anchor=\'middle\' dominant-baseline=\'middle\'>%s</text>", s)\n  | OpenPath(path) =>\n    Printf.sprintf("<path d=\'%s\' />", string_of_path(path))\n  | ClosedPath(path) => \n    Printf.sprintf("<path d=\'%sZ\' />", string_of_path(path))\n  | Beside(l, r) =>\n    Printf.sprintf("<g transform=\'translate(%f,0)\'>%s</g>",\n      -.width(r) /. 2., render(l))\n    ++\n    Printf.sprintf("<g transform=\'translate(%f,0)\'>%s</g>",\n      width(l) /. 2., render(r))\n  | Above(t, b) =>\n    Printf.sprintf("<g transform=\'translate(0,%f)\'>%s</g>",\n      -.height(b) /. 2., render(t))\n    ++\n    Printf.sprintf("<g transform=\'translate(0,%f)\'>%s</g>",\n      height(t) /. 2., render(b))\n  | On(a, b) => render(b) ++ render(a)\n  | Styled(img, stys) => {\n      let ss = List.map(s => { " " ++ string_of_style(s) }, stys);\n      Printf.sprintf("<g %s>%s</g>", List.fold_left((++), "", ss), render(img))\n    }\n  | Translate(img, x, y) =>\n    Printf.sprintf("<g transform=\'translate(%f,%f)\'>%s</g>",\n      x, y, render(img))\n  | Rotate(img, a) =>\n    Printf.sprintf("<g transform=\'rotate(%f)\'>%s</g>",\n      a, render(img))\n  | Scale(img, sx, sy) =>\n    Printf.sprintf("<g transform=\'scale(%f,%f)\'>%s</g>",\n      sx, sy, render(img))\n  | Bounds(img, _, _, _, _) => render(img)\n  }\n};\nlet draw = image => {\n  print_string("<svg viewBox=\'-100 -100 200 200\' width=\'100%\' preserveAspectRatio>");\n  print_string("<g fill=\'grey\' stroke=\'black\' font-size=\'14\'>");\n  print_string(render(image));\n  print_string("</g></svg>\\n");\n};\nlet empty = Empty;\nlet circle = r => { Ellipse(2. *. r, 2. *. r) };\nlet ellipse = (w, h) => { Ellipse(w, h) };\nlet rectangle = (w, h) => { Rectangle(w, h) };\nlet square = w => { Rectangle(w, w) };\nlet text = s => { Text(s) };\nlet (---) = (a, b) => { Above(a, b) };\nlet (|||) = (a, b) => { Beside(a, b) };\nlet (***) = (a, b) => { On(a, b) };\nlet fill = (c, img) => { Styled(img, [FillColor(c)]) };\nlet stroke = (c, img) => { Styled(img, [LineColor(c)]) };\nlet solid = (c, img) => { Styled(img, [FillColor(c), LineColor(c)]) };\nlet strokeWidth = (w, img) => { Styled(img, [LineWidth(w)]) };\nlet focus = (pos, img) => {\n  let (l, r, t, b) = bbox(img);\n  switch (pos) {\n  | TL => Translate(img, -.l, -.t)\n  | TC => Translate(img, -.(l +. r) /. 2., -.t)\n  | TR => Translate(img, -.r, -.t)\n  | ML => Translate(img, -.l, -.(t +. b) /. 2.)\n  | MC => Translate(img, -.(l +. r) /. 2., -.(t +. b) /. 2.)\n  | MR => Translate(img, -.r, -.(t +. b) /. 2.)\n  | BL => Translate(img, -.l, -.b)\n  | BC => Translate(img, -.(l +. r) /. 2., -.b)\n  | BR => Translate(img, -.r, -.b)\n  }\n};\nlet rotate = (a, img) => { Rotate(img, a) };\nlet translate = (dx, dy, img) => { Translate(img, dx, dy) };\nlet scalexy = (sx, sy, img) => { Scale(img, sx, sy) };\nlet scale = (s, img) => { Scale(img, s, s) };\nlet showBounds = img => {\n  let (l, r, t, b) = bbox(img);\n  let w = r -. l;\n  let h = b -. t;\n  On(\n    Styled(\n      circle(10.) ***\n        OpenPath([MoveTo((-20., 0.)), LineTo((20., 0.))]) ***\n        OpenPath([MoveTo((0., -20.)), LineTo((0., 20.))]) ***\n        Translate(rectangle(w, h), l +. w /. 2., t +. h /. 2.),\n      [Dashed, FillColor(Color("none")), LineColor(Color("black")), LineWidth(1.0)]),\n    img\n  )\n}\nlet polar = (r, theta) => {\n  let a = radians(theta);\n  (r *. cos(a), r *. sin(a))\n};\nlet rgb = (r, g, b) => { RGBA(r, g, b, 1.0) };\nlet rgba = (r, b, g, a) => { RGBA(r, g, b, a) };\nlet hsl = (h, s, l) => { HSLA(h, s, l, 1.0) };\nlet hsla = (h, s, l, a) => {HSLA(h, s, l, a) };\nlet rec foo = n => {\n  if (n == 0) {\n    Empty\n  } else {\n    foo(n - 1) ***\n      fill(hsl(float_of_int(24 * n), 1.0, 0.5), circle(float_of_int(10 * n)))\n  }\n};\ndraw(scale(2.1, fill(Color("black"), text("DPoodle"))) *** foo(10))\n')),Object(i.b)("p",null,"Here is an ugly example:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),'let blueFill = img => { Styled(img, [FillColor(Color("blue"))]) };\nlet wideLines = img => { Styled(img, [LineWidth(3.0)]) };\nlet redOutline = img => { Styled(img, [LineColor(Color("red"))]) };\nlet a = blueFill(ellipse(60.0, 80.0));\nlet b = wideLines(rectangle(50.0, 50.0));\nlet c = circle(30.0);\nlet d = Text("Hello");\ndraw(On(Rotate(Scale(d, 5., 5.), 45.),\n        redOutline(Above(Beside(a, b), c))));\n')),Object(i.b)("p",null,"Here is the same with operators and other shortcuts:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"a ||| b")," is ",Object(i.b)("inlineCode",{parentName:"li"},"Beside(a, b)")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"a --- b")," is ",Object(i.b)("inlineCode",{parentName:"li"},"Above(a, b)")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"a *** b")," is ",Object(i.b)("inlineCode",{parentName:"li"},"On(a, b)"))),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),'let blueFill = fill(Color("blue"));\nlet wideLines = strokeWidth(3.0);\nlet redOutline = stroke(Color("red"));\nlet a = blueFill(ellipse(60.0, 80.0));\nlet b = wideLines(square(50.0));\nlet c = circle(30.0);\nlet d = text("Hello");\ndraw(rotate(45., scale(5., d)) *** redOutline((a ||| b) --- c));\n')),Object(i.b)("p",null,"Here is an example of drawing a polygon using a closed path and polar coordinates:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-reason",metastring:"edit",edit:!0}),'let polygon = (sides, size, initialAngle) => {\n  let rotation = 360. /. float_of_int(sides);\n  let getPoint = n => polar(size, rotation *. float_of_int(n) +. initialAngle);\n  let rec path = n => {\n    if (n == 0) {\n      []\n    } else {\n      [LineTo(getPoint(n)), ...path(n - 1)]\n    }\n  };\n  ClosedPath([MoveTo(getPoint(sides)), ...path(sides - 1)])\n};\n\ndraw(solid(Color("green"), polygon(6, 30., 90.)));\n')))}c.isMDXComponent=!0},171:function(n,e,t){"use strict";t.d(e,"a",(function(){return c})),t.d(e,"b",(function(){return m}));var r=t(0),l=t.n(r);function i(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function a(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function o(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?a(Object(t),!0).forEach((function(e){i(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function s(n,e){if(null==n)return{};var t,r,l=function(n,e){if(null==n)return{};var t,r,l={},i=Object.keys(n);for(r=0;r<i.length;r++)t=i[r],e.indexOf(t)>=0||(l[t]=n[t]);return l}(n,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);for(r=0;r<i.length;r++)t=i[r],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(l[t]=n[t])}return l}var b=l.a.createContext({}),p=function(n){var e=l.a.useContext(b),t=e;return n&&(t="function"==typeof n?n(e):o({},e,{},n)),t},c=function(n){var e=p(n.components);return l.a.createElement(b.Provider,{value:e},n.children)},f="mdxType",d={inlineCode:"code",wrapper:function(n){var e=n.children;return l.a.createElement(l.a.Fragment,{},e)}},g=Object(r.forwardRef)((function(n,e){var t=n.components,r=n.mdxType,i=n.originalType,a=n.parentName,b=s(n,["components","mdxType","originalType","parentName"]),c=p(t),f=r,g=c["".concat(a,".").concat(f)]||c[f]||d[f]||i;return t?l.a.createElement(g,o({ref:e},b,{components:t})):l.a.createElement(g,o({ref:e},b))}));function m(n,e){var t=arguments,r=e&&e.mdxType;if("string"==typeof n||r){var i=t.length,a=new Array(i);a[0]=g;var o={};for(var s in e)hasOwnProperty.call(e,s)&&(o[s]=e[s]);o.originalType=n,o[f]="string"==typeof n?n:r,a[1]=o;for(var b=2;b<i;b++)a[b]=t[b];return l.a.createElement.apply(null,a)}return l.a.createElement.apply(null,t)}g.displayName="MDXCreateElement"}}]);