"use strict";(self.webpackChunkfocsipedia=self.webpackChunkfocsipedia||[]).push([[2197],{1109:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"someSidebar":[{"type":"category","label":"Course Info","items":[{"type":"link","label":"Attribution","href":"/focsipedia/docs/attribution","docId":"attribution"},{"type":"link","label":"Course Information and Policies","href":"/focsipedia/docs/policies","docId":"policies"},{"type":"link","label":"Topics","href":"/focsipedia/docs/topics","docId":"topics"},{"type":"link","label":"Overview of Foundations","href":"/focsipedia/docs/overview","docId":"overview"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Logic","items":[{"type":"link","label":"Logic","href":"/focsipedia/docs/logic/intro","docId":"logic/intro"},{"type":"link","label":"Propositional Logic","href":"/focsipedia/docs/logic/props","docId":"logic/props"},{"type":"link","label":"Boolean Algebra","href":"/focsipedia/docs/logic/boolean","docId":"logic/boolean"},{"type":"link","label":"Logic Circuits","href":"/focsipedia/docs/logic/circuits","docId":"logic/circuits"},{"type":"link","label":"Circuit Simplification","href":"/focsipedia/docs/logic/simplify","docId":"logic/simplify"},{"type":"link","label":"Common Circuit Components","href":"/focsipedia/docs/logic/components","docId":"logic/components"},{"type":"link","label":"Predicates and Quantifiers","href":"/focsipedia/docs/logic/preds","docId":"logic/preds"},{"type":"link","label":"Deduction","href":"/focsipedia/docs/logic/deduction","docId":"logic/deduction"},{"type":"link","label":"Natural Deduction for Predicate Logic","href":"/focsipedia/docs/logic/pred-deduction","docId":"logic/pred-deduction"},{"type":"link","label":"Mathematical Induction","href":"/focsipedia/docs/logic/induction","docId":"logic/induction"},{"type":"link","label":"Recursion and Induction","href":"/focsipedia/docs/logic/recursion","docId":"logic/recursion"},{"type":"link","label":"Sequential Circuits","href":"/focsipedia/docs/logic/sequential","docId":"logic/sequential"},{"type":"link","label":"State Machines","href":"/focsipedia/docs/logic/state","docId":"logic/state"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Sets","items":[{"type":"link","label":"Set Concepts","href":"/focsipedia/docs/sets/concepts","docId":"sets/concepts"},{"type":"link","label":"Boolean Algebra of Sets","href":"/focsipedia/docs/sets/algebra","docId":"sets/algebra"},{"type":"link","label":"Programming with Sets","href":"/focsipedia/docs/sets/programming","docId":"sets/programming"},{"type":"link","label":"Functions","href":"/focsipedia/docs/sets/functions","docId":"sets/functions"},{"type":"link","label":"Relations","href":"/focsipedia/docs/sets/relations","docId":"sets/relations"},{"type":"link","label":"Relational Databases","href":"/focsipedia/docs/sets/database","docId":"sets/database"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Functional Programming","items":[{"type":"link","label":"Overview of Functional Programming","href":"/focsipedia/docs/fp/overview","docId":"fp/overview"},{"type":"link","label":"Introduction to Functional Programming","href":"/focsipedia/docs/fp/intro","docId":"fp/intro"},{"type":"link","label":"Types in Functional Programming","href":"/focsipedia/docs/fp/types","docId":"fp/types"},{"type":"link","label":"Map and Reduce on Lists","href":"/focsipedia/docs/fp/map-reduce","docId":"fp/map-reduce"},{"type":"link","label":"DPoodle Graphics","href":"/focsipedia/docs/fp/doodle","docId":"fp/doodle"},{"type":"link","label":"State Machines in Java and ReasonML","href":"/focsipedia/docs/fp/state","docId":"fp/state"},{"type":"link","label":"Recursive Descent and Parser Combinators","href":"/focsipedia/docs/fp/parser-comb","docId":"fp/parser-comb"},{"type":"link","label":"Lambda Calculus","href":"/focsipedia/docs/fp/lambda","docId":"fp/lambda"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Lists, Trees, and Graphs","items":[{"type":"link","label":"Sorting Lists","href":"/focsipedia/docs/ds/lists","docId":"ds/lists"},{"type":"link","label":"Running Time and Recurrences","href":"/focsipedia/docs/ds/recurrence","docId":"ds/recurrence"},{"type":"link","label":"Program Verification","href":"/focsipedia/docs/ds/verification","docId":"ds/verification"},{"type":"link","label":"Trees","href":"/focsipedia/docs/ds/trees","docId":"ds/trees"},{"type":"link","label":"Binary Search Trees and Heaps","href":"/focsipedia/docs/ds/bst","docId":"ds/bst"},{"type":"link","label":"Graphs","href":"/focsipedia/docs/ds/graphs","docId":"ds/graphs"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Formal Languages","items":[{"type":"link","label":"Languages","href":"/focsipedia/docs/lang/languages","docId":"lang/languages"},{"type":"link","label":"Regular Expressions","href":"/focsipedia/docs/lang/regexp","docId":"lang/regexp"},{"type":"link","label":"Applications of Regular Expressions","href":"/focsipedia/docs/lang/regexpapp","docId":"lang/regexpapp"},{"type":"link","label":"Finite-State Automata","href":"/focsipedia/docs/lang/fsa","docId":"lang/fsa"},{"type":"link","label":"Nondeterministic Finite-State Automata","href":"/focsipedia/docs/lang/nfa","docId":"lang/nfa"},{"type":"link","label":"Finite-State Automata and Regular Languages","href":"/focsipedia/docs/lang/fsareg","docId":"lang/fsareg"},{"type":"link","label":"Context-Free Grammars","href":"/focsipedia/docs/lang/cfg","docId":"lang/cfg"},{"type":"link","label":"Backus-Naur Form","href":"/focsipedia/docs/lang/bnf","docId":"lang/bnf"},{"type":"link","label":"Parsing and Parse Trees","href":"/focsipedia/docs/lang/parsing","docId":"lang/parsing"},{"type":"link","label":"Pushdown Automata","href":"/focsipedia/docs/lang/pda","docId":"lang/pda"},{"type":"link","label":"General Grammars and Turing Machines","href":"/focsipedia/docs/lang/tm","docId":"lang/tm"},{"type":"link","label":"Computability","href":"/focsipedia/docs/lang/computability","docId":"lang/computability"},{"type":"link","label":"The Halting Problem","href":"/focsipedia/docs/lang/halting","docId":"lang/halting"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Features","items":[{"type":"link","label":"ReasonML","href":"/focsipedia/docs/reason","docId":"reason"},{"type":"link","label":"OCaml","href":"/focsipedia/docs/ocaml","docId":"ocaml"},{"type":"link","label":"Style Guide","href":"/focsipedia/docs/styleGuide","docId":"styleGuide"}],"collapsed":true,"collapsible":true}]},"docs":{"attribution":{"id":"attribution","title":"Attribution","description":"This work is dedicated to my wife, Eleanor, who hopes that one day it will grow up and","sidebar":"someSidebar"},"ds/bst":{"id":"ds/bst","title":"Binary Search Trees and Heaps","description":"Let us consider binary trees whose values can be ordered.","sidebar":"someSidebar"},"ds/graphs":{"id":"ds/graphs","title":"Graphs","description":"Graph Terminology","sidebar":"someSidebar"},"ds/lists":{"id":"ds/lists","title":"Sorting Lists","description":"We have already seen how to work with lists in a functional language.","sidebar":"someSidebar"},"ds/recurrence":{"id":"ds/recurrence","title":"Running Time and Recurrences","description":"Basics of Big-Oh Notation","sidebar":"someSidebar"},"ds/trees":{"id":"ds/trees","title":"Trees","description":"Binary Trees","sidebar":"someSidebar"},"ds/verification":{"id":"ds/verification","title":"Program Verification","description":"Pre- and post-conditions","sidebar":"someSidebar"},"fp/doodle":{"id":"fp/doodle","title":"DPoodle Graphics","description":"Section 1. Introduction","sidebar":"someSidebar"},"fp/doodle-project":{"id":"fp/doodle-project","title":"DPoodle Graphics Drawing Project","description":"For Monday, March 30, create a drawing using the DPoodle graphics library. You should feel free to be as creative as you like, the only requirement is that the drawing use recursion in an essential way."},"fp/galleryS20A":{"id":"fp/galleryS20A","title":"Spring 2020 DPoodle Gallery, Section A","description":"Allyson Low"},"fp/galleryS20B":{"id":"fp/galleryS20B","title":"Spring 2020 DPoodle Gallery, Section B","description":"Alecia Hawkins"},"fp/intro":{"id":"fp/intro","title":"Introduction to Functional Programming","description":"(Content adapted from Critchlow & Eck)","sidebar":"someSidebar"},"fp/lambda":{"id":"fp/lambda","title":"Lambda Calculus","description":"The section on computability mentioned the Church-Turing Thesis that Turing machines","sidebar":"someSidebar"},"fp/map-reduce":{"id":"fp/map-reduce","title":"Map and Reduce on Lists","description":"Two of the most fundamental operations on lists are map and reduce.","sidebar":"someSidebar"},"fp/overview":{"id":"fp/overview","title":"Overview of Functional Programming","description":"There is a more extensive introduction to FP later, but this section provides an early introduction to some of the concepts and tools that we will be using throughout the course.","sidebar":"someSidebar"},"fp/parser-comb":{"id":"fp/parser-comb","title":"Recursive Descent and Parser Combinators","description":"It is particularly easy to turn an LL(1) grammar into an efficient parser","sidebar":"someSidebar"},"fp/scaladoodle":{"id":"fp/scaladoodle","title":"Scala Doodle","description":"This is the code for the DePauw Scala version of the Doodle library (as used on scalafiddle.io):"},"fp/state":{"id":"fp/state","title":"State Machines in Java and ReasonML","description":"There are many ways to implement the state machine concept in code. The essence is that","sidebar":"someSidebar"},"fp/types":{"id":"fp/types","title":"Types in Functional Programming","description":"One of the hallmarks of modern functional programming is a strong and rich","sidebar":"someSidebar"},"greeting":{"id":"greeting","title":"Hello","description":"Hello from Docusaurus"},"lang/bnf":{"id":"lang/bnf","title":"Backus-Naur Form","description":"(Content adapted from Critchlow &amp; Eck)","sidebar":"someSidebar"},"lang/cfg":{"id":"lang/cfg","title":"Context-Free Grammars","description":"(Content adapted from Critchlow &amp; Eck)","sidebar":"someSidebar"},"lang/computability":{"id":"lang/computability","title":"Computability","description":"(Content adapted from Critchlow &amp; Eck)","sidebar":"someSidebar"},"lang/fsa":{"id":"lang/fsa","title":"Finite-State Automata","description":"(Content adapted from Critchlow &amp; Eck)","sidebar":"someSidebar"},"lang/fsareg":{"id":"lang/fsareg","title":"Finite-State Automata and Regular Languages","description":"(Content adapted from Critchlow &amp; Eck)","sidebar":"someSidebar"},"lang/halting":{"id":"lang/halting","title":"The Halting Problem","description":"As suggested in the previous section, there is an important distinction between a language being recursive and being recursively enumerable.","sidebar":"someSidebar"},"lang/languages":{"id":"lang/languages","title":"Languages","description":"(Content adapted from Critchlow &amp; Eck)","sidebar":"someSidebar"},"lang/nfa":{"id":"lang/nfa","title":"Nondeterministic Finite-State Automata","description":"(Content adapted from Critchlow &amp; Eck)","sidebar":"someSidebar"},"lang/parsing":{"id":"lang/parsing","title":"Parsing and Parse Trees","description":"(Content adapted from Critchlow &amp; Eck)","sidebar":"someSidebar"},"lang/pda":{"id":"lang/pda","title":"Pushdown Automata","description":"(Content adapted from Critchlow &amp; Eck)","sidebar":"someSidebar"},"lang/regexp":{"id":"lang/regexp","title":"Regular Expressions","description":"(Content adapted from Critchlow &amp; Eck)","sidebar":"someSidebar"},"lang/regexpapp":{"id":"lang/regexpapp","title":"Applications of Regular Expressions","description":"(Content adapted from Critchlow &amp; Eck)","sidebar":"someSidebar"},"lang/tm":{"id":"lang/tm","title":"General Grammars and Turing Machines","description":"(Content adapted from Critchlow &amp; Eck)","sidebar":"someSidebar"},"logic/boolean":{"id":"logic/boolean","title":"Boolean Algebra","description":"(Content adapted from Critchlow & Eck)","sidebar":"someSidebar"},"logic/circuits":{"id":"logic/circuits","title":"Logic Circuits","description":"(Content adapted from Critchlow & Eck)","sidebar":"someSidebar"},"logic/components":{"id":"logic/components","title":"Common Circuit Components","description":"Just as a complicated piece of software is never written from scratch entirely","sidebar":"someSidebar"},"logic/deduction":{"id":"logic/deduction","title":"Deduction","description":"(Content adapted from Critchlow & Eck)","sidebar":"someSidebar"},"logic/induction":{"id":"logic/induction","title":"Mathematical Induction","description":"(Content adapted from Critchlow & Eck)","sidebar":"someSidebar"},"logic/intro":{"id":"logic/intro","title":"Logic","description":"(Adapted from Critchlow & Eck)","sidebar":"someSidebar"},"logic/pred-deduction":{"id":"logic/pred-deduction","title":"Natural Deduction for Predicate Logic","description":"Before seeing the natural deduction rules for handling the quantifiers","sidebar":"someSidebar"},"logic/preds":{"id":"logic/preds","title":"Predicates and Quantifiers","description":"(Content adapted from Critchlow & Eck)","sidebar":"someSidebar"},"logic/props":{"id":"logic/props","title":"Propositional Logic","description":"(Content adapted from Critchlow & Eck)","sidebar":"someSidebar"},"logic/recursion":{"id":"logic/recursion","title":"Recursion and Induction","description":"(Content adapted from Critchlow & Eck)","sidebar":"someSidebar"},"logic/sequential":{"id":"logic/sequential","title":"Sequential Circuits","description":"All of the circuits we have considered so far have been acyclic; this was an essential part of the definition of a combinational circuit.","sidebar":"someSidebar"},"logic/simplify":{"id":"logic/simplify","title":"Circuit Simplification","description":"(Content adapted from Critchlow & Eck)","sidebar":"someSidebar"},"logic/state":{"id":"logic/state","title":"State Machines","description":"In another section we learned about Moore machines, a version of finite state automata where there is an output associated with each state.","sidebar":"someSidebar"},"ocaml":{"id":"ocaml","title":"OCaml","description":"OCaml is a functional programming language developed at Inria over the past thirty years.","sidebar":"someSidebar"},"overview":{"id":"overview","title":"Overview of Foundations","description":"The Foundations of Computer Science come from mathematics, although they are not limited to the sorts of mathematics conventionally studied in elementary and secondary schools.","sidebar":"someSidebar"},"policies":{"id":"policies","title":"Course Information and Policies","description":"What, Where, When, Who, ...","sidebar":"someSidebar"},"reason":{"id":"reason","title":"ReasonML","description":"ReasonML (often just called Reason) is a functional","sidebar":"someSidebar"},"sets/algebra":{"id":"sets/algebra","title":"Boolean Algebra of Sets","description":"(Content adapted from Critchlow & Eck)","sidebar":"someSidebar"},"sets/concepts":{"id":"sets/concepts","title":"Set Concepts","description":"(Content adapted from Critchlow & Eck)","sidebar":"someSidebar"},"sets/database":{"id":"sets/database","title":"Relational Databases","description":"(Content adapted from Critchlow &amp; Eck)","sidebar":"someSidebar"},"sets/functions":{"id":"sets/functions","title":"Functions","description":"(Content adapted from Critchlow & Eck)","sidebar":"someSidebar"},"sets/programming":{"id":"sets/programming","title":"Programming with Sets","description":"(Content adapted from Critchlow &amp; Eck)","sidebar":"someSidebar"},"sets/relations":{"id":"sets/relations","title":"Relations","description":"(Content adapted from Critchlow &amp; Eck)","sidebar":"someSidebar"},"styleGuide":{"id":"styleGuide","title":"Style Guide","description":"You can write content using GitHub-flavored Markdown syntax.","sidebar":"someSidebar"},"topics":{"id":"topics","title":"Topics","description":"This page gives the order of topics as they are covered in the DePauw course CSC 233, Foundations of Computation.","sidebar":"someSidebar"}}}')}}]);