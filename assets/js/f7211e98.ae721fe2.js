"use strict";(self.webpackChunkfocsipedia=self.webpackChunkfocsipedia||[]).push([[492],{3905:function(a,e,t){t.d(e,{Zo:function(){return o},kt:function(){return h}});var n=t(7294);function s(a,e,t){return e in a?Object.defineProperty(a,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):a[e]=t,a}function m(a,e){var t=Object.keys(a);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(a);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(a,e).enumerable}))),t.push.apply(t,n)}return t}function p(a){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?m(Object(t),!0).forEach((function(e){s(a,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(a,Object.getOwnPropertyDescriptors(t)):m(Object(t)).forEach((function(e){Object.defineProperty(a,e,Object.getOwnPropertyDescriptor(t,e))}))}return a}function r(a,e){if(null==a)return{};var t,n,s=function(a,e){if(null==a)return{};var t,n,s={},m=Object.keys(a);for(n=0;n<m.length;n++)t=m[n],e.indexOf(t)>=0||(s[t]=a[t]);return s}(a,e);if(Object.getOwnPropertySymbols){var m=Object.getOwnPropertySymbols(a);for(n=0;n<m.length;n++)t=m[n],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(a,t)&&(s[t]=a[t])}return s}var i=n.createContext({}),l=function(a){var e=n.useContext(i),t=e;return a&&(t="function"==typeof a?a(e):p(p({},e),a)),t},o=function(a){var e=l(a.components);return n.createElement(i.Provider,{value:e},a.children)},N={inlineCode:"code",wrapper:function(a){var e=a.children;return n.createElement(n.Fragment,{},e)}},c=n.forwardRef((function(a,e){var t=a.components,s=a.mdxType,m=a.originalType,i=a.parentName,o=r(a,["components","mdxType","originalType","parentName"]),c=l(t),h=s,k=c["".concat(i,".").concat(h)]||c[h]||N[h]||m;return t?n.createElement(k,p(p({ref:e},o),{},{components:t})):n.createElement(k,p({ref:e},o))}));function h(a,e){var t=arguments,s=e&&e.mdxType;if("string"==typeof a||s){var m=t.length,p=new Array(m);p[0]=c;var r={};for(var i in e)hasOwnProperty.call(e,i)&&(r[i]=e[i]);r.originalType=a,r.mdxType="string"==typeof a?a:s,p[1]=r;for(var l=2;l<m;l++)p[l]=t[l];return n.createElement.apply(null,p)}return n.createElement.apply(null,t)}c.displayName="MDXCreateElement"},4806:function(a,e,t){t.r(e),t.d(e,{assets:function(){return o},contentTitle:function(){return i},default:function(){return h},frontMatter:function(){return r},metadata:function(){return l},toc:function(){return N}});var n=t(7462),s=t(3366),m=(t(7294),t(3905)),p=["components"],r={id:"lists",title:"Sorting Lists"},i=void 0,l={unversionedId:"ds/lists",id:"ds/lists",title:"Sorting Lists",description:"We have already seen how to work with lists in a functional language.",source:"@site/docs/ds/lists.md",sourceDirName:"ds",slug:"/ds/lists",permalink:"/focsipedia/docs/ds/lists",draft:!1,editUrl:"https://github.com/bhoward/focsipedia/edit/master/docs/ds/lists.md",tags:[],version:"current",frontMatter:{id:"lists",title:"Sorting Lists"},sidebar:"someSidebar",previous:{title:"Lambda Calculus",permalink:"/focsipedia/docs/fp/lambda"},next:{title:"Running Time and Recurrences",permalink:"/focsipedia/docs/ds/recurrence"}},o={},N=[{value:"Insertion Sort",id:"insertion-sort",level:2},{value:"Selection Sort",id:"selection-sort",level:2},{value:"Running Time of Insertion and Selection Sort",id:"running-time-of-insertion-and-selection-sort",level:2},{value:"Merge Sort",id:"merge-sort",level:2},{value:"Quicksort",id:"quicksort",level:2},{value:"Exercises",id:"exercises",level:2}],c={toc:N};function h(a){var e=a.components,t=(0,s.Z)(a,p);return(0,m.kt)("wrapper",(0,n.Z)({},c,t,{components:e,mdxType:"MDXLayout"}),(0,m.kt)("p",null,"We have already seen ",(0,m.kt)("a",{parentName:"p",href:"../fp/map-reduce"},"how to work with lists in a functional language"),".\nThe focus here will be on functional approaches to sorting lists; for simplicity we will work with lists of integers, although the techniques extend to any type with a total ordering relation."),(0,m.kt)("h2",{id:"insertion-sort"},"Insertion Sort"),(0,m.kt)("p",null,"One of the simplest methods for sorting a list is based on the ",(0,m.kt)("inlineCode",{parentName:"p"},"insert")," function, which adds one element in the correct position within an already sorted list.\nSuppose that ",(0,m.kt)("inlineCode",{parentName:"p"},"nums")," is a (possibly empty) list of numbers, arranged in non-decreasing order, and we wish to insert the number ",(0,m.kt)("inlineCode",{parentName:"p"},"n"),".\nIf ",(0,m.kt)("inlineCode",{parentName:"p"},"nums")," is empty, then the result will just be the list ",(0,m.kt)("inlineCode",{parentName:"p"},"[n]"),"; otherwise, split the list into a ",(0,m.kt)("inlineCode",{parentName:"p"},"head")," element (which must be the smallest) and a ",(0,m.kt)("inlineCode",{parentName:"p"},"tail")," list.\nIf ",(0,m.kt)("inlineCode",{parentName:"p"},"n")," is no larger than ",(0,m.kt)("inlineCode",{parentName:"p"},"head"),", then ",(0,m.kt)("inlineCode",{parentName:"p"},"n")," will be the smallest number overall, and we may insert it in front of ",(0,m.kt)("inlineCode",{parentName:"p"},"head"),".\nOn the other hand, if ",(0,m.kt)("inlineCode",{parentName:"p"},"n")," is larger than ",(0,m.kt)("inlineCode",{parentName:"p"},"head"),", then ",(0,m.kt)("inlineCode",{parentName:"p"},"head")," is still the smallest and must come first, while ",(0,m.kt)("inlineCode",{parentName:"p"},"n")," must be inserted somewhere in the ",(0,m.kt)("inlineCode",{parentName:"p"},"tail"),".\nHowever, inserting ",(0,m.kt)("inlineCode",{parentName:"p"},"n")," into the ",(0,m.kt)("inlineCode",{parentName:"p"},"tail")," is the same problem we started with (insert a number into a sorted list), except the list is smaller","\u2014","this is exactly the setup we need to make a recursive call to finish the job."),(0,m.kt)("p",null,"In code, here is the procedure we just described:"),(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-reason",metastring:"edit",edit:!0},"/* Precondition: nums is sorted in non-decreasing order */\nlet rec insert = (nums, n) => {\n  switch (nums) {\n  | [] => [n]\n  | [head, ...tail] =>\n    if (n <= head) {\n      [n, ...nums]\n    } else {\n      [head, ...insert(tail, n)]\n    }\n  }\n};\n\ninsert([], 42);\ninsert([63], 42);\ninsert([17, 63], 42);\ninsert([17, 39], 42);\n")),(0,m.kt)("p",null,"Once we have the ",(0,m.kt)("inlineCode",{parentName:"p"},"insert")," function, it is easy to build a sorting function based on it.\nIf we want to sort an empty list, then we are done.\nOtherwise, we have a non-empty list that may be split (using pattern matching) into a head and a tail.\nRecursively sorting the tail will give us a sorted list, and then we just need to insert the head into it:"),(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-reason",metastring:"edit",edit:!0},"let rec insertion_sort = nums => {\n  switch (nums) {\n  | [] => []\n  | [head, ...tail] => insert(insertion_sort(tail), head)\n  }\n};\n\ninsertion_sort([3, 1, 4, 1, 5, 9, 2, 6, 5]);\n")),(0,m.kt)("p",null,"Although this is simple, the call to ",(0,m.kt)("inlineCode",{parentName:"p"},"insertion_sort")," is not a tail-recursive call","\u2014","that is, the recursive call is not the last thing done, because it still needs to call ",(0,m.kt)("inlineCode",{parentName:"p"},"insert")," after the recursion finishes.\nThat can cause problems when the list is large, because each recursive call needs to be saved on the function-call stack and we run the danger of overflowing the stack."),(0,m.kt)("p",null,"Another approach is to traverse the list from left to right, building up a sorted list by inserting each successive element (thus the sorted list is an ",(0,m.kt)("strong",{parentName:"p"},"accumulator"),"\u2014","an extra argument that collects the result as the calculation proceeds; this is a common trick when making a function tail-recursive).\nBecause the last action of the ",(0,m.kt)("inlineCode",{parentName:"p"},"aux")," function in the recursive case is to call itself, this solution is properly tail-recursive",(0,m.kt)("sup",{parentName:"p",id:"fnref-1"},(0,m.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1")),"\nand the ReasonML compiler will be able to produce code that doesn't overflow the stack no matter how many numbers we are sorting.",(0,m.kt)("sup",{parentName:"p",id:"fnref-2"},(0,m.kt)("a",{parentName:"sup",href:"#fn-2",className:"footnote-ref"},"2"))),(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-reason",metastring:"edit",edit:!0},"let insertion_sort_left = nums => {\n  let rec aux = (sorted, nums) => {\n    switch (nums) {\n    | [] => sorted\n    | [head, ...tail] => aux(insert(sorted, head), tail)\n    }\n  };\n  aux([], nums)\n};\n\ninsertion_sort_left([3, 1, 4, 1, 5, 9, 2, 6, 5]);\n")),(0,m.kt)("p",null,"Note that the helper function here (",(0,m.kt)("inlineCode",{parentName:"p"},"aux"),") is essentially the same as the ",(0,m.kt)("inlineCode",{parentName:"p"},"reduce")," function we saw in the ",(0,m.kt)("a",{parentName:"p",href:"../fp/map-reduce"},"MapReduce")," section.\nThe ReasonML standard library provides the ",(0,m.kt)("inlineCode",{parentName:"p"},"reduce")," function under the name ",(0,m.kt)("inlineCode",{parentName:"p"},"List.fold_left"),", so we can also define insertion sort as:"),(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-reason",metastring:"edit",edit:!0},"let insertion_sort_left2 = nums => {\n  List.fold_left(insert, [], nums)\n};\n\ninsertion_sort_left2([3, 1, 4, 1, 5, 9, 2, 6, 5]);\n")),(0,m.kt)("p",null,"Using currying, we can simplify this to ",(0,m.kt)("inlineCode",{parentName:"p"},"let insertion_sort_left2 = List.fold_left(insert, [])"),"."),(0,m.kt)("h2",{id:"selection-sort"},"Selection Sort"),(0,m.kt)("p",null,'Instead of having to go through the list to find the correct insertion point each time we want to add a number to the sorted list, we might try to do more work "up front" and choose the numbers to be added in the correct order.\nThis is the idea behind ',(0,m.kt)("strong",{parentName:"p"},"selection sort"),": given a non-empty list of numbers, if we can separate the smallest number from the rest, then that number will definitely be the head of the resulting sorted list and we will never have to adjust its position during the rest of the sorting operation.\nSo, our first goal is to write a ",(0,m.kt)("inlineCode",{parentName:"p"},"select")," function that takes a non-empty list and splits it into the smallest element plus a list of all of the other elements."),(0,m.kt)("p",null,"We may approach this using recursion: to find the smallest element in the list, first find the smallest element in the tail of the list (if any), then compare it against the head and keep the smaller of the two.\nThe result should be a pair of the smallest element plus a list of all of the other elements.\nThis leads to the following code:"),(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-reason",metastring:"edit",edit:!0},"/* Precondition: nums is non-empty */\nlet rec select = nums => {\n  switch (nums) {\n  | [n] => (n, [])\n  | [head, ...tail] => {\n      /* We know that tail is non-empty */\n      let (small, rest) = select(tail);\n      if (head <= small) {\n        (head, tail)\n      } else {\n        (small, [head, ...rest])\n      }\n    }\n  }\n};\n\nselect([42]);\nselect([3, 1, 4, 1, 5, 9, 2, 6, 5]);\n")),(0,m.kt)("p",null,"Note that it only makes sense to call ",(0,m.kt)("inlineCode",{parentName:"p"},"select")," on a non-empty list, so we must make sure that we satisfy that precondition when making the recursive call.\nReasonML warns us that we are not handling all of the cases with our patterns, but we may ignore the warning here."),(0,m.kt)("p",null,"The ",(0,m.kt)("inlineCode",{parentName:"p"},"select")," function is not tail-recursive, so again we might look for an alternate way to compute it using an accumulator and a helper function.\nThink of the usual process of searching a list for the smallest element: choose the first element as our initial guess, and then examine each of the rest of the numbers, refining our guess whenever we find a smaller element.\nIf our accumulator is the pair consisting of the smallest element seen so far (our current guess), plus a list of all of the other numbers examined, then we can view the selection process as a left-to-right reduction:"),(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-reason",metastring:"edit",edit:!0},"/* Precondition: nums is non-empty */\nlet select_left = nums => {\n  let rec aux = (nums, accum) => {\n    switch (nums) {\n    | [] => accum\n    | [head, ...tail] => {\n        let (small, rest) = accum;\n        if (head < small) {\n          aux(tail, (head, [small, ...rest]))\n        } else {\n          aux(tail, (small, [head, ...rest]))\n        }\n      }\n    }\n  };\n  \n  switch (nums) {\n  | [head, ...tail] => aux(tail, (head, []))\n  }\n};\n\nselect_left([42]);\nselect_left([3, 1, 4, 1, 5, 9, 2, 6, 5]);\n")),(0,m.kt)("p",null,"Once we have a selection function, the selection sort is easy to write recursively:"),(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-reason",metastring:"edit",edit:!0},"let rec selection_sort = nums => {\n  switch (nums) {\n  | [] => []\n  | _ => {\n      let (small, rest) = select(nums);\n      [small, ...selection_sort(rest)]\n    }\n  }\n};\n\nselection_sort([3, 1, 4, 1, 5, 9, 2, 6, 5]);\n")),(0,m.kt)("p",null,"One of the exercises asks you to find a way to write this using tail-recursion."),(0,m.kt)("h2",{id:"running-time-of-insertion-and-selection-sort"},"Running Time of Insertion and Selection Sort"),(0,m.kt)("p",null,"The ",(0,m.kt)("inlineCode",{parentName:"p"},"insert")," and ",(0,m.kt)("inlineCode",{parentName:"p"},"select")," functions each make a pass through all of the elements in their list argument, at least in the worst case (insertion will stop early if it finds the correct position, but selection needs to examine the entire list).\nWhen doing an insertion sort, the ",(0,m.kt)("inlineCode",{parentName:"p"},"insert")," function is called on successively longer lists, so its running time will be proportional to the sum ",(0,m.kt)("span",{parentName:"p",className:"math math-inline"},(0,m.kt)("span",{parentName:"span",className:"katex"},(0,m.kt)("span",{parentName:"span",className:"katex-mathml"},(0,m.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,m.kt)("semantics",{parentName:"math"},(0,m.kt)("mrow",{parentName:"semantics"},(0,m.kt)("mn",{parentName:"mrow"},"1"),(0,m.kt)("mo",{parentName:"mrow"},"+"),(0,m.kt)("mn",{parentName:"mrow"},"2"),(0,m.kt)("mo",{parentName:"mrow"},"+"),(0,m.kt)("mo",{parentName:"mrow"},"\u2026"),(0,m.kt)("mo",{parentName:"mrow"},"+"),(0,m.kt)("mi",{parentName:"mrow"},"N")),(0,m.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"1+2+\\ldots+N")))),(0,m.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"0.72777em",verticalAlign:"-0.08333em"}}),(0,m.kt)("span",{parentName:"span",className:"mord"},"1"),(0,m.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}}),(0,m.kt)("span",{parentName:"span",className:"mbin"},"+"),(0,m.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}})),(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"0.72777em",verticalAlign:"-0.08333em"}}),(0,m.kt)("span",{parentName:"span",className:"mord"},"2"),(0,m.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}}),(0,m.kt)("span",{parentName:"span",className:"mbin"},"+"),(0,m.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}})),(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"0.66666em",verticalAlign:"-0.08333em"}}),(0,m.kt)("span",{parentName:"span",className:"minner"},"\u2026"),(0,m.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}}),(0,m.kt)("span",{parentName:"span",className:"mbin"},"+"),(0,m.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}})),(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}}),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N"))))),", where ",(0,m.kt)("span",{parentName:"p",className:"math math-inline"},(0,m.kt)("span",{parentName:"span",className:"katex"},(0,m.kt)("span",{parentName:"span",className:"katex-mathml"},(0,m.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,m.kt)("semantics",{parentName:"math"},(0,m.kt)("mrow",{parentName:"semantics"},(0,m.kt)("mi",{parentName:"mrow"},"N")),(0,m.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"N")))),(0,m.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}}),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N")))))," is the size of the list to be sorted. We have seen that this sum is ",(0,m.kt)("span",{parentName:"p",className:"math math-inline"},(0,m.kt)("span",{parentName:"span",className:"katex"},(0,m.kt)("span",{parentName:"span",className:"katex-mathml"},(0,m.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,m.kt)("semantics",{parentName:"math"},(0,m.kt)("mrow",{parentName:"semantics"},(0,m.kt)("mfrac",{parentName:"mrow"},(0,m.kt)("mrow",{parentName:"mfrac"},(0,m.kt)("mi",{parentName:"mrow"},"N"),(0,m.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,m.kt)("mi",{parentName:"mrow"},"N"),(0,m.kt)("mo",{parentName:"mrow"},"+"),(0,m.kt)("mn",{parentName:"mrow"},"1"),(0,m.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,m.kt)("mn",{parentName:"mfrac"},"2"))),(0,m.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\frac{N(N+1)}{2}")))),(0,m.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"1.355em",verticalAlign:"-0.345em"}}),(0,m.kt)("span",{parentName:"span",className:"mord"},(0,m.kt)("span",{parentName:"span",className:"mopen nulldelimiter"}),(0,m.kt)("span",{parentName:"span",className:"mfrac"},(0,m.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,m.kt)("span",{parentName:"span",className:"vlist-r"},(0,m.kt)("span",{parentName:"span",className:"vlist",style:{height:"1.01em"}},(0,m.kt)("span",{parentName:"span",style:{top:"-2.6550000000000002em"}},(0,m.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3em"}}),(0,m.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,m.kt)("span",{parentName:"span",className:"mord mtight"},(0,m.kt)("span",{parentName:"span",className:"mord mtight"},"2")))),(0,m.kt)("span",{parentName:"span",style:{top:"-3.23em"}},(0,m.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3em"}}),(0,m.kt)("span",{parentName:"span",className:"frac-line",style:{borderBottomWidth:"0.04em"}})),(0,m.kt)("span",{parentName:"span",style:{top:"-3.485em"}},(0,m.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3em"}}),(0,m.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,m.kt)("span",{parentName:"span",className:"mord mtight"},(0,m.kt)("span",{parentName:"span",className:"mord mathdefault mtight",style:{marginRight:"0.10903em"}},"N"),(0,m.kt)("span",{parentName:"span",className:"mopen mtight"},"("),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault mtight",style:{marginRight:"0.10903em"}},"N"),(0,m.kt)("span",{parentName:"span",className:"mbin mtight"},"+"),(0,m.kt)("span",{parentName:"span",className:"mord mtight"},"1"),(0,m.kt)("span",{parentName:"span",className:"mclose mtight"},")"))))),(0,m.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,m.kt)("span",{parentName:"span",className:"vlist-r"},(0,m.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.345em"}},(0,m.kt)("span",{parentName:"span"}))))),(0,m.kt)("span",{parentName:"span",className:"mclose nulldelimiter"})))))),", which is quadratic in ",(0,m.kt)("span",{parentName:"p",className:"math math-inline"},(0,m.kt)("span",{parentName:"span",className:"katex"},(0,m.kt)("span",{parentName:"span",className:"katex-mathml"},(0,m.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,m.kt)("semantics",{parentName:"math"},(0,m.kt)("mrow",{parentName:"semantics"},(0,m.kt)("mi",{parentName:"mrow"},"N")),(0,m.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"N")))),(0,m.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}}),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N")))))," (",(0,m.kt)("em",{parentName:"p"},"i.e."),", we say that it is ",(0,m.kt)("span",{parentName:"p",className:"math math-inline"},(0,m.kt)("span",{parentName:"span",className:"katex"},(0,m.kt)("span",{parentName:"span",className:"katex-mathml"},(0,m.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,m.kt)("semantics",{parentName:"math"},(0,m.kt)("mrow",{parentName:"semantics"},(0,m.kt)("mi",{parentName:"mrow"},"O"),(0,m.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,m.kt)("msup",{parentName:"mrow"},(0,m.kt)("mi",{parentName:"msup"},"N"),(0,m.kt)("mn",{parentName:"msup"},"2")),(0,m.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,m.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(N^2)")))),(0,m.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"1.064108em",verticalAlign:"-0.25em"}}),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.02778em"}},"O"),(0,m.kt)("span",{parentName:"span",className:"mopen"},"("),(0,m.kt)("span",{parentName:"span",className:"mord"},(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N"),(0,m.kt)("span",{parentName:"span",className:"msupsub"},(0,m.kt)("span",{parentName:"span",className:"vlist-t"},(0,m.kt)("span",{parentName:"span",className:"vlist-r"},(0,m.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8141079999999999em"}},(0,m.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,m.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,m.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,m.kt)("span",{parentName:"span",className:"mord mtight"},"2")))))))),(0,m.kt)("span",{parentName:"span",className:"mclose"},")"))))),"). Similarly, when doing a selection sort, the ",(0,m.kt)("inlineCode",{parentName:"p"},"select")," function is initially called on a list of size ",(0,m.kt)("span",{parentName:"p",className:"math math-inline"},(0,m.kt)("span",{parentName:"span",className:"katex"},(0,m.kt)("span",{parentName:"span",className:"katex-mathml"},(0,m.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,m.kt)("semantics",{parentName:"math"},(0,m.kt)("mrow",{parentName:"semantics"},(0,m.kt)("mi",{parentName:"mrow"},"N")),(0,m.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"N")))),(0,m.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}}),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N"))))),", and then on successively smaller lists: ",(0,m.kt)("span",{parentName:"p",className:"math math-inline"},(0,m.kt)("span",{parentName:"span",className:"katex"},(0,m.kt)("span",{parentName:"span",className:"katex-mathml"},(0,m.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,m.kt)("semantics",{parentName:"math"},(0,m.kt)("mrow",{parentName:"semantics"},(0,m.kt)("mi",{parentName:"mrow"},"N"),(0,m.kt)("mo",{parentName:"mrow"},"+"),(0,m.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,m.kt)("mi",{parentName:"mrow"},"N"),(0,m.kt)("mo",{parentName:"mrow"},"\u2212"),(0,m.kt)("mn",{parentName:"mrow"},"1"),(0,m.kt)("mo",{parentName:"mrow",stretchy:"false"},")"),(0,m.kt)("mo",{parentName:"mrow"},"+"),(0,m.kt)("mo",{parentName:"mrow"},"\u2026"),(0,m.kt)("mo",{parentName:"mrow"},"+"),(0,m.kt)("mn",{parentName:"mrow"},"2"),(0,m.kt)("mo",{parentName:"mrow"},"+"),(0,m.kt)("mn",{parentName:"mrow"},"1")),(0,m.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"N+(N-1)+\\ldots+2+1")))),(0,m.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"0.76666em",verticalAlign:"-0.08333em"}}),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N"),(0,m.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}}),(0,m.kt)("span",{parentName:"span",className:"mbin"},"+"),(0,m.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}})),(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,m.kt)("span",{parentName:"span",className:"mopen"},"("),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N"),(0,m.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}}),(0,m.kt)("span",{parentName:"span",className:"mbin"},"\u2212"),(0,m.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}})),(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,m.kt)("span",{parentName:"span",className:"mord"},"1"),(0,m.kt)("span",{parentName:"span",className:"mclose"},")"),(0,m.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}}),(0,m.kt)("span",{parentName:"span",className:"mbin"},"+"),(0,m.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}})),(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"0.66666em",verticalAlign:"-0.08333em"}}),(0,m.kt)("span",{parentName:"span",className:"minner"},"\u2026"),(0,m.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}}),(0,m.kt)("span",{parentName:"span",className:"mbin"},"+"),(0,m.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}})),(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"0.72777em",verticalAlign:"-0.08333em"}}),(0,m.kt)("span",{parentName:"span",className:"mord"},"2"),(0,m.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}}),(0,m.kt)("span",{parentName:"span",className:"mbin"},"+"),(0,m.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}})),(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"0.64444em",verticalAlign:"0em"}}),(0,m.kt)("span",{parentName:"span",className:"mord"},"1"))))),", which is the same sum in reverse."),(0,m.kt)("p",null,"Therefore, the worst-case running time of both sorting algorithms is ",(0,m.kt)("span",{parentName:"p",className:"math math-inline"},(0,m.kt)("span",{parentName:"span",className:"katex"},(0,m.kt)("span",{parentName:"span",className:"katex-mathml"},(0,m.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,m.kt)("semantics",{parentName:"math"},(0,m.kt)("mrow",{parentName:"semantics"},(0,m.kt)("mi",{parentName:"mrow"},"O"),(0,m.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,m.kt)("msup",{parentName:"mrow"},(0,m.kt)("mi",{parentName:"msup"},"N"),(0,m.kt)("mn",{parentName:"msup"},"2")),(0,m.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,m.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(N^2)")))),(0,m.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"1.064108em",verticalAlign:"-0.25em"}}),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.02778em"}},"O"),(0,m.kt)("span",{parentName:"span",className:"mopen"},"("),(0,m.kt)("span",{parentName:"span",className:"mord"},(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N"),(0,m.kt)("span",{parentName:"span",className:"msupsub"},(0,m.kt)("span",{parentName:"span",className:"vlist-t"},(0,m.kt)("span",{parentName:"span",className:"vlist-r"},(0,m.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8141079999999999em"}},(0,m.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,m.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,m.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,m.kt)("span",{parentName:"span",className:"mord mtight"},"2")))))))),(0,m.kt)("span",{parentName:"span",className:"mclose"},")"))))),", and they are known as ",(0,m.kt)("strong",{parentName:"p"},"quadratic sorts"),". The average case for insertion sort might seem to be better, because on average the insertion process will only have to traverse half of the list to find the correct insertion point (as long as the input is random).\nHowever, that gives us a running time proportional to ",(0,m.kt)("span",{parentName:"p",className:"math math-inline"},(0,m.kt)("span",{parentName:"span",className:"katex"},(0,m.kt)("span",{parentName:"span",className:"katex-mathml"},(0,m.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,m.kt)("semantics",{parentName:"math"},(0,m.kt)("mrow",{parentName:"semantics"},(0,m.kt)("mfrac",{parentName:"mrow"},(0,m.kt)("mn",{parentName:"mfrac"},"1"),(0,m.kt)("mn",{parentName:"mfrac"},"4")),(0,m.kt)("msup",{parentName:"mrow"},(0,m.kt)("mi",{parentName:"msup"},"N"),(0,m.kt)("mn",{parentName:"msup"},"2"))),(0,m.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\frac{1}{4}N^2")))),(0,m.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"1.190108em",verticalAlign:"-0.345em"}}),(0,m.kt)("span",{parentName:"span",className:"mord"},(0,m.kt)("span",{parentName:"span",className:"mopen nulldelimiter"}),(0,m.kt)("span",{parentName:"span",className:"mfrac"},(0,m.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,m.kt)("span",{parentName:"span",className:"vlist-r"},(0,m.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.845108em"}},(0,m.kt)("span",{parentName:"span",style:{top:"-2.6550000000000002em"}},(0,m.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3em"}}),(0,m.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,m.kt)("span",{parentName:"span",className:"mord mtight"},(0,m.kt)("span",{parentName:"span",className:"mord mtight"},"4")))),(0,m.kt)("span",{parentName:"span",style:{top:"-3.23em"}},(0,m.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3em"}}),(0,m.kt)("span",{parentName:"span",className:"frac-line",style:{borderBottomWidth:"0.04em"}})),(0,m.kt)("span",{parentName:"span",style:{top:"-3.394em"}},(0,m.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3em"}}),(0,m.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,m.kt)("span",{parentName:"span",className:"mord mtight"},(0,m.kt)("span",{parentName:"span",className:"mord mtight"},"1"))))),(0,m.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,m.kt)("span",{parentName:"span",className:"vlist-r"},(0,m.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.345em"}},(0,m.kt)("span",{parentName:"span"}))))),(0,m.kt)("span",{parentName:"span",className:"mclose nulldelimiter"})),(0,m.kt)("span",{parentName:"span",className:"mord"},(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N"),(0,m.kt)("span",{parentName:"span",className:"msupsub"},(0,m.kt)("span",{parentName:"span",className:"vlist-t"},(0,m.kt)("span",{parentName:"span",className:"vlist-r"},(0,m.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8141079999999999em"}},(0,m.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,m.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,m.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,m.kt)("span",{parentName:"span",className:"mord mtight"},"2")))))))))))),", which is still quadratic.\nFor lists with millions of items, a quadratic sort will perform trillions of operations, which might be too long to wait (even at a billion operations per second, that could easily take on the order of an hour).\nSo, we might wonder if there is a faster approach to such a fundamental operation as sorting."),(0,m.kt)("h2",{id:"merge-sort"},"Merge Sort"),(0,m.kt)("p",null,"Instead of inserting one element at a time into a sorted list, the strategy for merge sort is to insert an entire sorted collection of items in a single operation.\nSince the items are in order, we know that after finding the correct insertion position for one item we can start looking from there for the next item's position, without having to start back at the beginning.\nIf we are merging two sorted lists, each of size ",(0,m.kt)("span",{parentName:"p",className:"math math-inline"},(0,m.kt)("span",{parentName:"span",className:"katex"},(0,m.kt)("span",{parentName:"span",className:"katex-mathml"},(0,m.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,m.kt)("semantics",{parentName:"math"},(0,m.kt)("mrow",{parentName:"semantics"},(0,m.kt)("mi",{parentName:"mrow"},"N")),(0,m.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"N")))),(0,m.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}}),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N"))))),", then the total time taken will be ",(0,m.kt)("span",{parentName:"p",className:"math math-inline"},(0,m.kt)("span",{parentName:"span",className:"katex"},(0,m.kt)("span",{parentName:"span",className:"katex-mathml"},(0,m.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,m.kt)("semantics",{parentName:"math"},(0,m.kt)("mrow",{parentName:"semantics"},(0,m.kt)("mi",{parentName:"mrow"},"O"),(0,m.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,m.kt)("mi",{parentName:"mrow"},"N"),(0,m.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,m.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(N)")))),(0,m.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.02778em"}},"O"),(0,m.kt)("span",{parentName:"span",className:"mopen"},"("),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N"),(0,m.kt)("span",{parentName:"span",className:"mclose"},")")))))," instead of the ",(0,m.kt)("span",{parentName:"p",className:"math math-inline"},(0,m.kt)("span",{parentName:"span",className:"katex"},(0,m.kt)("span",{parentName:"span",className:"katex-mathml"},(0,m.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,m.kt)("semantics",{parentName:"math"},(0,m.kt)("mrow",{parentName:"semantics"},(0,m.kt)("mi",{parentName:"mrow"},"O"),(0,m.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,m.kt)("msup",{parentName:"mrow"},(0,m.kt)("mi",{parentName:"msup"},"N"),(0,m.kt)("mn",{parentName:"msup"},"2")),(0,m.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,m.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(N^2)")))),(0,m.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"1.064108em",verticalAlign:"-0.25em"}}),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.02778em"}},"O"),(0,m.kt)("span",{parentName:"span",className:"mopen"},"("),(0,m.kt)("span",{parentName:"span",className:"mord"},(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N"),(0,m.kt)("span",{parentName:"span",className:"msupsub"},(0,m.kt)("span",{parentName:"span",className:"vlist-t"},(0,m.kt)("span",{parentName:"span",className:"vlist-r"},(0,m.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8141079999999999em"}},(0,m.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,m.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,m.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,m.kt)("span",{parentName:"span",className:"mord mtight"},"2")))))))),(0,m.kt)("span",{parentName:"span",className:"mclose"},")")))))," required to insert ",(0,m.kt)("span",{parentName:"p",className:"math math-inline"},(0,m.kt)("span",{parentName:"span",className:"katex"},(0,m.kt)("span",{parentName:"span",className:"katex-mathml"},(0,m.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,m.kt)("semantics",{parentName:"math"},(0,m.kt)("mrow",{parentName:"semantics"},(0,m.kt)("mi",{parentName:"mrow"},"N")),(0,m.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"N")))),(0,m.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}}),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N")))))," items one at a time.\nOf course, we still need to sort each of the lists being merged, but since these are each only half the size of the total collection of elements we can treat that as a smaller problem to be solved recursively."),(0,m.kt)("p",null,"First, here is a recursive ",(0,m.kt)("inlineCode",{parentName:"p"},"merge")," function:"),(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-reason",metastring:"edit",edit:!0},"/* Precondition: nums1 and nums2 are both sorted in increasing order */\nlet rec merge = (nums1, nums2) => {\n  switch (nums1, nums2) {\n  | ([], _) => nums2\n  | (_, []) => nums1\n  | ([head1, ...tail1], [head2, ...tail2]) =>\n    if (head1 <= head2) {\n      [head1, ...merge(tail1, nums2)]\n    } else {\n      [head2, ...merge(nums1, tail2)]\n    }\n  }\n};\n\nmerge([2, 3, 5, 7], [1, 2, 4, 8]);\n")),(0,m.kt)("p",null,"In words, if either list is empty, then the result is the other list. Otherwise, look at the heads of each list; the resulting merged list will start with the smaller of the two heads, followed by a merge of the tail following the smaller head with the entire other list.\n(As a challenge, see if you can write a tail-recursive version of ",(0,m.kt)("inlineCode",{parentName:"p"},"merge"),"; as a hint, you might want to make use of the ",(0,m.kt)("inlineCode",{parentName:"p"},"reverse")," function discussed in the section on ",(0,m.kt)("a",{parentName:"p",href:"../fp/map-reduce#accumulators"},"accumulators"),")."),(0,m.kt)("p",null,"The first part of the merge sort algorithm is to split the input list into two halves (provided there is more than one element), then recursively sort the halves to prepare for merging.\nOne way to split a list into halves is to calculate the size of the list, then count off the first half of them into one list and the rest into another (an exercise below asks you to implement this).\nHowever, because we do not care about the order of the incoming data, a more efficient approach is to walk through the list, alternately putting elements into one or the other of the halves (which are built up in an accumulator containing a pair of lists):"),(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-reason",metastring:"edit",edit:!0},"let split = nums => {\n  let rec aux = (nums, (left, right)) => {\n    switch (nums) {\n    | [] => (left, right)\n    | [head, ...tail] => aux(tail, (right, [head, ...left]))\n    }\n  }\n  aux(nums, ([], []))\n};\n\nsplit([]);\nsplit([1]);\nsplit([1, 2]);\nsplit([1, 2, 3]);\nsplit([1, 2, 3, 4]);\n")),(0,m.kt)("p",null,"Putting the pieces together then, we get the following ",(0,m.kt)("inlineCode",{parentName:"p"},"merge_sort")," function:"),(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-reason",metastring:"edit",edit:!0},"let rec merge_sort = nums => {\n  let (left, right) = split(nums);\n  switch (left) { /* base case if left is empty */\n  | [] => nums\n  | _ => merge(merge_sort(left), merge_sort(right))\n  }\n};\n\nmerge_sort([3, 1, 4, 1, 5, 9, 2, 6, 5]);\n")),(0,m.kt)("p",null,"Note that ",(0,m.kt)("inlineCode",{parentName:"p"},"merge_sort")," makes two recursive calls to itself, so there is no easy way to make it entirely tail-recursive.\nThis is not a problem, though, because we know that the number of times that a list of ",(0,m.kt)("span",{parentName:"p",className:"math math-inline"},(0,m.kt)("span",{parentName:"span",className:"katex"},(0,m.kt)("span",{parentName:"span",className:"katex-mathml"},(0,m.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,m.kt)("semantics",{parentName:"math"},(0,m.kt)("mrow",{parentName:"semantics"},(0,m.kt)("mi",{parentName:"mrow"},"N")),(0,m.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"N")))),(0,m.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}}),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N")))))," elements can be split in two before hitting the base case is just ",(0,m.kt)("span",{parentName:"p",className:"math math-inline"},(0,m.kt)("span",{parentName:"span",className:"katex"},(0,m.kt)("span",{parentName:"span",className:"katex-mathml"},(0,m.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,m.kt)("semantics",{parentName:"math"},(0,m.kt)("mrow",{parentName:"semantics"},(0,m.kt)("msub",{parentName:"mrow"},(0,m.kt)("mo",{parentName:"msub"},(0,m.kt)("mi",{parentName:"mo"},"log"),(0,m.kt)("mo",{parentName:"mo"},"\u2061")),(0,m.kt)("mn",{parentName:"msub"},"2")),(0,m.kt)("mi",{parentName:"mrow"},"N")),(0,m.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\log_2 N")))),(0,m.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"0.93858em",verticalAlign:"-0.24414em"}}),(0,m.kt)("span",{parentName:"span",className:"mop"},(0,m.kt)("span",{parentName:"span",className:"mop"},"lo",(0,m.kt)("span",{parentName:"span",style:{marginRight:"0.01389em"}},"g")),(0,m.kt)("span",{parentName:"span",className:"msupsub"},(0,m.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,m.kt)("span",{parentName:"span",className:"vlist-r"},(0,m.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.20696799999999996em"}},(0,m.kt)("span",{parentName:"span",style:{top:"-2.4558600000000004em",marginRight:"0.05em"}},(0,m.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,m.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,m.kt)("span",{parentName:"span",className:"mord mtight"},"2")))),(0,m.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,m.kt)("span",{parentName:"span",className:"vlist-r"},(0,m.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.24414em"}},(0,m.kt)("span",{parentName:"span"})))))),(0,m.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N"))))),";\neven if ",(0,m.kt)("span",{parentName:"p",className:"math math-inline"},(0,m.kt)("span",{parentName:"span",className:"katex"},(0,m.kt)("span",{parentName:"span",className:"katex-mathml"},(0,m.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,m.kt)("semantics",{parentName:"math"},(0,m.kt)("mrow",{parentName:"semantics"},(0,m.kt)("mi",{parentName:"mrow"},"N")),(0,m.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"N")))),(0,m.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}}),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N")))))," is one million, this is only around 20, so the stack will never get very deep with recursive calls to ",(0,m.kt)("inlineCode",{parentName:"p"},"merge_sort"),"."),(0,m.kt)("p",null,"This observation allows us to compute the expected running time of merge sort: splitting and merging ",(0,m.kt)("span",{parentName:"p",className:"math math-inline"},(0,m.kt)("span",{parentName:"span",className:"katex"},(0,m.kt)("span",{parentName:"span",className:"katex-mathml"},(0,m.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,m.kt)("semantics",{parentName:"math"},(0,m.kt)("mrow",{parentName:"semantics"},(0,m.kt)("mi",{parentName:"mrow"},"N")),(0,m.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"N")))),(0,m.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}}),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N")))))," items can be done in ",(0,m.kt)("span",{parentName:"p",className:"math math-inline"},(0,m.kt)("span",{parentName:"span",className:"katex"},(0,m.kt)("span",{parentName:"span",className:"katex-mathml"},(0,m.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,m.kt)("semantics",{parentName:"math"},(0,m.kt)("mrow",{parentName:"semantics"},(0,m.kt)("mi",{parentName:"mrow"},"O"),(0,m.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,m.kt)("mi",{parentName:"mrow"},"N"),(0,m.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,m.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(N)")))),(0,m.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.02778em"}},"O"),(0,m.kt)("span",{parentName:"span",className:"mopen"},"("),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N"),(0,m.kt)("span",{parentName:"span",className:"mclose"},")")))))," time, and there will be ",(0,m.kt)("span",{parentName:"p",className:"math math-inline"},(0,m.kt)("span",{parentName:"span",className:"katex"},(0,m.kt)("span",{parentName:"span",className:"katex-mathml"},(0,m.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,m.kt)("semantics",{parentName:"math"},(0,m.kt)("mrow",{parentName:"semantics"},(0,m.kt)("mi",{parentName:"mrow"},"O"),(0,m.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,m.kt)("mi",{parentName:"mrow"},"log"),(0,m.kt)("mo",{parentName:"mrow"},"\u2061"),(0,m.kt)("mi",{parentName:"mrow"},"N"),(0,m.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,m.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(\\log N)")))),(0,m.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.02778em"}},"O"),(0,m.kt)("span",{parentName:"span",className:"mopen"},"("),(0,m.kt)("span",{parentName:"span",className:"mop"},"lo",(0,m.kt)("span",{parentName:"span",style:{marginRight:"0.01389em"}},"g")),(0,m.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N"),(0,m.kt)("span",{parentName:"span",className:"mclose"},")")))))," levels of recursion (at the second level, there will be two lists of size ",(0,m.kt)("span",{parentName:"p",className:"math math-inline"},(0,m.kt)("span",{parentName:"span",className:"katex"},(0,m.kt)("span",{parentName:"span",className:"katex-mathml"},(0,m.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,m.kt)("semantics",{parentName:"math"},(0,m.kt)("mrow",{parentName:"semantics"},(0,m.kt)("mfrac",{parentName:"mrow"},(0,m.kt)("mi",{parentName:"mfrac"},"N"),(0,m.kt)("mn",{parentName:"mfrac"},"2"))),(0,m.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\frac{N}{2}")))),(0,m.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"1.217331em",verticalAlign:"-0.345em"}}),(0,m.kt)("span",{parentName:"span",className:"mord"},(0,m.kt)("span",{parentName:"span",className:"mopen nulldelimiter"}),(0,m.kt)("span",{parentName:"span",className:"mfrac"},(0,m.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,m.kt)("span",{parentName:"span",className:"vlist-r"},(0,m.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.872331em"}},(0,m.kt)("span",{parentName:"span",style:{top:"-2.6550000000000002em"}},(0,m.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3em"}}),(0,m.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,m.kt)("span",{parentName:"span",className:"mord mtight"},(0,m.kt)("span",{parentName:"span",className:"mord mtight"},"2")))),(0,m.kt)("span",{parentName:"span",style:{top:"-3.23em"}},(0,m.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3em"}}),(0,m.kt)("span",{parentName:"span",className:"frac-line",style:{borderBottomWidth:"0.04em"}})),(0,m.kt)("span",{parentName:"span",style:{top:"-3.394em"}},(0,m.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3em"}}),(0,m.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,m.kt)("span",{parentName:"span",className:"mord mtight"},(0,m.kt)("span",{parentName:"span",className:"mord mathdefault mtight",style:{marginRight:"0.10903em"}},"N"))))),(0,m.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,m.kt)("span",{parentName:"span",className:"vlist-r"},(0,m.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.345em"}},(0,m.kt)("span",{parentName:"span"}))))),(0,m.kt)("span",{parentName:"span",className:"mclose nulldelimiter"}))))))," to split and merge, at the third there will be four lists of size ",(0,m.kt)("span",{parentName:"p",className:"math math-inline"},(0,m.kt)("span",{parentName:"span",className:"katex"},(0,m.kt)("span",{parentName:"span",className:"katex-mathml"},(0,m.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,m.kt)("semantics",{parentName:"math"},(0,m.kt)("mrow",{parentName:"semantics"},(0,m.kt)("mfrac",{parentName:"mrow"},(0,m.kt)("mi",{parentName:"mfrac"},"N"),(0,m.kt)("mn",{parentName:"mfrac"},"4"))),(0,m.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\frac{N}{4}")))),(0,m.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"1.217331em",verticalAlign:"-0.345em"}}),(0,m.kt)("span",{parentName:"span",className:"mord"},(0,m.kt)("span",{parentName:"span",className:"mopen nulldelimiter"}),(0,m.kt)("span",{parentName:"span",className:"mfrac"},(0,m.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,m.kt)("span",{parentName:"span",className:"vlist-r"},(0,m.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.872331em"}},(0,m.kt)("span",{parentName:"span",style:{top:"-2.6550000000000002em"}},(0,m.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3em"}}),(0,m.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,m.kt)("span",{parentName:"span",className:"mord mtight"},(0,m.kt)("span",{parentName:"span",className:"mord mtight"},"4")))),(0,m.kt)("span",{parentName:"span",style:{top:"-3.23em"}},(0,m.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3em"}}),(0,m.kt)("span",{parentName:"span",className:"frac-line",style:{borderBottomWidth:"0.04em"}})),(0,m.kt)("span",{parentName:"span",style:{top:"-3.394em"}},(0,m.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3em"}}),(0,m.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,m.kt)("span",{parentName:"span",className:"mord mtight"},(0,m.kt)("span",{parentName:"span",className:"mord mathdefault mtight",style:{marginRight:"0.10903em"}},"N"))))),(0,m.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,m.kt)("span",{parentName:"span",className:"vlist-r"},(0,m.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.345em"}},(0,m.kt)("span",{parentName:"span"}))))),(0,m.kt)("span",{parentName:"span",className:"mclose nulldelimiter"})))))),", ",(0,m.kt)("em",{parentName:"p"},"etc."),", but that is still ",(0,m.kt)("span",{parentName:"p",className:"math math-inline"},(0,m.kt)("span",{parentName:"span",className:"katex"},(0,m.kt)("span",{parentName:"span",className:"katex-mathml"},(0,m.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,m.kt)("semantics",{parentName:"math"},(0,m.kt)("mrow",{parentName:"semantics"},(0,m.kt)("mi",{parentName:"mrow"},"O"),(0,m.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,m.kt)("mi",{parentName:"mrow"},"N"),(0,m.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,m.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(N)")))),(0,m.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.02778em"}},"O"),(0,m.kt)("span",{parentName:"span",className:"mopen"},"("),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N"),(0,m.kt)("span",{parentName:"span",className:"mclose"},")")))))," overall at each level), so the total expected running time is ",(0,m.kt)("span",{parentName:"p",className:"math math-inline"},(0,m.kt)("span",{parentName:"span",className:"katex"},(0,m.kt)("span",{parentName:"span",className:"katex-mathml"},(0,m.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,m.kt)("semantics",{parentName:"math"},(0,m.kt)("mrow",{parentName:"semantics"},(0,m.kt)("mi",{parentName:"mrow"},"O"),(0,m.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,m.kt)("mi",{parentName:"mrow"},"N"),(0,m.kt)("mi",{parentName:"mrow"},"log"),(0,m.kt)("mo",{parentName:"mrow"},"\u2061"),(0,m.kt)("mi",{parentName:"mrow"},"N"),(0,m.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,m.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(N\\log N)")))),(0,m.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.02778em"}},"O"),(0,m.kt)("span",{parentName:"span",className:"mopen"},"("),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N"),(0,m.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,m.kt)("span",{parentName:"span",className:"mop"},"lo",(0,m.kt)("span",{parentName:"span",style:{marginRight:"0.01389em"}},"g")),(0,m.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N"),(0,m.kt)("span",{parentName:"span",className:"mclose"},")"))))),", which is considerably better than ",(0,m.kt)("span",{parentName:"p",className:"math math-inline"},(0,m.kt)("span",{parentName:"span",className:"katex"},(0,m.kt)("span",{parentName:"span",className:"katex-mathml"},(0,m.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,m.kt)("semantics",{parentName:"math"},(0,m.kt)("mrow",{parentName:"semantics"},(0,m.kt)("mi",{parentName:"mrow"},"O"),(0,m.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,m.kt)("msup",{parentName:"mrow"},(0,m.kt)("mi",{parentName:"msup"},"N"),(0,m.kt)("mn",{parentName:"msup"},"2")),(0,m.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,m.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(N^2)")))),(0,m.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"1.064108em",verticalAlign:"-0.25em"}}),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.02778em"}},"O"),(0,m.kt)("span",{parentName:"span",className:"mopen"},"("),(0,m.kt)("span",{parentName:"span",className:"mord"},(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N"),(0,m.kt)("span",{parentName:"span",className:"msupsub"},(0,m.kt)("span",{parentName:"span",className:"vlist-t"},(0,m.kt)("span",{parentName:"span",className:"vlist-r"},(0,m.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8141079999999999em"}},(0,m.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,m.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,m.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,m.kt)("span",{parentName:"span",className:"mord mtight"},"2")))))))),(0,m.kt)("span",{parentName:"span",className:"mclose"},")"))))),".\nBy comparison, when ",(0,m.kt)("span",{parentName:"p",className:"math math-inline"},(0,m.kt)("span",{parentName:"span",className:"katex"},(0,m.kt)("span",{parentName:"span",className:"katex-mathml"},(0,m.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,m.kt)("semantics",{parentName:"math"},(0,m.kt)("mrow",{parentName:"semantics"},(0,m.kt)("mi",{parentName:"mrow"},"N")),(0,m.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"N")))),(0,m.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}}),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N")))))," is around a million, ",(0,m.kt)("span",{parentName:"p",className:"math math-inline"},(0,m.kt)("span",{parentName:"span",className:"katex"},(0,m.kt)("span",{parentName:"span",className:"katex-mathml"},(0,m.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,m.kt)("semantics",{parentName:"math"},(0,m.kt)("mrow",{parentName:"semantics"},(0,m.kt)("mi",{parentName:"mrow"},"N"),(0,m.kt)("mi",{parentName:"mrow"},"log"),(0,m.kt)("mo",{parentName:"mrow"},"\u2061"),(0,m.kt)("mi",{parentName:"mrow"},"N")),(0,m.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"N\\log N")))),(0,m.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8888799999999999em",verticalAlign:"-0.19444em"}}),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N"),(0,m.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,m.kt)("span",{parentName:"span",className:"mop"},"lo",(0,m.kt)("span",{parentName:"span",style:{marginRight:"0.01389em"}},"g")),(0,m.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N")))))," is only twenty million, while ",(0,m.kt)("span",{parentName:"p",className:"math math-inline"},(0,m.kt)("span",{parentName:"span",className:"katex"},(0,m.kt)("span",{parentName:"span",className:"katex-mathml"},(0,m.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,m.kt)("semantics",{parentName:"math"},(0,m.kt)("mrow",{parentName:"semantics"},(0,m.kt)("msup",{parentName:"mrow"},(0,m.kt)("mi",{parentName:"msup"},"N"),(0,m.kt)("mn",{parentName:"msup"},"2"))),(0,m.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"N^2")))),(0,m.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8141079999999999em",verticalAlign:"0em"}}),(0,m.kt)("span",{parentName:"span",className:"mord"},(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N"),(0,m.kt)("span",{parentName:"span",className:"msupsub"},(0,m.kt)("span",{parentName:"span",className:"vlist-t"},(0,m.kt)("span",{parentName:"span",className:"vlist-r"},(0,m.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8141079999999999em"}},(0,m.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,m.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,m.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,m.kt)("span",{parentName:"span",className:"mord mtight"},"2"))))))))))))," is a trillion."),(0,m.kt)("h2",{id:"quicksort"},"Quicksort"),(0,m.kt)("p",null,"We saw with insertion and selection sort that we could either do the hard word ",(0,m.kt)("em",{parentName:"p"},"after")," the recursion, when we insert into an already-sorted sublist, or ",(0,m.kt)("em",{parentName:"p"},"before")," the recursion, when we select and remove the smallest element.\nThe merge sort algorithm feels more like insertion sort, because the hard work, the merging, is done after the recursion that sorts the halves.\nThis should suggest that we look for an algorithm that will fill in the missing spot in this grid:"),(0,m.kt)("table",null,(0,m.kt)("thead",{parentName:"table"},(0,m.kt)("tr",{parentName:"thead"},(0,m.kt)("th",{parentName:"tr",align:"center"},"Subproblem Size"),(0,m.kt)("th",{parentName:"tr",align:"center"},"Easy Split, Hard Join"),(0,m.kt)("th",{parentName:"tr",align:"center"},"Hard Split, Easy Join"))),(0,m.kt)("tbody",{parentName:"table"},(0,m.kt)("tr",{parentName:"tbody"},(0,m.kt)("td",{parentName:"tr",align:"center"},(0,m.kt)("span",{parentName:"td",className:"math math-inline"},(0,m.kt)("span",{parentName:"span",className:"katex"},(0,m.kt)("span",{parentName:"span",className:"katex-mathml"},(0,m.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,m.kt)("semantics",{parentName:"math"},(0,m.kt)("mrow",{parentName:"semantics"},(0,m.kt)("mi",{parentName:"mrow"},"N"),(0,m.kt)("mo",{parentName:"mrow"},"\u2212"),(0,m.kt)("mn",{parentName:"mrow"},"1")),(0,m.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"N-1")))),(0,m.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"0.76666em",verticalAlign:"-0.08333em"}}),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N"),(0,m.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}}),(0,m.kt)("span",{parentName:"span",className:"mbin"},"\u2212"),(0,m.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}})),(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"0.64444em",verticalAlign:"0em"}}),(0,m.kt)("span",{parentName:"span",className:"mord"},"1")))))),(0,m.kt)("td",{parentName:"tr",align:"center"},"Insertion Sort"),(0,m.kt)("td",{parentName:"tr",align:"center"},"Selection Sort")),(0,m.kt)("tr",{parentName:"tbody"},(0,m.kt)("td",{parentName:"tr",align:"center"},(0,m.kt)("span",{parentName:"td",className:"math math-inline"},(0,m.kt)("span",{parentName:"span",className:"katex"},(0,m.kt)("span",{parentName:"span",className:"katex-mathml"},(0,m.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,m.kt)("semantics",{parentName:"math"},(0,m.kt)("mrow",{parentName:"semantics"},(0,m.kt)("mfrac",{parentName:"mrow"},(0,m.kt)("mi",{parentName:"mfrac"},"N"),(0,m.kt)("mn",{parentName:"mfrac"},"2"))),(0,m.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\frac{N}{2}")))),(0,m.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"1.217331em",verticalAlign:"-0.345em"}}),(0,m.kt)("span",{parentName:"span",className:"mord"},(0,m.kt)("span",{parentName:"span",className:"mopen nulldelimiter"}),(0,m.kt)("span",{parentName:"span",className:"mfrac"},(0,m.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,m.kt)("span",{parentName:"span",className:"vlist-r"},(0,m.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.872331em"}},(0,m.kt)("span",{parentName:"span",style:{top:"-2.6550000000000002em"}},(0,m.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3em"}}),(0,m.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,m.kt)("span",{parentName:"span",className:"mord mtight"},(0,m.kt)("span",{parentName:"span",className:"mord mtight"},"2")))),(0,m.kt)("span",{parentName:"span",style:{top:"-3.23em"}},(0,m.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3em"}}),(0,m.kt)("span",{parentName:"span",className:"frac-line",style:{borderBottomWidth:"0.04em"}})),(0,m.kt)("span",{parentName:"span",style:{top:"-3.394em"}},(0,m.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3em"}}),(0,m.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,m.kt)("span",{parentName:"span",className:"mord mtight"},(0,m.kt)("span",{parentName:"span",className:"mord mathdefault mtight",style:{marginRight:"0.10903em"}},"N"))))),(0,m.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,m.kt)("span",{parentName:"span",className:"vlist-r"},(0,m.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.345em"}},(0,m.kt)("span",{parentName:"span"}))))),(0,m.kt)("span",{parentName:"span",className:"mclose nulldelimiter"}))))))),(0,m.kt)("td",{parentName:"tr",align:"center"},"Merge Sort"),(0,m.kt)("td",{parentName:"tr",align:"center"},"?")))),(0,m.kt)("p",null,"As you should know from the title of this section, the missing algorithm is Quicksort.\nThe idea is that we will look at the values while splitting the list in two, in such a way that it will be trivial to join the parts back together after they are recursively sorted.\nThis implies that all of the elements in the first part need to be less than the elements in the second part.\nThe easiest way to ensure this is to choose a ",(0,m.kt)("strong",{parentName:"p"},"pivot")," element: elements less than the pivot go in the first part, and elements greater than the pivot go in the second part.\nElements that are equal to the pivot may go in either part.\nA simple (and not very good","\u2026",") choice for the pivot is the first element of the list; after using it to partition the rest of the list into two parts, we recursively sort those parts and then append them back together with the pivot element in between."),(0,m.kt)("p",null,"We may use the standard library function ",(0,m.kt)("inlineCode",{parentName:"p"},"List.filter")," to do the partitioning:"),(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-reason",metastring:"edit",edit:!0},"let partition = (pivot, nums) => {\n  (List.filter(n => n < pivot, nums), List.filter(n => n >= pivot, nums))\n};\n\npartition(3, [1, 4, 1, 5, 9, 2, 6, 5]);\n")),(0,m.kt)("p",null,"Now the quicksort function is very easy (making use of the ReasonML list append operator, ",(0,m.kt)("inlineCode",{parentName:"p"},"@"),"):"),(0,m.kt)("pre",null,(0,m.kt)("code",{parentName:"pre",className:"language-reason",metastring:"edit",edit:!0},"let rec quicksort = nums => {\n  switch (nums) {\n  | [] => []\n  | [pivot, ...rest] => {\n      let (first, second) = partition(pivot, rest);\n      quicksort(first) @ [pivot] @ quicksort(second)\n    }\n  }\n};\n\nquicksort([3, 1, 4, 1, 5, 9, 2, 6, 5]);\n")),(0,m.kt)("p",null,"The analysis of Quicksort is somewhat more difficult that the other sorts, however, because we do not know the sizes of the two parts that ",(0,m.kt)("inlineCode",{parentName:"p"},"partition")," will give us.\nIf the pivot is chosen at random, then we expect it to fall somewhere in the middle of the list, so the two parts will be roughly equal in size, and we get an ",(0,m.kt)("span",{parentName:"p",className:"math math-inline"},(0,m.kt)("span",{parentName:"span",className:"katex"},(0,m.kt)("span",{parentName:"span",className:"katex-mathml"},(0,m.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,m.kt)("semantics",{parentName:"math"},(0,m.kt)("mrow",{parentName:"semantics"},(0,m.kt)("mi",{parentName:"mrow"},"O"),(0,m.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,m.kt)("mi",{parentName:"mrow"},"N"),(0,m.kt)("mi",{parentName:"mrow"},"log"),(0,m.kt)("mo",{parentName:"mrow"},"\u2061"),(0,m.kt)("mi",{parentName:"mrow"},"N"),(0,m.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,m.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(N\\log N)")))),(0,m.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.02778em"}},"O"),(0,m.kt)("span",{parentName:"span",className:"mopen"},"("),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N"),(0,m.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,m.kt)("span",{parentName:"span",className:"mop"},"lo",(0,m.kt)("span",{parentName:"span",style:{marginRight:"0.01389em"}},"g")),(0,m.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N"),(0,m.kt)("span",{parentName:"span",className:"mclose"},")")))))," running time just as for merge sort.\nHowever, if we consistently choose a pivot that is either very small or very large (for example, if the list was already sorted, and we choose the head element, then the pivot will always be the smallest value!), then one of the parts will only have a few items while the other contains almost all of them.\nIn this worst case, the behavior of Quicksort approaches selection sort (which can be seen as the limiting case where we deliberately pivot on the smallest element), and it will run in ",(0,m.kt)("span",{parentName:"p",className:"math math-inline"},(0,m.kt)("span",{parentName:"span",className:"katex"},(0,m.kt)("span",{parentName:"span",className:"katex-mathml"},(0,m.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,m.kt)("semantics",{parentName:"math"},(0,m.kt)("mrow",{parentName:"semantics"},(0,m.kt)("mi",{parentName:"mrow"},"O"),(0,m.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,m.kt)("msup",{parentName:"mrow"},(0,m.kt)("mi",{parentName:"msup"},"N"),(0,m.kt)("mn",{parentName:"msup"},"2")),(0,m.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,m.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(N^2)")))),(0,m.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"1.064108em",verticalAlign:"-0.25em"}}),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.02778em"}},"O"),(0,m.kt)("span",{parentName:"span",className:"mopen"},"("),(0,m.kt)("span",{parentName:"span",className:"mord"},(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N"),(0,m.kt)("span",{parentName:"span",className:"msupsub"},(0,m.kt)("span",{parentName:"span",className:"vlist-t"},(0,m.kt)("span",{parentName:"span",className:"vlist-r"},(0,m.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8141079999999999em"}},(0,m.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,m.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,m.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,m.kt)("span",{parentName:"span",className:"mord mtight"},"2")))))))),(0,m.kt)("span",{parentName:"span",className:"mclose"},")")))))," time.\nIt is possible to show that, with a better way to choose the pivot, the quadratic worst case becomes very unlikely, and Quicksort will almost always run in ",(0,m.kt)("span",{parentName:"p",className:"math math-inline"},(0,m.kt)("span",{parentName:"span",className:"katex"},(0,m.kt)("span",{parentName:"span",className:"katex-mathml"},(0,m.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,m.kt)("semantics",{parentName:"math"},(0,m.kt)("mrow",{parentName:"semantics"},(0,m.kt)("mi",{parentName:"mrow"},"O"),(0,m.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,m.kt)("mi",{parentName:"mrow"},"N"),(0,m.kt)("mi",{parentName:"mrow"},"log"),(0,m.kt)("mo",{parentName:"mrow"},"\u2061"),(0,m.kt)("mi",{parentName:"mrow"},"N"),(0,m.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,m.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(N\\log N)")))),(0,m.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.02778em"}},"O"),(0,m.kt)("span",{parentName:"span",className:"mopen"},"("),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N"),(0,m.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,m.kt)("span",{parentName:"span",className:"mop"},"lo",(0,m.kt)("span",{parentName:"span",style:{marginRight:"0.01389em"}},"g")),(0,m.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N"),(0,m.kt)("span",{parentName:"span",className:"mclose"},")")))))," time, but we will not do this here."),(0,m.kt)("h2",{id:"exercises"},"Exercises"),(0,m.kt)("ol",null,(0,m.kt)("li",{parentName:"ol"},(0,m.kt)("p",{parentName:"li"},"Explain what will happen to the running time of each of the above sorting algorithms if the input is already sorted."),(0,m.kt)("details",{parentName:"li",className:"custom-block spoiler-block"},(0,m.kt)("summary",{parentName:"details",className:"custom-block-heading"},"Answer"),(0,m.kt)("div",{parentName:"details",className:"custom-block-body"},(0,m.kt)("p",{parentName:"div"},(0,m.kt)("inlineCode",{parentName:"p"},"insertion_sort")," will run in ",(0,m.kt)("span",{parentName:"p",className:"math math-inline"},(0,m.kt)("span",{parentName:"span",className:"katex"},(0,m.kt)("span",{parentName:"span",className:"katex-mathml"},(0,m.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,m.kt)("semantics",{parentName:"math"},(0,m.kt)("mrow",{parentName:"semantics"},(0,m.kt)("mi",{parentName:"mrow"},"O"),(0,m.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,m.kt)("mi",{parentName:"mrow"},"N"),(0,m.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,m.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(N)")))),(0,m.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.02778em"}},"O"),(0,m.kt)("span",{parentName:"span",className:"mopen"},"("),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N"),(0,m.kt)("span",{parentName:"span",className:"mclose"},")")))))," time, because each insertion will put its new element at the head of the result.\n",(0,m.kt)("inlineCode",{parentName:"p"},"insertion_sort_left")," will run in ",(0,m.kt)("span",{parentName:"p",className:"math math-inline"},(0,m.kt)("span",{parentName:"span",className:"katex"},(0,m.kt)("span",{parentName:"span",className:"katex-mathml"},(0,m.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,m.kt)("semantics",{parentName:"math"},(0,m.kt)("mrow",{parentName:"semantics"},(0,m.kt)("mi",{parentName:"mrow"},"O"),(0,m.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,m.kt)("msup",{parentName:"mrow"},(0,m.kt)("mi",{parentName:"msup"},"N"),(0,m.kt)("mn",{parentName:"msup"},"2")),(0,m.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,m.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(N^2)")))),(0,m.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"1.064108em",verticalAlign:"-0.25em"}}),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.02778em"}},"O"),(0,m.kt)("span",{parentName:"span",className:"mopen"},"("),(0,m.kt)("span",{parentName:"span",className:"mord"},(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N"),(0,m.kt)("span",{parentName:"span",className:"msupsub"},(0,m.kt)("span",{parentName:"span",className:"vlist-t"},(0,m.kt)("span",{parentName:"span",className:"vlist-r"},(0,m.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8141079999999999em"}},(0,m.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,m.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,m.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,m.kt)("span",{parentName:"span",className:"mord mtight"},"2")))))))),(0,m.kt)("span",{parentName:"span",className:"mclose"},")")))))," time, because each insertion will have to put its new element all the way at the end of the result.\nSelection sort does not depend on the order of the input, because it has to examine the entire list to find the smallest on each pass.\nMerge sort will always run in ",(0,m.kt)("span",{parentName:"p",className:"math math-inline"},(0,m.kt)("span",{parentName:"span",className:"katex"},(0,m.kt)("span",{parentName:"span",className:"katex-mathml"},(0,m.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,m.kt)("semantics",{parentName:"math"},(0,m.kt)("mrow",{parentName:"semantics"},(0,m.kt)("mi",{parentName:"mrow"},"O"),(0,m.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,m.kt)("mi",{parentName:"mrow"},"N"),(0,m.kt)("mi",{parentName:"mrow"},"log"),(0,m.kt)("mo",{parentName:"mrow"},"\u2061"),(0,m.kt)("mi",{parentName:"mrow"},"N"),(0,m.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,m.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(N\\log N)")))),(0,m.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.02778em"}},"O"),(0,m.kt)("span",{parentName:"span",className:"mopen"},"("),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N"),(0,m.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,m.kt)("span",{parentName:"span",className:"mop"},"lo",(0,m.kt)("span",{parentName:"span",style:{marginRight:"0.01389em"}},"g")),(0,m.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N"),(0,m.kt)("span",{parentName:"span",className:"mclose"},")")))))," time, because the best case for a merge operation is when everything in one list is smaller than everything in the other, and that only cuts the time by a factor of 2.\nQuicksort with the pivot taken as the head of the list exhibits its worst-case behavior, ",(0,m.kt)("span",{parentName:"p",className:"math math-inline"},(0,m.kt)("span",{parentName:"span",className:"katex"},(0,m.kt)("span",{parentName:"span",className:"katex-mathml"},(0,m.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,m.kt)("semantics",{parentName:"math"},(0,m.kt)("mrow",{parentName:"semantics"},(0,m.kt)("mi",{parentName:"mrow"},"O"),(0,m.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,m.kt)("msup",{parentName:"mrow"},(0,m.kt)("mi",{parentName:"msup"},"N"),(0,m.kt)("mn",{parentName:"msup"},"2")),(0,m.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,m.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(N^2)")))),(0,m.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,m.kt)("span",{parentName:"span",className:"base"},(0,m.kt)("span",{parentName:"span",className:"strut",style:{height:"1.064108em",verticalAlign:"-0.25em"}}),(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.02778em"}},"O"),(0,m.kt)("span",{parentName:"span",className:"mopen"},"("),(0,m.kt)("span",{parentName:"span",className:"mord"},(0,m.kt)("span",{parentName:"span",className:"mord mathdefault",style:{marginRight:"0.10903em"}},"N"),(0,m.kt)("span",{parentName:"span",className:"msupsub"},(0,m.kt)("span",{parentName:"span",className:"vlist-t"},(0,m.kt)("span",{parentName:"span",className:"vlist-r"},(0,m.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8141079999999999em"}},(0,m.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,m.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,m.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,m.kt)("span",{parentName:"span",className:"mord mtight"},"2")))))))),(0,m.kt)("span",{parentName:"span",className:"mclose"},")"))))),", as shown above.")))),(0,m.kt)("li",{parentName:"ol"},(0,m.kt)("p",{parentName:"li"},"Give an example of an input list that will cause the simple recursive version of ",(0,m.kt)("inlineCode",{parentName:"p"},"insertion_sort")," to exhibit its worst-case running time. That is, every insertion should need to traverse the entire list to find the correct insertion point."),(0,m.kt)("details",{parentName:"li",className:"custom-block spoiler-block"},(0,m.kt)("summary",{parentName:"details",className:"custom-block-heading"},"Answer"),(0,m.kt)("div",{parentName:"details",className:"custom-block-body"},(0,m.kt)("p",{parentName:"div"},"Any list sorted in reverse order will do.")))),(0,m.kt)("li",{parentName:"ol"},(0,m.kt)("p",{parentName:"li"},"Rewrite the ",(0,m.kt)("inlineCode",{parentName:"p"},"select_left")," function as an application of ",(0,m.kt)("inlineCode",{parentName:"p"},"List.fold_left")," to an appropriate reduction function. When ",(0,m.kt)("inlineCode",{parentName:"p"},"select_left(nums)")," is called on a non-empty list ",(0,m.kt)("inlineCode",{parentName:"p"},"nums"),", the initial value passed into the reduction should be the pair ",(0,m.kt)("inlineCode",{parentName:"p"},"(head, [])"),", representing the initial guess that the head of ",(0,m.kt)("inlineCode",{parentName:"p"},"nums")," is the smallest number, with an empty list of other numbers examined so far."),(0,m.kt)("details",{parentName:"li",className:"custom-block spoiler-block"},(0,m.kt)("summary",{parentName:"details",className:"custom-block-heading"},"Answer"),(0,m.kt)("div",{parentName:"details",className:"custom-block-body"},(0,m.kt)("pre",{parentName:"div"},(0,m.kt)("code",{parentName:"pre",className:"language-reason"},"let select_left2 = nums => {\n  let aux = ((small, rest), n) => {\n    if (n < small) {\n      (n, [small, ...rest])\n    } else {\n      (small, [n, ...rest])\n    }\n  };\n  switch (nums) {\n  | [head, ...tail] => List.fold_left(aux, (head, []), tail)\n  }\n};\n"))))),(0,m.kt)("li",{parentName:"ol"},(0,m.kt)("p",{parentName:"li"},"Find a way to write the selection sort algorithm using only tail-recursive functions. ",(0,m.kt)("em",{parentName:"p"},"Hint: Instead of selecting the smallest element, modify ",(0,m.kt)("inlineCode",{parentName:"em"},"select_left")," to separate out the largest element, then write a sorting function that accumulates the sorted list from back to front.")),(0,m.kt)("details",{parentName:"li",className:"custom-block spoiler-block"},(0,m.kt)("summary",{parentName:"details",className:"custom-block-heading"},"Answer"),(0,m.kt)("div",{parentName:"details",className:"custom-block-body"},(0,m.kt)("pre",{parentName:"div"},(0,m.kt)("code",{parentName:"pre",className:"language-reason"},"/* Precondition: nums is non-empty */\nlet select_max_left = nums => {\n  let rec aux = (nums, accum) => {\n    switch (nums) {\n    | [] => accum\n    | [head, ...tail] => {\n        let (large, rest) = accum;\n        if (head > large) {\n          aux(tail, (head, [large, ...rest]))\n        } else {\n          aux(tail, (large, [head, ...rest]))\n        }\n      }\n    }\n  };\n  \n  switch (nums) {\n  | [head, ...tail] => aux(tail, (head, []))\n  }\n};\n\nlet ssort = nums => {\n  let rec aux = (nums, sorted) => {\n    switch (nums) {\n    | [] => sorted\n    | _ => {\n        let (large, rest) = select_max_left(nums);\n                aux(rest, [large, ...sorted])\n          }\n    }\n    };\n  aux(nums, [])\n};\n"))))),(0,m.kt)("li",{parentName:"ol"},(0,m.kt)("p",{parentName:"li"},"Find a way to implement the ",(0,m.kt)("inlineCode",{parentName:"p"},"insert")," function using only tail-recursive functions.\n",(0,m.kt)("em",{parentName:"p"},"Hint: First write a tail-recursive function ",(0,m.kt)("inlineCode",{parentName:"em"},"reverse_append(a, b)")," that appends the reverse of list ",(0,m.kt)("inlineCode",{parentName:"em"},"a")," to the front of list ",(0,m.kt)("inlineCode",{parentName:"em"},"b"),", then\nuse a helper function to insert a number into a sorted list by collecting the front half of the list (the elements less than the number)\nin an accumulator; when the correct position is found for the number, use ",(0,m.kt)("inlineCode",{parentName:"em"},"reverse_append")," to move the accumulated elements back onto the front of the result.")),(0,m.kt)("details",{parentName:"li",className:"custom-block spoiler-block"},(0,m.kt)("summary",{parentName:"details",className:"custom-block-heading"},"Answer"),(0,m.kt)("div",{parentName:"details",className:"custom-block-body"},(0,m.kt)("pre",{parentName:"div"},(0,m.kt)("code",{parentName:"pre",className:"language-reason"},"let rec reverse_append = (a, b) => {\n  switch (a) {\n  | [] => b\n  | [head, ...tail] => reverse_append(tail, [head, ...b])\n  }\n};\n\n/* Precondition: nums is sorted in non-decreasing order */\nlet insert_TR = (nums, n) => {\n  let rec aux = (sorted, acc) => {\n    switch (sorted) {\n    | [] => reverse_append([n, ...acc], [])\n    | [head, ...tail] => if (n <= head) {\n        reverse_append(acc, [n, ...sorted])\n      } else {\n        aux(tail, [head, ...acc])\n      }\n    }\n  };\n  aux(nums, [])\n};\n"))))),(0,m.kt)("li",{parentName:"ol"},(0,m.kt)("p",{parentName:"li"},"Implement the merge sort ",(0,m.kt)("inlineCode",{parentName:"p"},"split")," function by first computing the size of the list, then passing half that size to a function that takes a number, n, and a list and returns a pair with the first n elements of the list as the first component, and the rest of the list as the other component."),(0,m.kt)("details",{parentName:"li",className:"custom-block spoiler-block"},(0,m.kt)("summary",{parentName:"details",className:"custom-block-heading"},"Answer"),(0,m.kt)("div",{parentName:"details",className:"custom-block-body"},(0,m.kt)("pre",{parentName:"div"},(0,m.kt)("code",{parentName:"pre",className:"language-reason"},"let split = nums => {\n  let rec size = nums => {\n    switch (nums) {\n    | [] => 0\n    | [_, ...tail] => 1 + size(tail)\n    }\n  };\n  let rec aux = (n, nums) => {\n    switch (n, nums) {\n    | (0, _) => ([], nums)\n    | (_, []) => ([], [])\n    | (_, [head, ...tail]) => {\n        let (left, right) = aux(n - 1, tail);\n        ([head, ...left], right)\n      }\n    }\n  };\n  let n = size(nums) / 2;\n  aux(n, nums)\n};\n"))))),(0,m.kt)("li",{parentName:"ol"},(0,m.kt)("p",{parentName:"li"},"The ",(0,m.kt)("inlineCode",{parentName:"p"},"partition")," implementation for Quicksort shown above makes two passes over the list, once for each call to ",(0,m.kt)("inlineCode",{parentName:"p"},"List.filter"),". Write a version of ",(0,m.kt)("inlineCode",{parentName:"p"},"partition")," that does the job in just one pass, accumulating a pair of the two parts as it traverses the list."),(0,m.kt)("details",{parentName:"li",className:"custom-block spoiler-block"},(0,m.kt)("summary",{parentName:"details",className:"custom-block-heading"},"Answer"),(0,m.kt)("div",{parentName:"details",className:"custom-block-body"},(0,m.kt)("pre",{parentName:"div"},(0,m.kt)("code",{parentName:"pre",className:"language-reason"},"let partition = (pivot, nums) => {\n  List.fold_left(\n    ((first, second), n) =>\n      if (n < pivot) {\n        ([n, ...first], second)\n      } else {\n        (first, [n, ...second])\n      },\n    ([], []),\n    nums\n  )\n};\n")))))),(0,m.kt)("div",{className:"footnotes"},(0,m.kt)("hr",{parentName:"div"}),(0,m.kt)("ol",{parentName:"div"},(0,m.kt)("li",{parentName:"ol",id:"fn-1"},"Well, it would be if we also modified the ",(0,m.kt)("inlineCode",{parentName:"li"},"insert")," function itself to be tail-recursive; this is left as an exercise.",(0,m.kt)("a",{parentName:"li",href:"#fnref-1",className:"footnote-backref"},"\u21a9")),(0,m.kt)("li",{parentName:"ol",id:"fn-2"},"In fact, when the compiler sees a tail-recursive call, it can essentially turn the recursive call into a loop back up to the top of the function, without needing to push a new function call on the stack. It is able to do this because it knows there is nothing left to do in the original call, so there is no need to return to where we left off.",(0,m.kt)("a",{parentName:"li",href:"#fnref-2",className:"footnote-backref"},"\u21a9")))))}h.isMDXComponent=!0}}]);